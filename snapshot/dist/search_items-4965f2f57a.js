searchNodes=[{"doc":"Introduction This documentation page describes a development version, for production systems please use the stable version instead. Astarte is a collection of components written in Elixir meant to orchestrate and pilot a number of 3rd party components. These components include: One or more ingresses (the most popular implementation being an MQTT broker) An AMQP broker for handling messages and queues between Astarte's services A Cassandra-like Database for ingesting and retrieving data (currently Cassandra and ScyllaDB are both supported) These components are never directly exposed to Astarte's end user, who requires no knowledge whatsoever of the mentioned frameworks - they are rather orchestrated and managed directly by Astarte's services. It is, however, responsability of Astarte's administrators to make sure these services are made available the way they are meant to. For more details on this topic and, in general, on how to deal with Astarte's installation and maintenance, please refer to the Administrator Guide .","ref":"001-intro_architecture.html","title":"Introduction","type":"extras"},{"doc":"Design Principles Astarte has a strongly opinionated design aimed at the generic IoT / data-driven use case. As such, and unlike other platforms, it strives to streamline a very simple user workflow for ingesting, distributing and retrieving data, built on a set of concepts and principles.","ref":"010-design_principles.html","title":"Design Principles","type":"extras"},{"doc":"Astarte does not allow exchanging raw data - it rather forces the user to describe data before it is sent into the platform. Data is described with a mechanism named Interfaces, explained in detail in the user guide . Through Interfaces, Astarte creates and maintains a data model autonomously, sparing the user from the complexity of dealing with Databases and Data Management in general.","ref":"010-design_principles.html#declarative-vs-explicit-data-management","title":"Design Principles - Declarative vs. Explicit Data Management","type":"extras"},{"doc":"Astarte services use a Protobuf-based API to exchange data over AMQP in a gRPC like fashion. As such, as long as a service conforms with the policies defined by the queues, it is possible to extend Astarte in virtually any language that can deliver a compliant AMQP client.","ref":"010-design_principles.html#amqp-as-internal-api-mechanism","title":"Design Principles - AMQP as internal API mechanism","type":"extras"},{"doc":"Astarte identifies each device with a 128 bit Device ID which has to be unique within its Realm. As a best practice, it is advised to generate such an ID from hardware unique IDs or using dedicated hardware modules, to make it consistent across device reflashes. It is advised to use a cryptographic hash function (such as sha256) when generating it using a software module. Astarte will use URL encoded base64 (without padding) strings like V_zv6ThCCtXWveQ8mPjsKg in its representation. Although not required, it is strongly advised to use UUIDs as Astarte Device IDs. In fact, Astarte Device ID's specification is 100% compatible with UUIDs Base64 encoded adhering to RFC 7515. In the same fashion, UUIDv5 can be used to generate a deterministic Device ID from any kind of input data. Astarte Clients which generate Astarte Device IDs (such as astartectl or Astarte Dashboard) will always generate a Device ID out of UUIDv4 (random ID) or UUIDv5 (deterministic ID). This detail is relevant not only for identifying and querying the device, but also for the Pairing mechanism , as a device's credentials are associated to its Device ID. Note: currently, Astarte accepts Device IDs longer than 128 bit, which are then truncated to 128 bit internally. This behaviour exists for compatibility reasons but it's not supported and will likely change in future releases - hence, refrain from using anything which is not a 128-bit Device ID. Note: As much as Device IDs should effectively be unique per-realm and this configuration will always be supported, some future optional optimizations might be available on top of the assumption that Device IDs are globally unique to an Astarte installation. Given the Device ID format has a 2&lt;sup&gt;-128&lt;/sup&gt; chance of collision, it is safe to assume that as long as best practices for Device ID generation are followed, Device IDs will always be globally unique.","ref":"010-design_principles.html#device-id","title":"Design Principles - Device ID","type":"extras"},{"doc":"Astarte assumes devices are capable of exchanging data over a transport/protocol supporting SSL/TLS (e.g.: MQTT). This is a strong requirement, as Astarte identifies devices through client SSL certificates when it comes to data exchange. Each transport implementation must be capable of mapping interfaces and out-of-band messages on top of it. Astarte itself does not care about the implementation detail of the transport itself, as the transport is in charge of converting its input to an AMQP message following Astarte's internal API specification. Astarte's official reference and recommended design is MQTT using VerneMQ and its Astarte plugin. Device SDK and code generation Device SDKs can take advantage of the interface design to dynamically generate code for exchanging data with Astarte. This way, developers using Device SDKs are spared from knowing details about the underlying transports and protocols, and can use a data-driven API. However, there are some limitations and requirements: The SDK requires SSL support - Astarte does not allow exchanging data over unencrypted channels and its design builds on the assumption that everything runs on top of SSL. If your device isn't capable of SSL, you are probably looking for Gateway support in Astarte. As much as the SDK can implement virtually any transport protocol, it is required that the SDK supports at least HTTP(s) for Pairing.","ref":"010-design_principles.html#device-interaction","title":"Design Principles - Device interaction","type":"extras"},{"doc":"Astarte is natively multitenant through the concept of Realms. Each Realm is a logical portion of Astarte, and usually represents an organization or, in general, a set of devices physically/logically isolated. Realms build upon the concept of keyspaces in Cassandra. Each Realm has its very own keyspace and has no shared data with other Realms. In fact, it is even possible to have a dedicated Cassandra cluster for a single realm in complex installations.","ref":"010-design_principles.html#realms-and-multitenancy","title":"Design Principles - Realms and multitenancy","type":"extras"},{"doc":"In Astarte, transports are given the task to deliver messages in a well-known AMQP structure. The ordering of such messages is then preserved on a set of criterias: There is no such thing as &quot;in-order&quot; among devices. A message X sent to device A can be processed after a message Y sent to device B even if Y was ingested in the AMQP queue before X. This is intentional and by design. All messages to a specific device A are always guaranteed to be processed in the very same order of the transport ingestion. Ordering is not dependent on the message timestamp, which can be set by different sources (depending on the interface's definition of timestamp). For example, interface A has explicit timestamping while interface B doesn't. Message X from A has an earlier timestamp than message Y from B, but if message Y has been ingested before X, Y will be processed before X regardless. Responsibility of message ordering before entering AMQP is entirely up to the transport, and different transports might have different behaviors when it comes to message ordering. Astarte provides this guarantee right after the transport itself. Message ordering concerns only pipelines in the DUP , including but not limited to data ingestion in the Database and Simple Triggers.","ref":"010-design_principles.html#message-ordering","title":"Design Principles - Message Ordering","type":"extras"},{"doc":"Triggers are rules which are &quot;triggered&quot; whenever one or more conditions are satisfied. Every satisfied condition generates an ordered event for the Trigger Engine to be processed. They are one of the core concepts in Astarte and are the preferred way to handle push interactions between Astarte and connected applications. More details about triggers can be found in the dedicated section .","ref":"010-design_principles.html#triggers","title":"Design Principles - Triggers","type":"extras"},{"doc":"Components Astarte is a distributed system interacting over AMQP, as explained in Design Principles . This is an overview of its main internal services.","ref":"020-components.html","title":"Components","type":"extras"},{"doc":"Pairing takes care of Device Authentication and Authorization. It interacts with Astarte's CA and orchestrates the way devices connect and interact with Transports. It also handles Device Registration. Agent, Device and Pairing interaction is described in detail here .","ref":"020-components.html#pairing","title":"Components - Pairing","type":"extras"},{"doc":"Data Updater Plant is a replicable, scalable component which takes care of the ingestion pipeline. It gathers data from devices and orchestrates data flow amongst other components. It is, arguably, the most critical component of the system and the most resource hungry - the way DUP is deployed, replicated and configured has a tremendous impact on Astarte's performances, especially when dealing with massive data flows.","ref":"020-components.html#data-updater-plant-dup","title":"Components - Data Updater Plant (DUP)","type":"extras"},{"doc":"Trigger Engine takes care of processing Triggers. It is a purely computational component which handles every Trigger's pipeline and triggers actions accordingly.","ref":"020-components.html#trigger-engine","title":"Components - Trigger Engine","type":"extras"},{"doc":"AppEngine is Astarte's main API endpoint for end users. AppEngine exposes a RESTful API to retrieve and send data from/to devices, according to their interfaces. Every direct device interaction can be done from here. It also exposes Channels, a WebSocket-based solution for listening to device events in real-time with Triggers' same mechanism and semantics.","ref":"020-components.html#appengine","title":"Components - AppEngine","type":"extras"},{"doc":"Realm Management is an administrator-like API for configuring a Realm. It is used for managing Interfaces and Triggers.","ref":"020-components.html#realm-management","title":"Components - Realm Management","type":"extras"},{"doc":"Housekeeping is the equivalent of a superadmin API. It is usually not accessible to the end user but rather to Astarte's administrator who, in most cases, might deny overall outside access. It allows to manage and create Realms, and perform cluster-wide maintenance actions.","ref":"020-components.html#housekeeping","title":"Components - Housekeeping","type":"extras"},{"doc":"Interfaces Interfaces are a core concept of Astarte which defines how data is exchanged between Astarte and its peers. They are not to be intended as OOP interfaces, but rather as the following definition: In computing, an interface is a shared boundary across which two or more separate components of a computer system exchange information. In Astarte each interface has an owner, can represent either a continuous data stream or a snapshot of a set of properties, and can be either aggregated into an object or be an independent set of individual members. If you are already familiar with interface's basic concepts, you might want to jump directly to the Interface Schema .","ref":"030-interface.html","title":"Interfaces","type":"extras"},{"doc":"Interfaces are versioned, each interface having both a major version and a minor version number. The concept behind these two version numbers mimics Semantic Versioning : arbitrary changes can happen exclusively between different major versions (e.g. removing members, changing types, etc...), whereas minor versions allow incremental additive changes only (e.g. adding members). Several different major versions of the same interface can coexist at the same time in Astarte, although a Device can hold only a single version of an interface at a time (even though interfaces can be updated over time). Interfaces, internally, are univocally identified by their name and their major version.","ref":"030-interface.html#versioning","title":"Interfaces - Versioning","type":"extras"},{"doc":"Interfaces are described using a JSON document. Each interface is identified by an unique interface name of maximum 128 characters, which must be a Reverse Domain Name . As a convention, the interface name usually contains its author's URI Reverse Internet Domain Name. An example skeleton looks like this: { &quot;interface_name&quot;: &quot;com.test.MyInterfaceName&quot;, &quot;version_major&quot;: 1, &quot;version_minor&quot;: 0, [...] } Valid values and variables are listed in the Interface Schema . Name limitations A valid interface name consists of a Reverse Domain Name containing alphanumeric characters, hyphens and dots. By design, both the top level domain and last domain component can not contain hyphens, although hypens are allowed in other parts of the interface name (e.g.: org.astarte-platform.Values is a valid interface name). Interface names have to be fully-defined Reverse Domain Names. Values will not be accepted as an Astarte interface name, whereas org.astarte-platform.Values is a valid one. Interface's uniqueness is case insensitive - this means you cannot install two interfaces with the same name and different casing (e.g.: org.astarte-platform.MyValues and org.astarte-platform.Myvalues ). This also applies to Major versioning: interfaces sharing the same name with a different major version cannot have different casing. Although not enforced, naming conventions for Astarte Interfaces require lowercasing for anything but the last part of the Interface name, which should be CamelCase. Valid examples are: org.astarte-platform.conventions.ValidInterfaceName org.astarte-platform.ValidInterfaceName org.astarte-platform.conventions.satisfied.ValidInterfaceName Non-valid examples are: org.astarte-platform.Conventions.ValidInterfaceName org.astarte-platform.validInterfaceName org.astarte-platform.Conventions.satisfied.ValidInterfaceName","ref":"030-interface.html#format","title":"Interfaces - Format","type":"extras"},{"doc":"Interfaces have a well-known, predefined type, which can be either property or datastream . Every Device in Astarte can have any number of interfaces of any different types. Datastream datastream represents a mutable, ordered stream of data, with no concept of persistent state or synchronization. As a rule of thumb, datastream interfaces should be used when dealing with values such as sensor samples, commands and events. datastream are stored as time series in the database, making them suitable for time span filtering and any other common time series operation, and they are not idempotent in the REST API semantics. Due to their nature, datastream interfaces have a number of additional properties which fine tune their behavior. Properties properties represent a persistent, stateful, synchronized state with no concept of history or timestamping. properties are useful, for example, when dealing with settings, states or policies/rules. properties are stored in a key-value fashion, and grouped according to their interface, and they are idempotent in the REST API semantics. Rather than being able to act on a stream like in the datastream case, properties can be retrieved, or can be used as a trigger whenever they change. Values in a properties interface can be unset (or deleted according to the http jargon): to allow such a thing, the interface must have its allow_unset property set to true . Please refer to the JSON Schema for further details.","ref":"030-interface.html#interface-type","title":"Interfaces - Interface Type","type":"extras"},{"doc":"Astarte's design mandates that each interface has an owner. The owner of an interface has a write-only access to it, whereas other actors have read-only access. Interface ownership can be either device or server : the owner is the actor producing the data, whereas the other actor consumes data.","ref":"030-interface.html#ownership","title":"Interfaces - Ownership","type":"extras"},{"doc":"Every interface must have an array of mappings. Mappings are designed around REST controller semantics: each mapping describes an endpoint which is resolved to a path, it is strongly typed, and can have additional options. Just like in REST controllers, Endpoints can be parametrized to build REST-like collection and trees. Parameters are identified by %{parameterName} , with each endpoint supporting any number of parameters (see Limitations ). This is how a parametrized mapping looks like: [...] &quot;mappings&quot;: [ { &quot;endpoint&quot;: &quot;/%{itemIndex}/value&quot;, &quot;type&quot;: &quot;integer&quot;, &quot;reliability&quot;: &quot;unique&quot;, &quot;retention&quot;: &quot;discard&quot; }, [...] In this example, /0/value , /1/value or /test/value all map to a valid endpoint, while /te/st/value can't be resolved by any endpoint. Supported data types The following types are supported: double : A double-precision floating-point number as specified by binary64, by the IEEE 754 standard (NaNs and other non numerical values are not supported). integer : A signed 32 bit integer. boolean : Either true or false , adhering to JSON boolean type. longinteger : A signed 64 bit integer (please note that longinteger is represented as a string by default in JSON-based APIs.). string : An UTF-8 string, at most 65536 bytes long. binaryblob : An arbitrary sequence of any byte that should be shorter than 64 KiB. ( binaryblob is represented as a base64 string by default in JSON-based APIs.). datetime : A UTC timestamp, internally represented as milliseconds since 1st Jan 1970 using a signed 64 bits integer. ( datetime is represented as an ISO 8601 string by default in JSON based APIs.) doublearray , integerarray , booleanarray , longintegerarray , stringarray , binaryblobarray , datetimearray : A list of values, represented as a JSON Array. Arrays can have up to 1024 items and each item must respect the limits of its scalar type ( i.e. each string in a stringarray must be at most 65535 bytes long, each binary blob in a binaryblobarray must be shorter than 64 KiB. Make sure that the differences between two distinct interface names are not limited to the casing or the presence of hyphens. This situation leads to a collision in the interface names which brings to an error in the interface installation process. A valid interface must resolve a path univocally to a single endpoint. Take the following example: [...] &quot;mappings&quot;: [ { &quot;endpoint&quot;: &quot;/%{itemIndex}/value&quot;, &quot;type&quot;: &quot;integer&quot; }, { &quot;endpoint&quot;: &quot;/myPath/value&quot;, &quot;type&quot;: &quot;integer&quot; }, [...] In such a case, the interface isn't valid and is rejected, due to the fact that path /myPath/value is ambiguous and could be resolved to two different endpoints. Any endpoint configuration must not generate paths that are prefix of other paths, for this reason the following example is also invalid: [...] &quot;mappings&quot;: [ { &quot;endpoint&quot;: &quot;/some/thing&quot;, &quot;type&quot;:&quot;integer&quot; }, { &quot;endpoint&quot;: &quot;/some/%{param}/value&quot;, &quot;type&quot;: &quot;integer&quot; }, [...] In case the interface's aggregation is object , additional restrictions apply. Endpoints in the same interface must all have the same depth, and the same number of parameters. If the interface is parametrized, every endpoint must have the same parameter name at the same level. This is an example of a valid aggregated interface mapping: [...] &quot;mappings&quot;: [ { &quot;endpoint&quot;: &quot;/%{itemIndex}/value&quot;, &quot;type&quot;: &quot;integer&quot; }, { &quot;endpoint&quot;: &quot;/%{itemIndex}/otherValue&quot;, &quot;type&quot;: &quot;string&quot; }, [...]","ref":"030-interface.html#mappings","title":"Interfaces - Mappings","type":"extras"},{"doc":"In a real world scenario, such as an array of sensors, there are usually two main cases. A sensor might have one or more independent values which are sampled individually and sent whenever they become available independently. Or a sensor might sample at the same time a number of values, which might as well have some form of correlation. In Astarte, this concept is mapped to interface aggregation . In case aggregation is individual , each mapping is treated as an independent value and is managed individually. In case aggregation is object , Astarte expects the owner to send all of the interface's mappings at the same time, packed in a single message. In this case, all of the mappings share some core properties such as the timestamp. Aggregation is a powerful mechanism that can be used to map interfaces to real world &quot;objects&quot; . Moreover, aggregated interfaces can also be parametrized, although with some limitations . Endpoints and aggregation Since Astarte 0.11, Aggregations cannot have endpoints with depth 1. This was an erroneously allowed behavior in Astarte 0.10 which is kept for retrocompatibility - however, new interfaces should ensure each endpoint in an aggreate has at least depth 2, as support for depth 1 will be removed in a future release. This change has been done to be consistent with AppEngine API design, and to ensure that path / is not ambiguous. This is the correct way to set up a valid endpoint structure for an aggregate: [...] &quot;mappings&quot;: [ { &quot;endpoint&quot;: &quot;/objects/value&quot;, &quot;type&quot;: &quot;integer&quot; }, { &quot;endpoint&quot;: &quot;/objects/otherValue&quot;, &quot;type&quot;: &quot;string&quot; }, [...] The following structure, instead, is deprecated: [...] &quot;mappings&quot;: [ { &quot;endpoint&quot;: &quot;/value&quot;, &quot;type&quot;: &quot;integer&quot; }, { &quot;endpoint&quot;: &quot;/otherValue&quot;, &quot;type&quot;: &quot;string&quot; }, [...]","ref":"030-interface.html#aggregation","title":"Interfaces - Aggregation","type":"extras"},{"doc":"datastream interfaces are highly tunable, depending on the kind of data they are representing: it is possible to fine tune several aspects of how data is stored, transferred and indexed. The following properties can be set at mapping level. NOTE: In case the interface is aggregated, additional properties must be the same for each mapping. explicit_timestamp : By default, Astarte associates a timestamp to data whenever it is collected (or - when the message hits the data collection stage). However, when setting this property to true , Astarte expects the owner to attach a valid timestamp each time it produces data. In that case, the provided timestamp is used for indexing. reliability : Each mapping can be unreliable (default), guaranteed , unique . This defines whether data should be considered delivered when the transport successfully sends the data regardless of the outcome ( unreliable ), when data has been received at least once by the recipient ( guaranteed ) or when data has been received exactly once by the recipient ( unique ). When using reliable data, consider you might incur in additional resource usage on both the transport and the device's end. retention : Each mapping can have a discard (default), volatile , stored retention. This defines whether data should be discarded if the transport is temporarily uncapable of delivering it ( discard ), should be kept in a cache in memory ( volatile ) or on disk ( stored ), and guaranteed to be delivered in the timeframe defined by the expiry . expiry : Meaningful only when retention is stored . Defines how many seconds a specific data entry should be kept before giving up and erasing it from the persistent cache. A value &lt;= 0 means the persistent cache never expires, and is the default. database_retention_policy : Useful only with datastream. Defines whether data should expire from the database after a given interval. Valid values are: no_ttl and use_ttl. database_retention_ttl : Useful when database_retention_policy is &quot;use_ttl&quot; . Defines how many seconds a specific data entry should be kept before erasing it from the database.","ref":"030-interface.html#datastream-specific-features","title":"Interfaces - Datastream-specific features","type":"extras"},{"doc":"When creating interface drafts, or for testing purposes in general, it is recommended to use 0 as the major version, to make maintenance and testing easier. Currently, Astarte allows only interfaces with major_version == 0 to be deleted, and this limitation will probably be never lifted to prevent data loss. When sending real time commands in datastream interfaces, discard is usually the best option. Even though it does not guarantee delivery, it prevents users from unwillingly sending the same command over and over if the recipient isn't available, causing a queue of commands to be sent to the recipient when it gets back online. In general, retention should be used to keep track of low traffic/important events","ref":"030-interface.html#best-practices","title":"Interfaces - Best practices","type":"extras"},{"doc":"Interface Schema The schema contains the following objects: Interface (root object) Mapping","ref":"040-interface_schema.html","title":"Interface Schema","type":"extras"},{"doc":"This schema describes how an Astarte interface should be declared Properties Type Description Required interface_name string The name of the interface. This has to be an unique, alphanumeric reverse internet domain name, shorther than 128 characters. ✔ Yes version_major integer A Major version qualifier for this interface. Interfaces with the same id and different version_major number are deemed incompatible. It is then acceptable to redefine any property of the interface when changing the major version number. ✔ Yes version_minor integer A Minor version qualifier for this interface. Interfaces with the same id and major version number and different version_minor number are deemed compatible between each other. When changing the minor number, it is then only possible to insert further mappings. Any other modification might lead to incompatibilities and undefined behavior. ✔ Yes type string Identifies the type of this Interface. Currently two types are supported: datastream and properties. datastream should be used when dealing with streams of non-persistent data, where a single path receives updates and there's no concept of state. properties, instead, are meant to be an actual state and as such they have only a change history, and are retained. ✔ Yes ownership string Identifies the quality of the interface. Interfaces are meant to be unidirectional, and this property defines who's sending or receiving data. device means the device/gateway is sending data to Astarte, consumer means the device/gateway is receiving data from Astarte. Bidirectional mode is not supported, you should instantiate another interface for that. ✔ Yes aggregation string Identifies the aggregation of the mappings of the interface. Individual means every mapping changes state or streams data independently, whereas an object aggregation treats the interface as an object, making all the mappings changes interdependent. Choosing the right aggregation might drastically improve performances. No, default: &quot;individual&quot; explicit_timestamp boolean Allow to set a custom timestamp, otherwise a timestamp is added when the message is received. If true explicit timestamp will also be used for sorting. This feature is only supported on datastreams. No, default: false description string An optional description of the interface. No doc string A string containing documentation that will be injected in the generated client code. No mappings Astarte Mapping Schema [1-1024] Mappings define the endpoint of the interface, where actual data is stored/streamed. They are defined as relative URLs (e.g. /my/path) and can be parametrized (e.g.: /%{myparam}/path). A valid interface must have no mappings clash, which means that every mapping must resolve to a unique path or collection of paths (including parametrization). Every mapping acquires type, quality and aggregation of the interface. ✔ Yes Additional properties are allowed. astarte.interface.schema.interface_name ✔ The name of the interface. This has to be an unique, alphanumeric reverse internet domain name, shorther than 128 characters. Type : string Required : Yes Minimum Length : &gt;= 1 astarte.interface.schema.version_major ✔ A Major version qualifier for this interface. Interfaces with the same id and different version_major number are deemed incompatible. It is then acceptable to redefine any property of the interface when changing the major version number. Type : integer Required : Yes astarte.interface.schema.version_minor ✔ A Minor version qualifier for this interface. Interfaces with the same id and major version number and different version_minor number are deemed compatible between each other. When changing the minor number, it is then only possible to insert further mappings. Any other modification might lead to incompatibilities and undefined behavior. Type : integer Required : Yes astarte.interface.schema.type ✔ Identifies the type of this Interface. Currently two types are supported: datastream and properties. datastream should be used when dealing with streams of non-persistent data, where a single path receives updates and there's no concept of state. properties, instead, are meant to be an actual state and as such they have only a change history, and are retained. Type : string Required : Yes Allowed values : &quot;datastream&quot; &quot;properties&quot; astarte.interface.schema.ownership ✔ Identifies the quality of the interface. Interfaces are meant to be unidirectional, and this property defines who's sending or receiving data. device means the device/gateway is sending data to Astarte, consumer means the device/gateway is receiving data from Astarte. Bidirectional mode is not supported, you should instantiate another interface for that. Type : string Required : Yes Allowed values : &quot;device&quot; &quot;server&quot; astarte.interface.schema.aggregation Identifies the aggregation of the mappings of the interface. Individual means every mapping changes state or streams data independently, whereas an object aggregation treats the interface as an object, making all the mappings changes interdependent. Choosing the right aggregation might drastically improve performances. Type : string Required : No, default: &quot;individual&quot; Allowed values : &quot;individual&quot; &quot;object&quot; astarte.interface.schema.explicit_timestamp Allow to set a custom timestamp, otherwise a timestamp is added when the message is received. If true explicit timestamp will also be used for sorting. This feature is only supported on datastreams. Type : boolean Required : No, default: false astarte.interface.schema.description An optional description of the interface. Type : string Required : No astarte.interface.schema.doc A string containing documentation that will be injected in the generated client code. Type : string Required : No astarte.interface.schema.mappings ✔ Mappings define the endpoint of the interface, where actual data is stored/streamed. They are defined as relative URLs (e.g. /my/path) and can be parametrized (e.g.: /%{myparam}/path). A valid interface must have no mappings clash, which means that every mapping must resolve to a unique path or collection of paths (including parametrization). Every mapping acquires type, quality and aggregation of the interface. Type : Astarte Mapping Schema [1-1024] Each element in the array must be unique. Required : Yes","ref":"040-interface_schema.html#interface","title":"Interface Schema - Interface","type":"extras"},{"doc":"Identifies a mapping for an interface. A mapping must consist at least of an endpoint and a type. Properties Type Description Required endpoint string The template of the path. This is a UNIX-like path (e.g. /my/path) and can be parametrized. Parameters are in the %{name} form, and can be used to create interfaces which represent dictionaries of mappings. When the interface aggregation is object, an object is composed by all the mappings for one specific parameter combination. ✔ Yes type string Defines the type of the mapping. ✔ Yes reliability string Useful only with datastream. Defines whether the sent data should be considered delivered when the transport successfully sends the data (unreliable), when we know that the data has been received at least once (guaranteed) or when we know that the data has been received exactly once (unique). unreliable by default. When using reliable data, consider you might incur in additional resource usage on both the transport and the device's end. No, default: &quot;unreliable&quot; retention string Useful only with datastream. Defines whether the sent data should be discarded if the transport is temporarily uncapable of delivering it (discard) or should be kept in a cache in memory (volatile) or on disk (stored), and guaranteed to be delivered in the timeframe defined by the expiry. discard by default. No, default: &quot;discard&quot; expiry integer Useful when retention is stored. Defines after how many seconds a specific data entry should be kept before giving up and erasing it from the persistent cache. A value &lt;= 0 means the persistent cache never expires, and is the default. No, default: 0 database_retention_policy string Useful only with datastream. Defines whether data should expire from the database after a given interval. Valid values are: no_ttl and use_ttl. No, default: &quot;no_ttl&quot; database_retention_ttl integer Useful when database_retention_policy is &quot;use_ttl&quot; . Defines how many seconds a specific data entry should be kept before erasing it from the database. No allow_unset boolean Used only with properties. Used with producers, it generates a method to unset the property. Used with consumers, it generates code to call an unset method when an empty payload is received. No, default: false description string An optional description of the mapping. No doc string A string containing documentation that will be injected in the generated client code. No Additional properties are allowed. astarte.mapping.schema.endpoint ✔ The template of the path. This is a UNIX-like path (e.g. /my/path) and can be parametrized. Parameters are in the %{name} form, and can be used to create interfaces which represent dictionaries of mappings. When the interface aggregation is object, an object is composed by all the mappings for one specific parameter combination. Type : string Required : Yes Minimum Length : &gt;= 2 astarte.mapping.schema.type ✔ Defines the type of the mapping. Type : string Required : Yes Allowed values : &quot;double&quot; &quot;integer&quot; &quot;boolean&quot; &quot;longinteger&quot; &quot;string&quot; &quot;binaryblob&quot; &quot;datetime&quot; &quot;doublearray&quot; &quot;integerarray&quot; &quot;booleanarray&quot; &quot;longintegerarray&quot; &quot;stringarray&quot; &quot;binaryblobarray&quot; &quot;datetimearray&quot; astarte.mapping.schema.reliability Useful only with datastream. Defines whether the sent data should be considered delivered when the transport successfully sends the data (unreliable), when we know that the data has been received at least once (guaranteed) or when we know that the data has been received exactly once (unique). unreliable by default. When using reliable data, consider you might incur in additional resource usage on both the transport and the device's end. Type : string Required : No, default: &quot;unreliable&quot; Allowed values : &quot;unreliable&quot; &quot;guaranteed&quot; &quot;unique&quot; astarte.mapping.schema.retention Useful only with datastream. Defines whether the sent data should be discarded if the transport is temporarily uncapable of delivering it (discard) or should be kept in a cache in memory (volatile) or on disk (stored), and guaranteed to be delivered in the timeframe defined by the expiry. discard by default. Type : string Required : No, default: &quot;discard&quot; Allowed values : &quot;discard&quot; &quot;volatile&quot; &quot;stored&quot; astarte.mapping.schema.expiry Useful when retention is stored. Defines after how many seconds a specific data entry should be kept before giving up and erasing it from the persistent cache. A value &lt;= 0 means the persistent cache never expires, and is the default. Type : integer Required : No, default: 0 astarte.mapping.schema.database_retention_policy Useful only with datastream. Defines whether data is expired from the database after a given time to live interval. When &quot;no_ttl&quot; is used data are not expired. Type : string Required : No astarte.mapping.schema.database_retention_ttl Useful when database_retention_policy is &quot;use_ttl&quot; . Defines how many seconds a specific data entry should be kept before erasing it from the database. Type : integer Required : No astarte.mapping.schema.allow_unset Used only with properties. Used with producers, it generates a method to unset the property. Used with consumers, it generates code to call an unset method when an empty payload is received. Type : boolean Required : No, default: false astarte.mapping.schema.description An optional description of the mapping. Type : string Required : No astarte.mapping.schema.doc A string containing documentation that will be injected in the generated client code. Type : string Required : No","ref":"040-interface_schema.html#mapping","title":"Interface Schema - Mapping","type":"extras"},{"doc":"Pairing Mechanism Astarte's Pairing is a unified mechanism for Registering Devices and obtaining Transport Credentials . Even though in Astarte each Transport is free to choose its own Authentication mechanisms and Credentials autonomously, Pairing defines a well-known mechanism for Registering Devices and for orchestrating the exchange of Transport Credentials . Pairing is the main endpoint which orchestrates Device Authentication in Astarte, abstracting all details.","ref":"050-pairing_mechanism.html","title":"Pairing Mechanism","type":"extras"},{"doc":"","ref":"050-pairing_mechanism.html#authentication-flow","title":"Pairing Mechanism - Authentication flow","type":"extras"},{"doc":"Each device is identified by a Device ID and, on top of that, it has two different credentials directly associated to its ID: Credentials Secret and Transport Credentials . Credentials Secret is a shared secret between Astarte and a Device, which are used only to authenticate against Pairing API. Each device has a single Credentials Secret which remains valid throughout its whole lifecycle, and cannot be changed (unless operating manually). Transport Credentials are Transport-specific credentials usually orchestrated by Pairing. Pairing emits these Credentials through a policy which is usually imposed by the Authority emitting the Credentials or by Pairing itself. They are designed to be transient, revokable and reasonably short-lived - however, the actual behavior and their lifecycle is entirely orchestrated by the Authority emitting them. The emission of Transport Credentials can be inhibited for a specific Device, you can read how to do that in the User Guide Transports, by design, have no knowledge nor access to Credentials Secret , but have full authority over the authentication mechanism for devices. In fact, each Transport is free to choose the authentication mechanism which fits it best. Credentials Secret storage recommendations As losing or disclosing a Credentials Secret might mean a device is compromised or requires manual intervention to be fixed and secured, storing it appropriately is critical. Usually, when it comes to embedded devices, it is advised to store the Credentials Secret into an OTP, if available. Otherwise, storing it into the bootloader's variables is a viable and safe alternative. Other options might be having a separate, isolated storage containing Credentials Secret . In general, Astarte SDK does not provide a streamlined mechanism for retrieving Credentials Secret as the storage detail is strongly dependent on the target hardware - device developers should implement the safest strategy which better complies with their policies. Tuning devices for security is out of the scope of this guide, however it is advised to make sure only Astarte SDK has access to Credentials Secret .","ref":"050-pairing_mechanism.html#credentials-secret-vs-transport-credentials","title":"Pairing Mechanism - Credentials Secret vs. Transport Credentials","type":"extras"},{"doc":"Whenever possible, Transports are advised to implement their Authentication through the use of SSL certificates and a certificate authority by using Mutual Authentication , to ensure identities of the endpoint and the client are well-known to each other - this is especially the case with Astarte's MQTT Protocol on top of VerneMQ Transport. In this case, Transport Credentials are a SSL Certificate, and Pairing will interact with a Certificate Authority. The certificate rotates depending on the emission policy of the CA and can be renewed and invalidated countless times over the device lifecycle. The Certificate is a transient, asymmetric, device-specific, non-critical Transport Credential which can be in turn used to authenticate against the chosen Transport. In this case, Transports should have no knowledge nor access to secrets or Authorization details: they rather have to comply with the configured CA and the certificate parsing, as the Certificate contains all needed information for Authorization as well. Mutual SSL Authentication Flow Side note: the Transport usually bears the public certificate of the CA, and actually interacts with the CA itself only if it exposes an OCSP endpoint and the Transport is capable of understanding it. In case the CA exposes a CRL, the Transport just makes sure to update its CRL from the CA every once in a while. In both cases, Transport's only interaction with the CA is the configuration of its SSL endpoint. Certificate Authority Pairing is designed to interact with an abstract certificate authority, given this authority is capable of: Emitting SSL Certificates with a custom CN (this is important in the Transport authentication flow) Revoking emitted certificates and exposing CRL/OCSP revocation information and is accessible from a 3rd party (e.g. from a REST API). By default, Astarte supports Cloudflare's CFSSL , and also provides a minimal installation in its default deploy scripts. For bigger installations, especially in terms of number of connected devices, it is strongly advised to use a dedicated CFSSL installation. Also, Astarte Enterprise provides a number of additional features including support for other external CAs. Certificate flow During the Pairing flow, the device must generate autonomously a Certificate Signing Request (CSR) which will be in turn relayed by Pairing to the configured Certificate Authority. Pairing will also provide the Certificate Authority with a custom CN, which maps to &lt;realm&gt;/&lt;device id&gt; . The CA must ensure the signed certificate carries this information, as it will be used by the Transport to authenticate the caller inside Astarte. Pairing, in fact, will also perform sanity checks over the signed certificate and reject it in case the CA fails to comply.","ref":"050-pairing_mechanism.html#using-ssl-certificates-as-transport-credentials","title":"Pairing Mechanism - Using SSL Certificates as Transport Credentials","type":"extras"},{"doc":"Agents are realm-level entities capable of registering a device into Astarte. Agents are a core concept in the Pairing mechanism, as no Device can request its Transport Credentials nor be authenticated against any Transport unless an Agent previously gave its consent and delivered its Credentials Secret . The recommended configuration includes an authenticated Agent in a trusted physical environment (e.g.: the distribution facility of the device) which guarantees an isolated and safe routine for generating Credentials Secret . However, such a setup might not always be possible, and Astarte's SDK has an On Board Agent concept to allow a simpler registration procedure. On Board Agent In the On Board Agent use case, the device is preloaded with an Agent Key , a shared secret which is not tied to a specific Device in the realm . In fact, this secret is usually the same for all Devices in the same realm. This secret will be used only once, upon the device's first interaction with Astarte (Registration), and can be safely discarded afterwards. This approach largely simplifies the deploy procedure, but leaves every device with a secret which, if retrieved, can allow an entity to register an arbitrary Device in the realm. If following the On Board Agent approach, it is advised to store the Agent Key in a safe area inside the device and delete it after retrieving a Credentials Secret (some OTPs allow this configuration).","ref":"050-pairing_mechanism.html#agents","title":"Pairing Mechanism - Agents","type":"extras"},{"doc":"Once a device obtains its Transport Credentials , it is then capable of connecting to the Transport the credentials were forged for. Transports have full responsibility in terms of authenticating the client, reporting and relaying its connection state to Astarte via its internal AMQP API. As such, it is fundamental that 3rd parties implementing new Transports not only adhere to protocol specifications, but also make sure to implement the authentication procedure meticolously, as a vulnerable Transport acts as a single point of failure of the whole system, and is capable of bypassing the Pairing workflow entirely. For this very reason, we encourage users to be extremely cautious when using 3rd party Transports which have not been verified and hardly tested, especially when it comes to the Client Authentication stage. Even though there are valid use cases where Mutual Authentication is not usable, Transports are advised to stick to Mutual SSL Authentication where possible. This, among other benefits, allows to use Pairing's core features for handling SSL Certificates.","ref":"050-pairing_mechanism.html#transport-responsibility","title":"Pairing Mechanism - Transport responsibility","type":"extras"},{"doc":"Pairing's Device API exposes two additional facilities: first and foremost an endpoint which bears a set of information about both Pairing itself and Transports the device should use or choose from. This endpoint is Device and Realm specific and can be found at /{realm_name}/devices/{hw_id} . This allows granting each Device a specific Transport configuration, which can be useful in installations with more than a single Transport, and automates the configuration on the Device's end, which knows in advance what is supported and how to access its Transport(s). Moreover, each Transport implementation has a /verify endpoint where a client, authenticating with its Credentials Secret , can verify whether its Transport Credentials are valid or not. This, in case SSL is used, is especially useful for checking against revocation lists.","ref":"050-pairing_mechanism.html#pairing-facilities","title":"Pairing Mechanism - Pairing facilities","type":"extras"},{"doc":"Triggers Triggers in Astarte are the go-to mechanism for generating push events. In contrast with AppEngine's REST APIs, Triggers allow users to specify conditions upon which a custom payload is delivered to a recipient, using a specific action , which usually maps to a specific transport/protocol, such as HTTP. Given this kind of flexibility, triggers are the most powerful way to push data to an external service, potentially without any additional customization. Triggers can be managed from Realm Management API , astartectl with the astartectl realm-management triggers subcommand, or Astarte Dashboard in the Triggers page.","ref":"060-triggers.html","title":"Triggers","type":"extras"},{"doc":"Triggers can be either built manually or using Astarte Dashboard's Trigger Editor. Trigger Editor dynamically loads installed Interfaces in the Realm and eases trigger creation by providing not only linting and validation, but also dynamic resolution of Interface names. Trigger Editor works in a very similar fashion to Interfaces Editor, and shares the same User Interface. Format A trigger is described using a JSON document. Each trigger is defined by two main parts: condition and action . This is a JSON representation of an example trigger: { &quot;name&quot;: &quot;example_trigger&quot;, &quot;action&quot;: { &quot;http_url&quot;: &quot;https://example.com/my_hook&quot;, &quot;http_method&quot;: &quot;post&quot; }, &quot;simple_triggers&quot;: [ { &quot;type&quot;: &quot;data_trigger&quot;, &quot;on&quot;: &quot;incoming_data&quot;, &quot;interface_name&quot;: &quot;org.astarte-platform.genericsensors.Values&quot;, &quot;interface_major&quot;: 0, &quot;match_path&quot;: &quot;/streamTest/value&quot;, &quot;value_match_operator&quot;: &quot;&gt;&quot;, &quot;known_value&quot;: 0.4 } ] } The condition is represented by the simple_triggers array. In this release, Astarte supports only a single entry in the simple_triggers array, but support for multiple simple triggers (and different ways to combine them) is planned for future releases. The condition in the example specifies that when data is received on the org.astarte-platform.genericsensors.Values interface on /streamTest/value path, if the value of said data is &gt; 0.4 , then the trigger is activated. For more information about all the possible conditions, check out the Conditions section The action object describes what the result of the trigger will be. In this specific case, an HTTP POST request will be sent to https://example.com/my_hook , with the payload: { &quot;timestamp&quot;: &quot;&lt;event_timestamp&gt;&quot;, &quot;device_id&quot;: &quot;&lt;device_id&gt;&quot;, &quot;event&quot;: { &quot;type&quot;: &quot;incoming_data&quot;, &quot;interface&quot;: &quot;org.astarte-platform.genericsensors.Values&quot;, &quot;path&quot;: &quot;/streamTest/value&quot;, &quot;value&quot;: &lt;some_value&gt; } } To know more about all possible actions, check the Actions section","ref":"060-triggers.html#building-triggers","title":"Triggers - Building Triggers","type":"extras"},{"doc":"A condition defines the event upon which an action is triggered. Conditions are expressed through simple triggers. Astarte monitors incoming events and triggers a corresponding action whenever there is a match. Simple triggers are divided into two types: Device Triggers and Data Triggers . Device Triggers Device triggers express conditions matching the state of a device. This is the generic representation of a Data Trigger: { &quot;type&quot;: &quot;device_trigger&quot;, &quot;on&quot;: &quot;&lt;device_trigger_type&gt;&quot;, &quot;device_id&quot;: &quot;&lt;device_id&gt;&quot;, &quot;group_name&quot;: &quot;&lt;group_name&gt;&quot; } Parameters device_trigger_type can be one of the following: device_connected : triggered when a device connects to its transport. device_disconnected : triggered when a device disconnects from its transport. device_error : triggered when data from a device causes an error. device_id can be used to pass a specific Device ID to restrict the trigger to a single device. * is also accepted as device_id to maintain backwards compatibility and it is considered equivalent to no device_id specified. group_name can be used to restrict the trigger to all devices that are member of the group. device_id and group_name are mutually exclusive and if neither of them is specified in the simple trigger, the simple trigger will be installed for all devices in a realm. Data Triggers Data triggers express conditions matching data coming from a device. This is the generic representation of a Device Trigger: { &quot;type&quot;: &quot;data_trigger&quot;, &quot;device_id&quot;: &quot;&lt;device_id&gt;&quot;, &quot;group_name&quot;: &quot;&lt;group_name&gt;&quot;, &quot;on&quot;: &quot;&lt;data_trigger_type&gt;&quot;, &quot;interface_name&quot;: &quot;&lt;interface_name&gt;&quot;, &quot;interface_major&quot;: &quot;&lt;interface_major&gt;&quot;, &quot;match_path&quot;: &quot;&lt;match_path&gt;&quot;, &quot;value_match_operator&quot;: &quot;&lt;value_match_operator&gt;&quot;, &quot;known_value&quot;: &lt;known_value&gt; } Data triggers are installed for all devices in a Realm. Data Triggers Parameters device_id can be used to pass a specific Device ID to restrict the trigger to a single device. * is also accepted as device_id to maintain backwards compatibility and it is considered equivalent to no device_id specified. group_name can be used to restrict the trigger to all devices that are member of the group. device_id and group_name are mutually exclusive and if neither of them is specified in the simple trigger, the simple trigger will be installed for all devices in a realm. data_trigger_type can be one of the following: incoming_data : verifies the condition whenever new data arrives. value_stored : verifies the condition whenever new data arrives, after it is saved to the database. value_change : works only with properties interface; verifies the condition whenever the received value is different from the previous one. value_change_applied : works only with properties interface; verifies the condition whenever the last value received is different from the last one previously received, after it is saved to the database. path_created : verifies the condition whenever a new path in a property interface is set or the first value is streamed on a datastream interface. path_removed : works only with properties interface; verifies the condition whenever a property path is unset. interface_name and interface_major represent, respectively, the Interface name and major version that uniquely identify an Astarte Interface. interface_name can be * to match all interfaces; in that case interface_major is ignored and all major numbers are matched. match_path is the path that will be used to match the condition. It can be /* to match all the paths of an interface. value_match_operator is the operator used to match the incoming data against a known value. It can be * to indicate that all values should be matched ( known_value is ignored in that case), otherwise it can be one of these operators: == , != , &gt; , &gt;= , &lt; , &lt;= , contains , not_contains . The match is always performed with &lt;incoming_value&gt; &lt;operator&gt; &lt;known_value&gt; . contains and not_contains can be used only with type string , binaryblob and with array types. known_value is the value used with value_match_operator to perform the comparison on the incoming value. It must have the same type as the incoming value, except in the contains and not_contains case.","ref":"060-triggers.html#conditions","title":"Triggers - Conditions","type":"extras"},{"doc":"Actions are triggered by a matching condition. An Action defines how the event should be sent to the outer world (e.g. an http POST on a certain URL). In addition, most actions have a Payload, which carries the body of the event. HTTP Actions Payloads are most of the time represented as text, and Astarte provides several ways to generate them. By default Astarte generates a JSON payload with all the relevant information of the event. This is also the format used when delivering payloads in Astarte Channels. The format of the payload can be found in the Default action section. Astarte also provides a powerful templating mechanism for plain-text payloads based on top of Mustache . This is especially useful for integrating with third-party actors which require custom plain-text payloads. Keep in mind that Mustache templates are only able to produce text/plain payloads, not valid JSON. Default action This is the configuration object representing a minimal default action: { &quot;http_url&quot;: &quot;&lt;http_url&gt;&quot;, &quot;http_method&quot;: &quot;&lt;method&gt;&quot; } The default action sends an HTTP request to the specified http_url using http_method method (e.g. POST ). Further options might be used, such as &quot;http_static_headers&quot;, enabling auth to remote services: { &quot;http_url&quot;: &quot;&lt;http_url&gt;&quot;, &quot;http_method&quot;: &quot;&lt;method&gt;&quot;, &quot;http_static_headers&quot;: { &quot;Authorization&quot;: &quot;Bearer &lt;token&gt;&quot; }, &quot;ignore_ssl_errors&quot;: &lt;true|false&gt; } The ignore_ssl_errors key is optional and defaults to false . If set to true , any SSL error encountered while doing the HTTP request will be ignored. This can be useful if the trigger must ignore self-signed or expired certificates. Please, beware that some http headers might be not allowed or reserved for http connection signaling. SimpleEvent payloads The payload delivered in a default HTTP action or in Astarte Channels is a JSON document with this format: { &quot;timestamp&quot;: &quot;&lt;timestamp&gt;&quot;, &quot;device_id&quot;: &quot;&lt;device_id&gt;&quot;, &quot;event&quot;: &lt;event&gt; } timestamp is an UTC ISO 8601 timestamp (e.g. &quot;2019-10-16T08:56:08.534377Z&quot; ) representing when the event happened. device_id identifies the device that triggered the event. event is a JSON object that has a specific structure depending on the type of the simple_trigger that generated it. Event objects are detailed below. Additionally, the realm that originated the trigger is available in the request in the Astarte-Realm header. Event objects DeviceConnectedEvent { &quot;type&quot;: &quot;device_connected&quot;, &quot;device_ip_address&quot;: &quot;&lt;device_ip_address&gt;&quot; } device_ip_address is the IP address of the device. DeviceDisconnectedEvent { &quot;type&quot;: &quot;device_disconnected&quot; } DeviceErrorEvent { &quot;type&quot;: &quot;device_error&quot;, &quot;error_name&quot;: &quot;&lt;error_name&gt;&quot;, &quot;metadata&quot;: { &quot;&lt;key&gt;&quot;: &quot;&lt;value&gt;&quot; } } error_name is a string identifying the error. More details can be found in the device errors documentation metadata is a map with string key and string values that may contain additional information about the error. Some metadata ( e.g. binary payloads) might be encoded in base64 if they cannot be represented as string. In that case, the key is prepended with the base64_ prefix. IncomingDataEvent { &quot;type&quot;: &quot;incoming_data&quot;, &quot;interface&quot;: &quot;&lt;interface&gt;&quot;, &quot;path&quot;: &quot;&lt;path&gt;&quot;, &quot;value&quot;: &lt;value&gt; } interface is the interface on which data was received. path is the path on which data was received. value is the received value. Its type depends on the type of the mapping it's coming from. binaryblob and binaryblobarray type values are encoded with Base64. ValueStoredEvent { &quot;type&quot;: &quot;value_stored&quot;, &quot;interface&quot;: &quot;&lt;interface&gt;&quot;, &quot;path&quot;: &quot;&lt;path&gt;&quot;, &quot;value&quot;: &lt;value&gt; } interface is the interface on which data was received. path is the path on which data was received. value is the received value. Its type depends on the type of the mapping it's coming from. binaryblob and binaryblobarray type values are encoded with Base64. ValueChangeEvent { &quot;type&quot;: &quot;value_change&quot;, &quot;interface&quot;: &quot;&lt;interface&gt;&quot;, &quot;path&quot;: &quot;&lt;path&gt;&quot;, &quot;old_value&quot;: &lt;old_value&gt;, &quot;new_value&quot;: &lt;new_value&gt; } interface is the interface on which data was received. path is the path on which data was received. old_value is the previous value. Its type depends on the type of the mapping it's coming from. binaryblob and binaryblobarray type values are encoded with Base64. new_value is the received value. Its type depends on the type of the mapping it's coming from. binaryblob and binaryblobarray type values are encoded with Base64. ValueChangeAppliedEvent { &quot;type&quot;: &quot;value_change_applied&quot;, &quot;interface&quot;: &quot;&lt;interface&gt;&quot;, &quot;path&quot;: &quot;&lt;path&gt;&quot;, &quot;old_value&quot;: &lt;old_value&gt;, &quot;new_value&quot;: &lt;new_value&gt; } interface is the interface on which data was received. path is the path on which data was received. old_value is the previous value. Its type depends on the type of the mapping it's coming from. binaryblob and binaryblobarray type values are encoded with Base64. new_value is the received value. Its type depends on the type of the mapping it's coming from. binaryblob and binaryblobarray type values are encoded with Base64. PathCreatedEvent { &quot;type&quot;: &quot;path_created&quot;, &quot;interface&quot;: &quot;&lt;interface&gt;&quot;, &quot;path&quot;: &quot;&lt;path&gt;&quot;, &quot;value&quot;: &lt;value&gt; } interface is the interface on which data was received. path is the path that has been created. value is the received value. Its type depends on the type of the mapping it's coming from. binaryblob and binaryblobarray type values are encoded with Base64. PathRemovedEvent { &quot;type&quot;: &quot;path_removed&quot;, &quot;interface&quot;: &quot;&lt;interface&gt;&quot;, &quot;path&quot;: &quot;&lt;path&gt;&quot; } interface is the interface on which data was received. path is the path that has been removed. Mustache action This is the configuration object representing a Mustache action: { &quot;http_url&quot;: &quot;&lt;http_url&gt;&quot;, &quot;http_method&quot;: &quot;&lt;http_method&gt;&quot;, &quot;template_type&quot;: &quot;mustache&quot;, &quot;template&quot;: &quot;&lt;template&gt;&quot; &quot;ignore_ssl_errors&quot;: &lt;true|false&gt; } The Mustache action sends an HTTP request to the specified http_url , with the payload built with the Mustache template specified in template . If the template contains a key inside a double curly bracket (like so: {{ key }} ), it will be substituted with the actual value of that key in the event. The basic keys that can be use to populate the template are: {{ realm }} : the realm the trigger belongs to. {{ device_id }} : the device that originated the trigger. {{ event_type }} : the type of the received event. The ignore_ssl_errors key is optional and defaults to false . If set to true , any SSL error encountered while doing the HTTP request will be ignored. This can be useful if the trigger must ignore self-signed or expired certificates. Moreover, depending on the event type, all keys that are contained in the events described in the previous section are available, always by wrapping them in {{ }} . The realm is also sent in the Astarte-Realm header. Example This is an example of a trigger that uses Mustache action. { &quot;name&quot;: &quot;example_mustache_trigger&quot;, &quot;action&quot;: { &quot;template_type&quot;: &quot;mustache&quot;, &quot;template&quot;: &quot;Device {{ device_id }} just connected from IP {{ device_ip_address }}&quot;, &quot;http_url&quot;: &quot;https://example.com/my_mustache_hook&quot;, &quot;http_method&quot;: &quot;post&quot; }, &quot;simple_triggers&quot;: [ { &quot;type&quot;: &quot;device_trigger&quot;, &quot;on&quot;: &quot;device_connected&quot;, &quot;device_id&quot;: &quot;*&quot; } ] } When a device is connected, the following request will be received by https://example.com/my_mustache_hook : POST /my_mustache_hook HTTP/1.1 Astarte-Realm: test Content-Length: 63 Content-Type: text/plain Host: example.com User-Agent: hackney/1.13.0 Device ydqBlFsGQ--xZ-_efQxuLw just connected from IP 172.18.0.1 AMQP 0-9-1 Actions AMQP 0-9-1 actions might be configured as an alternative to HTTP actions for advanced use cases. AMQP 0-9-1 is the right choice for a number of scenarios, including Astarte Flow integration, high performance ingestion, integration with an existing AMQP infrastructure, etc... Payloads are always encoded using protobuf , therefore if any other format is required Astarte Flow should be employed as a format converter. This is a minimal configuration object representing an AMQP 0-9-1 action: { &quot;amqp_exchange&quot;: &quot;astarte_events_&lt;realm-name&gt;_&lt;exchange-suffix&gt;&quot;, &quot;amqp_routing_key&quot;: &quot;my_routing_key&quot;, &quot;amqp_message_expiration_ms&quot;: &lt;expiration in milliseconds&gt;, &quot;amqp_message_persistent&quot;: &lt;true when disk persistency is used&gt; } It is possible to configure more advanced AMQP 0-9-1 actions: { &quot;amqp_exchange&quot;: &quot;astarte_events_myrealm_myexchange&quot;, &quot;amqp_routing_key&quot;: &quot;my routing key&quot;, &quot;amqp_static_headers&quot;: { &quot;key&quot;: &quot;value&quot; }, &quot;amqp_message_expiration_ms&quot;: 10000, &quot;amqp_message_priority&quot;: 0, &quot;amqp_message_persistent&quot;: true, } Some Astarte specific restrictions apply: amqp_exchange must have astarte_events_&lt;realm-name&gt;_&lt;any-allowed-string&gt; format. amqp_routing_key must not contain { and } , which are reserved for future uses. For further details RabbitMQ documentation is suggested.","ref":"060-triggers.html#actions","title":"Triggers - Actions","type":"extras"},{"doc":"Channels are part of AppEngine, and allow users to monitor device events through WebSockets, on top of Phoenix Channels . Under the hood, Channels use transient triggers to define which kind of events will flow through a specific room.","ref":"060-triggers.html#relationship-with-channels","title":"Triggers - Relationship with Channels","type":"extras"},{"doc":"Groups Astarte supports creating groups of devices in a realm. Groups are currently useful mainly to provide access control, combining Astarte's path based authorization with the fact that devices can be queried with a group URL. This makes it possible to emit tokens allowing a user to operate only on devices that belong to a specific group. Groups can be managed using astartectl or using AppEngine API . See the Managing Groups page in the User Guide for some usage examples. Keep in mind a group is existing as long as there's at least one device in it. Once the last device is removed from the group, the group does not exist anymore, since groups are a tag (or label) of devices.","ref":"065-groups.html","title":"Groups","type":"extras"},{"doc":"Authentication and Authorization Authentication and authorization are crucial, as Astarte likely holds sensitive resources and is capable to send mass commands to a device fleet. First of all: when talking about auth in Astarte, we are talking about anything which isn't a Device - those are Authenticated through Pairing and Authorized by their Transport (which uses Pairing for the Authentication policies). Astarte's authentication/authorization stage identifies the principal through a token (with JWT as the first class citizen), which is the only currency the platform supports.","ref":"070-auth.html","title":"Authentication and Authorization","type":"extras"},{"doc":"In Astarte, realms are logically separated and have completely different data partitions. This is also true in terms of authentication, as caller is always authenticated on a per-realm basis. As such, an authentication realm matches 1:1 an Astarte realm. Superadmin APIs, such as housekeeping, are part of a different authentication realm which is defined upon cluster setup.","ref":"070-auth.html#authentication-realms","title":"Authentication and Authorization - Authentication Realms","type":"extras"},{"doc":"Astarte, by design, does not have a concept of per-user authentication built in. The definition of an authentication realm is a mean to verify a token's validity, that is most likely a public key. This makes integrating Astarte with 3rd party authentication/authorization frameworks and SSOs extremely easy, as the whole logic for addressing user management is managed out of the cluster by a dedicated party. Depending on one's use case, it is possible to use either a very simple, dedicated OAuth server for each realm, or a full fledged SSO such as Keycloak which matches its authentication realms to Astarte's realms. Especially if you are aiming at the latter, make sure to read the advised best practices for authentication afterwards.","ref":"070-auth.html#authentication-in-astarte","title":"Authentication and Authorization - Authentication in Astarte","type":"extras"},{"doc":"Currently, Astarte supports a URL-based authorization for the API. Given that Astarte's data access APIs match the devices' topology like a tree, declaring the authorization in terms of path allow-listing gives enough flexibility to give each user the correct permissions without limitations. As said, Astarte does not have the concept of user, and neither has a durable storage which tracks permissions. As such, it expects the authorization information to be inside the token, which is the only entity Astarte can trust - given it has been verified and authenticated through its signature. Paths are given in form of a set of Perl-like Regular Expressions , and on a per-API basis. This means that each API endpoint (app, realm, etc...) has its own regular expression which defines what the user can do. Moreover, each HTTP verb in an API endpoint (e.g.: GET, POST, PUT, DELETE) can have its own regular expression, to fine-grain permissions on each path. Note: given Astarte's interface are either read only or write only, HTTP verb fine-graining in AppEngine API is mostly useful for preventing a user from deleting a consumer Datastream even though it has write access to it. Most of the time, using only a single regular expression with no verb fine-graining works. Examples of valid regular expressions on AppEngine API are: POST::devices/.*/interfaces/com\\\\.my\\\\.interface/.* : Allows to set individual values on the com.my.interface interface on any individual device in the realm. .*::.*/interfaces/com\\\\.my\\\\.monitoring\\\\.interface.* : Allows to get/set/delete either the aggregate or the individual values of the com.my.monitoring.interface interface on any device or device aggregation in the realm. .*::devices/j0zbvbQp9ZNnanwvh4uOCw.* : Allows every operation on device j0zbvbQp9ZNnanwvh4uOCw GET::devices/[a-zA-Z0-9-_]* : Allows to get every individual device's status, but denies access to any additional information/operation on them. Examples of valid regular expressions on Realm Management API are: POST::interfaces\\/.* : Allows installing new interfaces in the realm. GET::interfaces\\/.* : Allows inspecting every interface in the realm. PUT::interfaces\\/.*\\/0 : Allows updating all draft interfaces in the realm. Other valid examples are: .*::.* : Allows any operation on the given API. Both verb and path regular expressions are implicitly delimited by adding ^ before and $ after the regular expression string. For example, if you use GET::interfaces as regular expression in Realm Management API, the path will be matched against ^GET$ and the path will be matched against ^interfaces$ . This way the only operation allowed will be listing all the interfaces, while all operation on interfaces/ subpaths will be denied. Token claims and formats Authorization regular expressions have to be contained in the token's claims. Only the JWT case will be considered given it is the primary currency Astarte supports. Every claim is an array of regular expressions, which act as a logical OR. A similar behavior could be of course achieved (and might be more efficient) with a singular regular expression, but for the sake of readability and simplicity it is allowed nonetheless. Of course, keeping the authorization claims simple and pragmatic helps in terms of performance. Supported token claims are: a_aea : Defines the regular expressions for AppEngine API a_rma : Defines the regular expressions for Realm Management API a_ha : Defines the regular expressions for Housekeeping API a_pa : Defines the regular expressions for Pairing API a_ch : Defines the regular expressions for Channels Of course, claims are considered only after a successful token verification. This means that the claim will be processed only if the caller is authenticated against the correct authentication realm - this is especially the case for what concerns Housekeeping, which has a dedicated Authentication realm not tied to any Astarte realms. An example of a valid token claim is: { &quot;a_aea&quot;: [&quot;GET::devices/[a-zA-Z0-9-_]*&quot;, &quot;.*::.*/interfaces/com\\\\.my\\\\.monitoring\\\\.interface.*&quot;, &quot;.*::devices/j0zbvbQp9ZNnanwvh4uOCw.*&quot;], &quot;a_rma&quot;: [&quot;GET::.*&quot;] } Which allows very specific permissions on AppEngine API, and a &quot;read all&quot; on Realm Management API. The client by default has no permission to do anything: as such, if a token is missing a claim it is simply assumed that the client isn't authorized to access that specific API. However, keeping in mind that Astarte has no concept of User, it is also true that your authentication backend might choose to emit a different token with only a subset of its real permissions to keep claims and regular expressions as pragmatic as possible. See Granular Claims in Best Practices for more details on this. Natively supported tokens Astarte supports only JWT natively, which has to be signed using one of the following algorithms: ES256 ES384 ES512 PS256 PS384 PS512 RS256 RS384 RS512","ref":"070-auth.html#authorization","title":"Authentication and Authorization - Authorization","type":"extras"},{"doc":"Valid tokens can be used for calling into Astarte's public APIs. Depending on which token mechanism is used, the HTTP call must adhere to some requirements. JWT Every API call must have an Authorization: Bearer &lt;token&gt; header. Not providing the token or providing a token which can't be validated for the authentication realm of the context results in a 401 reply.","ref":"070-auth.html#authorization-for-rest-apis","title":"Authentication and Authorization - Authorization for REST APIs","type":"extras"},{"doc":"A valid token should be supplied when opening the WebSocket, in the very same fashion to what happens with REST APIs. However, the claims in this token will support different verbs compared to the REST APIs, namely JOIN and WATCH . These have very specific meanings and are well explained in Channels' User Guide . The behavior and supported tokens are equivalent to REST APIs.","ref":"070-auth.html#authorization-for-channels","title":"Authentication and Authorization - Authorization for Channels","type":"extras"},{"doc":"Astarte, by default, is extremely easy to configure assuming your chosen SSO is capable of issuing JWT, as it is currently the only natively supported authentication currency. However, virtually any token-based system can be used as an auth framework for Astarte. The main purpose of Astarte's design, however, is to keep things simple for everyone. Putting up a full-fledged SSO dedicated to Astarte is beyond the scope of this documentation, and we favor the use case where an existing SSO infrastructure is integrated with Astarte, rather than built ad-hoc. For simple use cases and instant satisfaction, it is strongly advised to use a simpler solution, such as a dedicated OAuth server. Almost all popular languages and frameworks provide great projects which can spin up an OAuth2 server + user management in a matter of hours, from Elixir/Phoenix to Java/Spring to Go . Astarte's Enterprise Distribution includes other add-ons, such as automation and configuration for popular SSOs.","ref":"070-auth.html#supported-integrations","title":"Authentication and Authorization - Supported integrations","type":"extras"},{"doc":"Due to the nature of tokens, applications and SSOs must take care of emission and storage of the token themselves. In most production cases, Astarte will be part of a larger SSO infrastructure being one of the clients (this is especially true for OAuth). Among best practices, emitting short-lived tokens should always be considered, but depending on the use case, the authentication pipeline can be further tuned to address a number of potential issues. Token exchange OAuth, like other protocols supports the concept of a Token Exchange . Consider a web dashboard with a logged in user. The user will, most likely, have a token which is used by its frontend to call upon the backend/APIs of the web dashboard. For the sake of simplicity, one might include in this token the adequate claims to give the user access to Astarte, but this might not be desirable for a number of reasons outlined above. Token exchange, if supported by your SSO, provides a great way to work around this: whenever the backend or the frontend requires access to Astarte, it can invoke the token exchange mechanism of the SSO to generate a short lived token for the API call from the original authentication, which can then be used even as a single shot access mechanism. Granular claims The token exchange approach can be efficiently paired with a mechanism of granular claims. Consider the use case above, and let's assume the frontend needs direct, frequent access to Astarte's APIs. Exchanging tokens too many times might put a burden on the SSO and might become impractical. However, Astarte decouples entirely authentication and authorization - that means, if two subsequent (valid) tokens which represent the same identity have substantially different claims, it doesn't care. This is intentional, as it allows for a much more efficient pattern: the token used by an hypotetical frontend can have a subset of the user's claims - for example, allowing him to read data from its devices, whereas token exchange can be used whenever more specific operations should be performed - for example, sending some commands or data to devices. This also addresses the objection that regular expressions can grow big or quite complicated in case users need a large number of very granular permissions. In such complex cases, the SSO can be tuned to give out only a subset of claims depending on the user's operation. Token revocation Token revocation isn't natively supported in Astarte for two reason: the first one is performance, as keeping a revocation list is expensive in many regards. The second is the fact that the revocation list is, most of the time, SSO specific, and a dedicated SSO integration would be required. Rather than token revocation, a better practice is to make sure every emitted token has a short enough lifetime. However, it is possible to extend Astarte's authorization stage to support revocation, even though there are no plans to provide upstream support for that. Changing a Realm's validation mean Over the lifetime of a cluster, it might be necessary to change a realm's validation mean for the most diverse reasons. By design, validation means are meant to be long lived, and changing them is supposed to be an extraordinary operation. Astarte supports only one validation mean at a time. When the validation mean is changed, all tokens emitted which could be validated with the previous mean become invalid. It is also possible that there might be a delay between the request of a validation mean change and its actuation. This means during this grace period tokens will be validated against the previously configured mean. As such, it is advised to treat a validation mean change as a maintenance operation for the realm. More details can be found in the Administrator Guide.","ref":"070-auth.html#best-practices","title":"Authentication and Authorization - Best practices","type":"extras"},{"doc":"Astarte MQTT v1 Protocol Astarte MQTT v1 Protocol allows communication between Astarte and devices. It is the first protocol that has been implemented in Astarte, and it exploits every feature provided by Astarte itself. Astarte MQTT v1 doesn't mandate a specific Transport Credentials format: the broker must handle Authentication, Authorization and Pairing integration the way it sees fit. Astarte MQTT v1 is implemented by Astarte's Reference Transport, Astarte/VerneMQ - a client wishing to interact with it must implement MQTT v3.1.1 and all needed features for Pairing to work. MQTT doesn't mandate the data serialization format, so any application might implement its own format. Data serialization might be a tricky task and protocols might be hard to design, Astarte MQTT takes care of this and provides a higher level protocol which abstracts this detail from the end user. Astarte MQTT v1 Protocol builds upon MQTT v3.1.1 itself, BSON (Binary JSON, version 1.1) serialized payloads and on optional zlib deflate. All communications are ordered and asynchronous. A protocol reference implementation is provided with an Astarte SDK, however developers might implement it from scratch using 3rd party libraries with their favourite languages: all formats and protocols described here are open and well documented. Last but not least Astarte doesn't mandate this protocol, and a different one can be used with a different transport.","ref":"080-mqtt-v1-protocol.html","title":"Astarte MQTT v1 Protocol","type":"extras"},{"doc":"Astarte MQTT v1 Protocol relies on few well known reserved topics. Topic Purpose Published By QoS Payload Format &lt;realm name&gt;/&lt;device id&gt; Introspection Device 2 ASCII plain text, ':' and ';' delimited &lt;realm name&gt;/&lt;device id&gt;/control/emptyCache Empty Cache Device 2 ASCII plain text (always &quot;1&quot;) &lt;realm name&gt;/&lt;device id&gt;/control/consumer/properties Purge Properties Astarte 2 deflated plain text &lt;realm name&gt;/&lt;device id&gt;/control/producer/properties Purge Properties Device 2 deflated plain text &lt;realm name&gt;/&lt;device id&gt;/&lt;interface name&gt;/&lt;path&gt; Publish Data Both 0, 1, 2 BSON (or empty) For clarity reasons all &lt;realm name&gt;/&lt;device id&gt; prefixes will be omitted on the following paragraphs, those topics will be called device topics. Topics are not bidirectional, devices must not publish data for server owned topics and viceversa, onwership is explicitly stated in interfaces files.","ref":"080-mqtt-v1-protocol.html#mqtt-topics-overview","title":"Astarte MQTT v1 Protocol - MQTT Topics Overview","type":"extras"},{"doc":"BSON allows saving precious bytes compared to JSON, while offering the advantages of a schema-less protocol. Consider, for example, a simple value and timestamp payload. The encoded JSON version, {&quot;v&quot;:25.367812,&quot;t&quot;:1537346756844} counts 33 bytes. The hexdump of the same message encoded with BSON is: 0000000 1 b 00 00 00 09 74 00 ec e0 01 f1 65 01 00 00 01 0000020 76 00 8 c 13 5 f ed 28 5 e 39 40 00 that fits just in 27 bytes. BSON format BSON is a really simple binary format, breaking down the previous example is very easy thanks to BSON simplicity: the first 4 bytes ( 1b 00 00 00 ) are the document size header, follows the timestamp marker ( 09 ), the timestamp key name ( 74 00 , that is &quot;t&quot;), the timestamp value ( 5f 48 06 f1 65 01 00 00 as int64), the double value marker ( 01 ), the value key name ( 76 00 , that is &quot;v&quot;), the actual value ( cd cc cc cc cc 4c 39 40 as 64-bit IEEE 754-2008 floating point) and the end of document marker ( 00 ). Astarte payload standard fields Key Type Mandatory Description v Any Astarte type Yes The value being sent (both properties and datastream) t UTC datetime No Explicit timestamp, if present (optional, datastream only) Astarte data types to BSON types Astarte Data Type BSON Type Size in Bytes double double (0x01) 8 integer int32 (0x10) 4 boolean boolean (0x08) 1 longinteger int64 (0x12) 8 string UTF-8 string (0x02) &gt;= length (encoding dependent) binaryblob binary (0x05) length datetime UTC datetime (0x09) 8 doublearray Array (0x04) (8 + keysize) * count integerarray Array (0x04) (4 + keysize) * count booleanarray Array (0x04) (1 + keysize) * count longintegerarray Array (0x04) (1 + keysize) * count stringarray Array (0x04) depends on count, length, keys length and encoding binaryblobarray Array (0x4) depends on count, keys length and length integer and long integer are signed integer values, double must be a valid number ( +inf , NaN , etc... are not supported), variable data types might be subject to size limitations and object aggregations are encoded as embedded documents.","ref":"080-mqtt-v1-protocol.html#bson","title":"Astarte MQTT v1 Protocol - BSON","type":"extras"},{"doc":"A device is not required to publish any additional connection or disconnection messages, the MQTT broker will automatically keep track of these events and relay them to Astarte. When connecting, before publishing any data message, a device should check MQTT session present flag. When the MQTT session present flag is true no further actions are required, when false the device should take following actions: Publish its introspection Publish an empty cache message Publish all of its existing and set properties on all its property interfaces If a device is unable to inspect session present all previous actions must be taken at every reconnection.","ref":"080-mqtt-v1-protocol.html#connection-and-disconnection","title":"Astarte MQTT v1 Protocol - Connection and Disconnection","type":"extras"},{"doc":"Each device must declare the set of supported interfaces and their version. Astarte needs to know which interfaces the device advertises before processing any further data publish. This message in Astarte jargon is called introspection and it's performed by publishing on the device root topic the list of interfaces that are installed on the device. Introspection payload is a simple plain text string, and it has the following format (in BNF like syntax): introspection :: = introspection_list introspection_list :: = introspection_entry &quot;;&quot; introspection_list | introspection_entry introspection_entry :: = interface_name &quot;:&quot; interface_major_version &quot;:&quot; interface_minor_version The following example is a valid introspection payload: com . example . MyInterface : 1 : 0 ; org . example . DraftInterface : 0 : 3","ref":"080-mqtt-v1-protocol.html#introspection","title":"Astarte MQTT v1 Protocol - Introspection","type":"extras"},{"doc":"Astarte MQTT v1 strives to save bandwidth upon reconnections, to make sure even frequent reconnections don't affect bandwidth consumption. As such, upon connecting and if MQTT advertises a session present, both sides assume that data flow is ordered and consistent. However, there might be cases where this guarantee isn't respected by the device for a number of reasons (e.g.: new device, factory reset, cache lost...). In this case, a device might declare that it has no confidence about its status and its known properties, and can request to resynchronise entirely with Astarte. In Astarte jargon this message is called empty cache and it is performed by publising &quot;1&quot; on the device /control/emptyCache topic. After an empty cache message properties might be purged and Astarte might publish all the server owned properties again.","ref":"080-mqtt-v1-protocol.html#empty-cache","title":"Astarte MQTT v1 Protocol - Empty Cache","type":"extras"},{"doc":"In the very same fashion as the device, Astarte (or the broker) might be inconsistent with a Device's known status and its known properties. Although unlikely, as Astarte should always keep knowledge about remote device status, this might happen, for example, after an internal error. Astarte performs this task by telling the broker to disconnect the device and clear its session. After this, when the device will attempt reconnection, session present will be false. After a clean session properties might be purged.","ref":"080-mqtt-v1-protocol.html#session-present","title":"Astarte MQTT v1 Protocol - Session Present","type":"extras"},{"doc":"Either a Device or Astarte may tell the remote host the set properties list. Any property that is not part of the list will be deleted from any cache or database. This task is called purge properties in Astarte jargon, and it is performed by publishing a the list of known set properties to /control/consumer/properties or /control/producer/properties . Purge Properties payload is a zlib deflated plain text, with an additional 4 bytes header. The additional 4 bytes header is the size of the uncompressed payload, encoded as big endian uint32. The following example is a payload compressed using zlib default compression, with the additional 4 bytes header: 0000000 00 00 00 46 78 9 c 4 b ce cf d5 4 b ad 48 cc 2 d c8 0000020 49 d5 f3 ad f4 cc 2 b 49 2 d 4 a 4 b 4 c 4 e d5 2 f ce 0000040 cf 4 d d5 2 f 48 2 c c9 b0 ce 2 f 4 a 87 ab 70 29 4 a 0000060 4 c 2 b 41 28 ca 2 f c9 48 2 d 0 a 00 2 a 02 00 b2 0 c 0000100 1 a c9 The uncompressed plain text payload has the following format (in BNF like syntax): properties :: = properties_list properties_list :: = properties_entry &quot;;&quot; properties_list | properties_entry properties_entry :: = interface_name path The following example is the inflated previous payload: com . example . MyInterface / some / path ; org . example . DraftInterface / otherPath This protocol feature is fundamental when a device has any interface with an allow_unset mapping, purge properties allows to correct any error due to unhandled unset messages.","ref":"080-mqtt-v1-protocol.html#purge-properties","title":"Astarte MQTT v1 Protocol - Purge Properties","type":"extras"},{"doc":"Either Astarte or a device might publish new data on a interface/endpoint specific topic. The topic is built using /&lt;interface name&gt;/&lt;path&gt; schema, and it is used regardless of the type of interface or mapping being used. Also / path is a valid path for object aggregated interfaces. The following device topics are valid: /com.example.MyInterface/some/path /org.example.DraftInterface/otherPath /com.example.astarte.ObjectAggregatedInterface/ Data messages QoS is chosen according to mapping settings, such as reliability. Properties are always published using QoS 2. Interface Type Reliability QoS properties always unique 2 datastream unreliable 0 datastream guaranteed 1 datastream unique 2 Payload Format Payload format might change according to the message type. Payloads are always BSON encoded, except for unset messages that are empty. Property Message Property messages have a &quot;v&quot; key (which means value). Valid examples are: {&quot;v&quot;: &quot;string property value&quot;} {&quot;v&quot;: 10} {&quot;v&quot;: true} Previous payloads are BSON encoded as the following hex dumps: 0000000 22 00 00 00 02 76 00 16 00 00 00 73 74 72 69 6 e 0000020 67 20 70 72 6 f 70 65 72 74 79 20 76 61 6 c 75 65 0000040 00 00 0000000 0 c 00 00 00 10 76 00 0 a 00 00 00 00 0000000 09 00 00 00 08 76 00 01 00 Property messages order must be preserved and they must be consumed in order. The same property with the same value can be sent several times, this behavior is allowed but discouraged: it's up to the device to avoid useless messages. A device must also make sure to publish all the properties that have been changed while the device was offline. Unset Property Message Properties can be unset with an unset message. An unset message is just an empty 0 bytes payload. Datastream Message (individual aggregation) Datastream messages for interfaces with individual aggregation have a &quot;v&quot; key and an optional &quot;t&quot; key (which means timestamp). Valid examples are: {&quot;v&quot;: false} {&quot;v&quot;: 16.73} {&quot;v&quot;: 16.73, &quot;t&quot;: 1537449422890} Timestamps are UTC timestamps (BSON 0x09 type), when not provided reception timestamp is used. Previous payloads are BSON encoded as the following hex dumps: 0000000 09 00 00 00 08 76 00 00 00 0000000 10 00 00 00 01 76 00 7 b 14 ae 47 e1 ba 30 40 00 0000000 1 b 00 00 00 09 74 00 2 a 70 20 f7 65 01 00 00 01 0000020 76 00 7 b 14 ae 47 e1 ba 30 40 00 Datastream Message (object aggregation) Datastream messages for interfaces with object aggregation support every Astarte payload standard field (such as &quot;t&quot;), but in this case value is a BSON subdocument, in which each key represent a mapping of the aggregation. Valid examples are: {&quot;v&quot;: {&quot;temp&quot;: 25.3123, &quot;hum&quot;: 67.112}} {&quot;v&quot;: {&quot;temp&quot;: 25.3123, &quot;hum&quot;: 67.112}, &quot;t&quot;: 1537452514811} Timestamps are UTC timestamps (BSON 0x09 type), when not provided reception timestamp is used. Previous payloads are BSON encoded as following hex dumps: 0000000 28 00 00 00 03 76 00 20 00 00 00 01 68 75 6 d 00 0000020 ba 49 0 c 02 2 b c7 50 40 01 74 65 6 d 70 00 72 8 a 0000040 8 e e4 f2 4 f 39 40 00 00 0000000 33 00 00 00 09 74 00 fb 9 d 4 f f7 65 01 00 00 03 0000020 76 00 20 00 00 00 01 68 75 6 d 00 ba 49 0 c 02 2 b 0000040 c7 50 40 01 74 65 6 d 70 00 72 8 a 8 e e4 f2 4 f 39 0000060 40 00 00","ref":"080-mqtt-v1-protocol.html#publishing-data","title":"Astarte MQTT v1 Protocol - Publishing Data","type":"extras"},{"doc":"A device might implement a subset of this protocol if needed. /control/consumer/properties , /control/producer/properties and /emptyCache might be ignored or not implemented if a device has no property interfaces. A further simplification might remove any requirement for any introspection message when previously provisioned, but this feature is not supported out of the box.","ref":"080-mqtt-v1-protocol.html#minimal-protocol","title":"Astarte MQTT v1 Protocol - Minimal Protocol","type":"extras"},{"doc":"A device might be forcefully disconnected due to any kind of error. Devices should wait a random amount of time before trying to connect again to the broker. session present might be also set to false to ensure a clean and consistent state (in that case messages such as introspection and empty cache should published as previously described). Malformed or unexpected messages are discarded and further actions might be taken.","ref":"080-mqtt-v1-protocol.html#error-handling","title":"Astarte MQTT v1 Protocol - Error Handling","type":"extras"},{"doc":"In Astarte, every Transport orchestrates its credentials through Pairing. Astarte/VerneMQ authenticates devices using Mutual SSL Autentication - as such, devices use SSL certificates emitted through Pairing API to authenticate against the broker. To achieve this, the device must ensure it is capable of performing http(s) calls to Pairing API to obtain its certificates, performing SSL/X509 operations and connecting to the MQTT Broker through the use of SSL certificates.","ref":"080-mqtt-v1-protocol.html#authentication","title":"Astarte MQTT v1 Protocol - Authentication","type":"extras"},{"doc":"Device can only publish and subscribe to its device topic ( &lt;realm name&gt;/&lt;device id&gt; ) and its subtopics. The broker will deny any publish or subscribe outside that hierarchy.","ref":"080-mqtt-v1-protocol.html#authorization","title":"Astarte MQTT v1 Protocol - Authorization","type":"extras"},{"doc":"In the same fashion as Authentication, Pairing provides the client with information about how to connect to the MQTT broker. When invoking relevant Pairing API's method to gather information about available transports for a device, if Astarte advertises Astarte MQTT v1, a similar reply will be returned: { &quot;data&quot;: { &quot;version&quot;: &quot;&lt;version string&gt;&quot;, &quot;status&quot;: &quot;&lt;status string&gt;&quot;, &quot;protocols&quot;: { &quot;astarte_mqtt_v1&quot;: { &quot;broker_url&quot;: &quot;mqtts://broker.astarte.example.com:8883&quot; } } } }","ref":"080-mqtt-v1-protocol.html#connecting-to-the-broker","title":"Astarte MQTT v1 Protocol - Connecting to the Broker","type":"extras"},{"doc":"Astarte Database Astarte leverages Cassandra to store all of its data, including data ingested from devices (which might scale to insane amounts). Cassandra offers scalability and high availability with good performances . Cassandra offers linear scalability and can span from really small clusters to hundreds of nodes, without compromising on reliability. ScyllaDB &gt;= 3.3 is also supported as a drop-in replacement when a performance boost is needed. Cassandra is also the ideal storage for large-scale data processing with Apache Spark . Astarte is multi-tenant by design, with each tenant mapping to an Astarte Realm. Each Realm has its own Cassandra keyspace, which can be tuned according to Realm-specific needs (e.g.: Realms might have different replication levels). For this reason, in the scope of this section, realm and keyspace can be used as synonyms, except for the astarte keyspace.","ref":"090-database.html","title":"Astarte Database","type":"extras"},{"doc":"Astarte automatically takes care of keyspaces, tables creation and intra-version migrations (those tasks are performed by astarte_housekeeping or astarte_realm_management , depending on the context). The following documentation is just a reference about Astarte's internal statements, and is related to the release series referenced by the documentation. Astarte Keyspace Astarte needs an astarte keyspace to store its own data. astarte keyspace and tables are created with following CQL statements: CREATE KEYSPACE astarte WITH replication = {'class': 'SimpleStrategy', 'replication_factor': &lt;replication factor&gt;} AND durable_writes = true; CREATE TABLE astarte.realms ( realm_name varchar, PRIMARY KEY (realm_name) ); Realm Creation Each realm needs several tables to store data for all the functionalities. Realm tables can be grouped in the following functionalities: Configuration &amp; key-value store Interfaces schema Device management Groups management Triggers storage Data storage Some data storage tables might be created when required, whereas all other tables are created when a keyspace is created, using the following statements: CREATE KEYSPACE &lt;realm name&gt; WITH replication = {'class': 'SimpleStrategy', 'replication_factor': :replication_factor} AND durable_writes = true; CREATE TABLE &lt;realm name&gt;.kv_store ( group varchar, key varchar, value blob, PRIMARY KEY ((group), key) ); CREATE TABLE &lt;realm name&gt;.names ( object_name varchar, object_type int, object_uuid uuid, PRIMARY KEY ((object_name), object_type) ); CREATE TABLE &lt;realm_name&gt;.devices ( device_id uuid, aliases map&lt;ascii, varchar&gt;, introspection map&lt;ascii, int&gt;, introspection_minor map&lt;ascii, int&gt;, old_introspection map&lt;frozen&lt;tuple&lt;ascii, int&gt;&gt;, int&gt;, protocol_revision int, first_registration timestamp, credentials_secret ascii, inhibit_credentials_request boolean, cert_serial ascii, cert_aki ascii, first_credentials_request timestamp, last_connection timestamp, last_disconnection timestamp, connected boolean, pending_empty_cache boolean, total_received_msgs bigint, total_received_bytes bigint, exchanged_bytes_by_interface map&lt;frozen&lt;tuple&lt;ascii, int&gt;&gt;, bigint&gt;, exchanged_msgs_by_interface map&lt;frozen&lt;tuple&lt;ascii, int&gt;&gt;, bigint&gt;, last_credentials_request_ip inet, last_seen_ip inet, attributes map&lt;varchar, varchar&gt;, groups map&lt;text, timeuuid&gt;, PRIMARY KEY (device_id) ); CREATE TABLE &lt;realm name&gt;.grouped_devices ( group_name varchar, insertion_uuid timeuuid, device_id uuid, PRIMARY KEY ((group_name), insertion_uuid, device_id) ); CREATE TABLE &lt;realm name&gt;.endpoints ( interface_id uuid, endpoint_id uuid, interface_name ascii, interface_major_version int, interface_minor_version int, interface_type int, endpoint ascii, value_type int, reliability int, retention int, expiry int, database_retention_ttl int, database_retention_policy int, allow_unset boolean, explicit_timestamp boolean, description varchar, doc varchar, PRIMARY KEY ((interface_id), endpoint_id) ); CREATE TABLE &lt;realm name&gt;.interfaces ( name ascii, major_version int, minor_version int, interface_id uuid, storage_type int, storage ascii, type int, ownership int, aggregation int, automaton_transitions blob, automaton_accepting_states blob, description varchar, doc varchar, PRIMARY KEY (name, major_version) ); CREATE TABLE &lt;realm name&gt;.individual_properties ( device_id uuid, interface_id uuid, endpoint_id uuid, path varchar, reception_timestamp timestamp, reception_timestamp_submillis smallint, double_value double, integer_value int, boolean_value boolean, longinteger_value bigint, string_value varchar, binaryblob_value blob, datetime_value timestamp, doublearray_value list&lt;double&gt;, integerarray_value list&lt;int&gt;, booleanarray_value list&lt;boolean&gt;, longintegerarray_value list&lt;bigint&gt;, stringarray_value list&lt;varchar&gt;, binaryblobarray_value list&lt;blob&gt;, datetimearray_value list&lt;timestamp&gt;, PRIMARY KEY((device_id, interface_id), endpoint_id, path) ); CREATE TABLE &lt;realm name&gt;.simple_triggers ( object_id uuid, object_type int, parent_trigger_id uuid, simple_trigger_id uuid, trigger_data blob, trigger_target blob, PRIMARY KEY ((object_id, object_type), parent_trigger_id, simple_trigger_id) );","ref":"090-database.html#schema-and-keyspace-creation","title":"Astarte Database - Schema and Keyspace Creation","type":"extras"},{"doc":"Devices Devices table stores the list of all the devices for a certain realm and all their metadata, including the introspection, the device status and credentials information. Column Name Column Type Description device_id uuid Device unique 128 bits ID. aliases map&lt;ascii, varchar&gt; Alias purpose and alias map. introspection map&lt;ascii, int&gt; Device interface name to interface major version map based on most recent device introspection. introspection_minor map&lt;ascii, int&gt; Device interface name to interface minor version map based on most recent device introspection. old_introspection map&lt;frozen&lt;tuple&lt;ascii, int&gt;&gt;, int&gt; All previous device interfaces. This column is used to keep track of all interfaces that have been used and might still have some recorded data. The column maps interface (name, major) to minor. protocol_revision int Spoken Astarte MQTT v1 protocol revision. first_registration timestamp First registration attempt timestamp. credentials_secret ascii The bcrypt hash of the credential secret, that the device uses to obtain new credentials. inhibit_credentials_request boolean Ban device credentials renewal, device will be able to connect to the transport up to the credential expiry. cert_serial ascii Device certificate serial used by the CA. cert_aki ascii Device certificate Authority Key Identifier. first_credentials_request timestamp First credentials request timestamp. last_connection timestamp Most recent device connection event timestamp. last_disconnection timestamp Most recent device disconnection event timestamp. connected boolean True if the device is connected, otherwise is false. pending_empty_cache boolean Device is in an unclean state and an empty cache message is being waited. total_received_msgs bigint Count of received messages since the device registration. total_received_bytes bigint Amount of received messages bytes since the device registration. exchanged_msgs_by_interface bigint Count of exchanged messages since the device registration. exchanged_bytes_by_interface bigint Amount of exchanged messages bytes since the device registration. last_credentials_request_ip inet Device IP address used during the last credential request. last_seen_ip inet Most recent device IP address. | attributes | map&lt;varchar, varchar&gt; | Device attributes. It can contain arbitrary string key and values associated with the device. | groups | map&lt;text, timeuuid&gt; | Groups which the device belongs to, the key is the group name, and the value is its insertion timeuuid, which is used as part of the key on grouped_devices table. |","ref":"090-database.html#tables","title":"Astarte Database - Tables","type":"extras"},{"doc":"This section describes the schema changes happening between different Astarte Versions. They are divided between Astarte Keyspace (changes that affect the Astarte Keyspace), and Realm Keyspaces (changes that affect all realm keyspaces). Every change is followed by the CQL statement that produces the change. From v0.10 to v0.11 Astarte Keyspace v0.11 Changes Remove astarte_schema table DROP TABLE astarte_schema; Remove replication_factor column from the realms table ALTER TABLE realms DROP replication_factor; Realm Keyspaces v0.11 Changes Add grouped_devices table CREATE TABLE &lt;realm_name&gt;.grouped_devices ( group_name varchar, insertion_uuid timeuuid, device_id uuid, PRIMARY KEY ((group_name), insertion_uuid, device_id) ); Add groups , exchanged_bytes_by_interface and exchanged_msgs_by_interface columns to the devices table ALTER TABLE &lt;realm_name&gt;.devices ADD (groups map&lt;text, timeuuid&gt;, exchanged_bytes_by_interface map&lt;frozen&lt;tuple&lt;ascii, int&gt;&gt;, bigint&gt;, exchanged_msgs_by_interface map&lt;frozen&lt;tuple&lt;ascii, int&gt;&gt;, bigint&gt;); Add database_retention_ttl and database_retention_policy columns to the endpoints table ALTER TABLE &lt;realm_name&gt;.endpoints ADD ( database_retention_ttl int, database_retention_policy int ); From v0.11 to v1.0.0-beta.1 Realm Keyspace v1.0.0-beta.1 Changes The connected field of the devices table is now saved with a TTL, so it automatically expires if it doesn't gets refreshed by the hearbeat sent by the broker. This behaviour was added to avoid stale connected devices if they disconnect while the broker is down. Add metadata column to the devices table ALTER TABLE devices ADD ( metadata map&lt;varchar, varchar&gt; ); From v1.0-beta.1 to v1.0.0 Realm Keyspace v1.0.0 Changes Rename the metadata to attributes in the devices table Warning : migrating data from the metadata column to the attributes one is possible but is out of scope of this guide since this change happened between development releases. The procedure below just creates the new column and then deletes the old one without migrating data . You're free to implement a migration procedure between the two steps. ALTER TABLE devices ADD ( attributes map&lt;varchar, varchar&gt; ); ALTER TABLE devices DROP metadata;","ref":"090-database.html#schema-changes","title":"Astarte Database - Schema changes","type":"extras"},{"doc":"Introduction This documentation page describes a development version, for production systems please use the stable version instead. Astarte is an Open Source IoT platform focused on Data management. It takes care of everything from collecting data from devices to delivering data to end-user applications. To achieve such a thing, it uses a mixture of mechanisms and paradigm to store organized data, perform live queries. This guide focuses on daily operations for Astarte users and integrators. It goes through fundamental operations such as setting up triggers, querying APIs, integrating 3rd party applications and more. The user guide starts from the assumption that the reader is interacting with one or more well-known realms , and throughout the manual the assumption is that we're always operating inside a test realm, unless otherwise specified. Setting up realms is out of the scope of this guide, also because it's not a task the average user has to deal with. Please refer to the dedicated chapter of the Administrator manual to learn more about this specific topic. Before you begin, make sure you are familiar with Astarte's architecture, design and concepts .","ref":"001-intro_user.html","title":"Introduction","type":"extras"},{"doc":"Interacting with Astarte Astarte's interaction is logically divided amongst two main entities. Devices are the bottom end, and represent your IoT fleet. They can access Astarte only through a Transport, they are defined by a set of Interfaces which, in turn, also define on a very granular level which kind of data they can exchange. By design, they can't access any resource which isn't their own: such a behavior can be configured using Astarte as a middleman to act as a secure Gateway. Users are actual users, applications or anything else which needs to interact directly with Astarte. They are bound to a realm, and can virtually access any resource in that realm given they're authorized to do so. Users can also manage triggers and perform maintenance activity on the Realm.","ref":"010-interacting_with_astarte.html","title":"Interacting with Astarte","type":"extras"},{"doc":"When interacting with Astarte as a User, you have several options to choose from: astartectl : astartectl is the main command-line tool to interact with Astarte clusters, which packs in a number of subcommands to interact with Astarte API sets. It is a swiss army knife to perform daily operations on Astarte Clusters, and it abstracts most Astarte API interactions in a user-friendly way. Astarte Dashboard : Astarte provides a built-in UI that can be used for managing Interfaces, Devices and Triggers. It is meant to be a graphical, user-friendly tool to perform daily operations on Realms. Astarte API Clients: API Clients are provided for a variety of languages. These clients abstract API interaction with language-friendly paradigms, and provide API automations for several operations. Currently, the main API client available is astarte-go . Astarte APIs: The base APIs are the lower level interaction layer. They are accessible, in standard installations, at api.&lt;base Astarte URL&gt;/&lt;apiset&gt; , and are the main mean of interaction upon which all other clients are based upon. Grafana Datasource Plugin for Astarte : Thanks to the Astarte Datasource Plugin, data coming from Astarte may be visualised in custom dashboards provided by Grafana, the open source observability platform. Depending on the context, you might want to choose what suits you best. Over the course of the documentation, several examples will be provided with interaction means. Setting up astartectl In the documentation, it is assumed that astartectl is properly configured to interact with your Realm or your Cluster. Please refer to its documentation to make sure all needed configurations are in place.","ref":"010-interacting_with_astarte.html#user-side-tools","title":"Interacting with Astarte - User-side Tools","type":"extras"},{"doc":"Devices interact with Astarte through their associated Transport. In this guide, we'll assume the Transport is MQTT/VerneMQ as per Astarte's defaults. However, rather than implementing the whole Astarte protocol over MQTT, it is usually a better idea to rely on one of Astarte's SDKs . Authentication/Pairing Depending on how you plan on implementing Astarte's pairing mechanism , your devices might need an Agent for their first authentication or not. However, once they retrieve their Credentials Secret, they can implement Astarte's standard pairing routine to rotate their SSL certificate for accessing the transport. In the most likely scenario in which you are using one of Astarte's SDKs, the SDK takes care of the whole pairing routine under the hood and, depending on your agent implementation, you just need to feed the SDK with either the Credentials Secret or the Agent Key. Exchanging data As per Astarte's protocol specification, data is exchanged based on the device's introspection. The device will be able to publish data on the transport on device interfaces, and receive data on server interfaces. In the MQTT case, the device will subscribe to its server interfaces' topics, and publish on its device interfaces topics. Isolation and RBAC are guaranteed by the transport's ACL, which are usually orchestrated though a dedicated Astarte extension (as in the VerneMQ/MQTT case). Again, Astarte's SDK allows you to interact with your device interfaces directly without caring about the underlying protocol and exchange details.","ref":"010-interacting_with_astarte.html#interacting-with-a-device","title":"Interacting with Astarte - Interacting with a Device","type":"extras"},{"doc":"Astarte is mainly accessed through its APIs. Astarte's APIs are exposed through dedicated microservices (see Components ) and are meant both for configuration and for accessing data. There are two main sets of APIs we'll be using frequently: AppEngine API : This API is meant for querying/pushing data from/to devices. This maps to astartectl 's astartectl appengine subcommand. Realm Management API : This API is meant for configuring a target realm, and most notably for managing triggers. This maps to astartectl 's astartectl realm-management subcommand. Authentication Authenticating against Astarte is out of the scope of this guide, especially due to the fact that Astarte does not manage authentication directly . We'll assume either the authentication isn't enabled, or that the user is always interacting with the APIs with a token with the following claims { &quot;a_aea&quot;: &quot;.*:.*&quot;, &quot;a_rma&quot;: &quot;.*:.*&quot; } Which represents a realm administrator. In real life use cases, you should always make sure to give out more granular permissions and to obtain the token in the right way from your authentication server. When using astartectl or any other client, you can also pass a Realm Private Key as an authentication mean, and have the token be automatically generated for you. Accessing the APIs In a standard Astarte installation, AppEngine API and Realm Management API are usually accessible at api.&lt;your astarte domain&gt;/appengine and api.&lt;your astarte domain&gt;/realmmanagement . If your Astarte installation has Swagger UI enabled, you can use the /swagger endpoint to access it, and to issue API calls straight from your browser to follow this guide.","ref":"010-interacting_with_astarte.html#interacting-as-a-user","title":"Interacting with Astarte - Interacting as a User","type":"extras"},{"doc":"Astarte Dashboard Astarte provides a built-in UI that can be used for managing Interfaces, Devices, and Triggers. The Dashboard simplifies the development phases of applications that make use of Astarte, as well as troubleshooting activities. You can browse the source code of the Dashboard software on its GitHub repository .","ref":"015-astarte_dashboard.html","title":"Astarte Dashboard","type":"extras"},{"doc":"The Astarte Dashboard is a Single Page Application that provides users with an overview of their Realm and a user-friendy way of managing it on any web browser. The Dashboard is designed to be a quick and easy way to give you immediate feedback on your work and as a quick and intuitive way to configure your realm. It is not designed to be operated by end-users, rather by infrastructure maintainers, owners who need information on the system status, and those working on projects based on Astarte. It is shipped by default with the Astarte standard distribution. The Dashboard is a graphical client for Astarte APIs; it shares similar features with the CLI client astartectl , the command-line utility to manage Astarte. The Dashboard helps you manage: Triggers Interfaces Devices Groups Realm Settings In case your Astarte distribution comes packaged with the Flow framework , the Dashboard is probably configured to manage Flow resources as well. Blocks Pipelines Flows Please note that the Flow framework is not available for use in a docker-compose environment since it relies on Kubernetes APIs to operate. How to access it Depending on how you are using Astarte, here is where you can find the Dashboard: Docker-compose: if you are using a local instance of Astarte via docker-compose , you will find it by pointing your browser to the default address http://localhost:4040/ . To login, fill in the name of your realm and a valid JWT token: if you possess the realm private key, as it is the case if you followed the Astarte in 5 minutes guide, you can generate the token with the command astartectl utils gen-jwt all-realm-apis -k &lt;private_key&gt; . Astarte Cloud: if you are using our managed Astarte option, you can hop onto our Console , find or create your realm and click the Dashboard button. Kubernetes cluster: in this case, if the Dashboard is enabled, it can be usually found at dashboard.&lt;base Astarte URL&gt; . Refer to your system administrator for more details.","ref":"015-astarte_dashboard.html#introduction","title":"Astarte Dashboard - Introduction","type":"extras"},{"doc":"Upon successful login, the main screen is the home page that provides an overview of the realm status and resources. API Status The API Status gives you general information about the status of services: Realm Management is an administrator-like API for configuring a Realm. It is used for managing Interfaces and Triggers. AppEngine is Astarte's main API endpoint for end-users. AppEngine exposes a RESTful API to retrieve and send data from/to devices, according to their interfaces. Every direct device interaction can be done from here. It also exposes Channels, a WebSocket-based solution for listening to device events in real-time with the same mechanism and semantics used by Triggers. Pairing takes care of Device Authentication and Authorization. It interacts with Astarte's CA and orchestrates the way devices connect and interact with Transports. It also handles Device Registration. Agent, Device and Pairing interaction is described in detail here . Flow is the API endpoint for Astarte Flow, used for managing Blocks, Pipelines, and Flows. Possible statuses are: This service is operating normally. This service appears offline. A general status on API health is also present in the app's sidebar, thus always providing a feedback regardless of which page you are currently visiting. Realm resources Within the main overview, a brief summary is available as well for the existing resources of the realm: registered and connected devices, installed interfaces, and installed triggers. More detailed overviews of each resource are available in the dedicated Dashboard sections, accessible via the navigation links in the Dashboard's side menu.","ref":"015-astarte_dashboard.html#main-overview","title":"Astarte Dashboard - Main overview","type":"extras"},{"doc":"Interfaces are a core concept of Astarte which defines how data is exchanged between Astarte and its peers. You can navigate to this section thanks to the side menu of the Dashboard. A list of all installed interfaces is displayed, together with their major versions. Installing interfaces From the Interface list, clicking on the Install a new interface button will load up the Interface Editor , an interactive tool that you can use to configure your interfaces. The Interface Editor provides you with two ways to define your interfaces: on the left panel, a graphical frontend, while on the right panel you may input a JSON definition to achieve the same result. Each panel updates automatically whenever the other is changed. While defining a new interface, the Interface Editor will help you in supplying the right options and filling in mandatory entries such as: Name: an arbitrary name, formatted in reversed DNS casing. Major and Minor versions: based on Semantic Versioning . Type: indicates whether data is streamed continuously ( datastream ) or is stateful and persistent ( properties ). Ownership: the write-only allowed actor. All the other actors are read-only. Mappings: a list of endpoints that represent the data structure, following REST controller semantics. You can learn more about Interface definitions in their documentation's section . Note that when creating interface drafts, or for testing purposes in general, it is recommended to use 0 as the major version: to prevent data loss, Astarte allows only interfaces where major_version equals 0 to be deleted. Managing interfaces From the Interface list, you can select an interface to load and view its details in the Interface Editor. Clicking on the name of the interface will select its latest revision; clicking on a specific major of the interface will select the latest revision for that major. Note that interface revisions follow the Semantic Versioning convention. Once the Interface Editor is loaded you can review, update or delete the definition of the interface. Note that to prevent data loss, Astarte allows only interfaces where major_version equals 0 to be deleted. For similar reasons, when updating the definition of an interface, the Interface Editor will not allow you to change core properties on a minor version update. If you need to apply substantial changes, you can define and install a new major version for the interface.","ref":"015-astarte_dashboard.html#interfaces","title":"Astarte Dashboard - Interfaces","type":"extras"},{"doc":"Triggers in Astarte are the go-to mechanism for generating push events. You can navigate to this section thanks to the side menu of the Dashboard. A list of all installed triggers is displayed. Installing triggers From the Trigger list, clicking on the Install a new trigger button will load up the Trigger Editor , an interactive tool that you can use to configure your triggers. It works in a very similar fashion to Interface Editor and shares the same User Interface. The Trigger Editor provides you with two ways to define your triggers: on the left panel, a graphical frontend, while on the right panel you may input a JSON definition to achieve the same result. Each panel updates automatically whenever the other is changed. The graphical tool dynamically loads installed Interfaces in the Realm and eases trigger creation by providing not only linting and validation, but also dynamic resolution of Interface names. You can learn more about Trigger definitions in their documentation's section . Note that due to how triggers work, you should install the trigger before a device connects. Doing otherwise will cause the trigger to kick in at a later time, and as such no events will be streamed for a while. Managing triggers From the Trigger list, you can select a trigger to load and view its details in the Trigger Editor. Once the Trigger Editor is loaded you can review the definition of the trigger. You can also delete the trigger instance by clicking on the Delete trigger button.","ref":"015-astarte_dashboard.html#triggers","title":"Astarte Dashboard - Triggers","type":"extras"},{"doc":"Devices are Astarte's main entities for exchanging data. You can navigate to this section thanks to the side menu of the Dashboard. A list of all registered devices is displayed. Each device in the list is displayed together with info regarding its status and the last connection event . The status is represented by a grey dot if the device never connected to Astarte, a green dot if it is currently connected, a red dot if it is currently disconnected. The last connection event reports, if available, the date of the last connection or disconnection. A filter section is present on the side of the list to aid the search for specific devices, filtering the list by device ID, name, connection status, or configured attributes. Registering a device From the Device list, new devices may be registered by clicking on the Register a new device button which will take you to the registration page. Here you can proceed with the registration of the device by: providing a device ID: either by generating a random ID or by specifying a Name and Namespace UUID to generate the ID in a deterministic fashion. optionally declaring the initial introspection of the device: this is an indication of the list of interfaces that the device will use to exchange data. You can learn more about Devices and the registration process in their documentation's section . Device status and details From the Device list, you can select a device to navigate to its dedicated page. Here you can review and manage different info about your device. Device Info Device Info : displays info such as the device ID and the device Name alias, if set. It reports whether the device is currently connected or disconnected, or if it was never connected. From this section you can also momentarily Inhibit credentials for the device, preventing it to obtain access to Astarte; or you can directly Wipe credential secret of the device, a permanent action which will require to register the device again to have a new Credential Secret. Aliases : where you can manage custom aliases for the device. Note that setting a name alias will provide a name for the device. Attributes : a dedicated section to attach arbitrary info to the device, in a key-value form. Groups : where you can review and manage the Groups the device belongs to. Interfaces : a list of all currently and previously used interfaces. Clicking on an interface's name will load a dedicated page to review data exchanged by the device through that interface. Stats : a rundown on exchanged data via different interfaces. Here you can review, in both visual and numeric form, the quantity of bytes and messages the device is exchanging over each interface. This way you can always know at a glance which interfaces are the busiest and how chatty your device is. Status Events : here is info collected by Astarte regarding the IP addresses involved in the connections of the device to Astarte, the dates of first registration and credentials request, and the dates of last connection and disconnection, if available. Live Events : a section that reports live events regarding the device. It makes use of Astarte Channels and displays the connections, exchanged data, and errors of the device, as they happen in real-time.","ref":"015-astarte_dashboard.html#devices","title":"Astarte Dashboard - Devices","type":"extras"},{"doc":"Groups are logical collections of devices to ease the management and querying of devices. You can navigate to this section thanks to the side menu of the Dashboard. A list of all existing groups is displayed, together with the number of total and connected devices for each group. Creating a group From the Group list, clicking on the Create a new group button will load a dedicated page to setup the new group. You are required to specify a name for the group and to select at least one device that will belong to it. Indeed, note that a group must contain at least one device to exist. To confirm the creation of the new group, click the Create group button. Managing groups From the Group list, you can select a group to view its configuration on a dedicated page. Here you can review the list of devices that belong to it. To remove a device from a group, click on the Delete icon next to it. To add a device to a group, you can first navigate to the device's page and then add it to a group from there. To delete a group, remove all devices that belong to it and the group will automatically cease to exist.","ref":"015-astarte_dashboard.html#groups","title":"Astarte Dashboard - Groups","type":"extras"},{"doc":"Blocks are computation units that can be chained together to define a logical computation topology. You can navigate to this section thanks to the side menu of the Dashboard. Here is a list of all existing blocks, both custom and native ones: the former ones are those defined by you, the latter ones are those provided by Astarte and are displayed with a native label. Creating blocks From the Block list, clicking on the Create button will load a dedicated page to define a new block. Here you can define the block by specifying: A name for the block. A type , between Producer , Consumer or Producer &amp; Consumer , depending on how the block should treat messages and connect to other blocks. A schema , reporting the JSON Schema definition of how a configuration should look like for the block. A source , containing the implementation of the block, written in the DSL format for Pipelines. Confirm the creation of the block by clicking on the Create new block button. To learn more about block definition you can read their documentation's section . Managing blocks From the Block list, you can select a block to view its definition in a dedicated page. Here you can review the details of the block such as the block type, the schema and, if it is a custom block, its source. To delete a block, click on the Delete block button. Note that you cannot delete native blocks provided by Astarte.","ref":"015-astarte_dashboard.html#blocks","title":"Astarte Dashboard - Blocks","type":"extras"},{"doc":"A Pipeline is a computation blueprint (therefore a description) built as a chain of blocks. You can navigate to this section thanks to the side menu of the Dashboard. Here is a list of all existing pipelines from which you can review, manage and instantiate them. Creating pipelines From the Pipeline list, clicking on the Create button will load up the Pipeline Editor page, an interactive tool that you can use to configure your pipeline. The Pipeline Editor is composed of two parts: A sidebar listing all available Blocks, grouped by type A space where you can drag &amp; drop blocks, connecting them to effectively design a pipeline You can read more about the Pipeline Editor on the dedicated documentation . Once you have designed your pipeline, you can review and specify its: name source , containing the implementation of the pipeline, written in the DSL format for Pipelines. schema , reporting the JSON Schema definition of how a configuration should look like for the pipeline. description , explaining the scope and supposed usage of the pipeline. Then hit the Create new pipeline button to confirm the definition of the pipeline. Managing pipelines From the Pipeline list, you can select a pipeline to view its definition in a dedicated page. Here you can review the details of the pipeline such as the pipeline description, its schema, and its source. To delete a pipeline, click on the Delete pipeline button.","ref":"015-astarte_dashboard.html#pipelines","title":"Astarte Dashboard - Pipelines","type":"extras"},{"doc":"Flows are specific instances of a pipeline, created providing concrete values to the parametric configuration of a pipeline. You can navigate to this section thanks to the side menu of the Dashboard. Here is a list of all existing flows. Each flow reports its current status and the pipeline it originated from. To review the details of a Flow, click on its name to load up the dedicated page. To delete a flow, click on the Delete icon next to it. Instantiating flows From the Pipeline list, clicking on the Instantiate button of a Pipeline will load the Flow configuration page; from there you can supply a name and a configuration for the flow before hitting the Instantiate Flow button to confirm.","ref":"015-astarte_dashboard.html#flows","title":"Astarte Dashboard - Flows","type":"extras"},{"doc":"You can navigate to this section thanks to the side menu of the Dashboard. Here you can review and update settings for your realm. You can update the public key of the realm, which is useful if you mean to use a new private key to generate auth tokens. Please note that it is a permanent action and Astarte will prevent interactions that use auth tokens generated with the previous key.","ref":"015-astarte_dashboard.html#realm-settings","title":"Astarte Dashboard - Realm Settings","type":"extras"},{"doc":"Accessing and Exploring a Realm In Astarte, a Realm is a logical partition which holds a number of devices and an Authentication Realm","ref":"020-accessing_and_exploring_a_realm.html","title":"Accessing and Exploring a Realm","type":"extras"},{"doc":"Interface Design Guide Before we begin, let's get this straight: The way you design your interfaces will determine the overall performance and efficiency of your cluster This is because interfaces define not only the way data is exchanged between Astarte and Devices/Applications, but also how it will be stored, managed and queried . As such, it is fundamental to spend enough time on finding the most correct Interface design for your use case, keeping in mind how your users will consume your data, what might change in the future, what is fundamental and what is optional, and more.","ref":"029-interface_design_guide.html","title":"Interface Design Guide","type":"extras"},{"doc":"Before you begin, you might want to take a look at Astarte Interfaces Editor , which is also available in any Astarte Dashboard installation. Astarte Interfaces Editor gives you automated validation and linting for Astarte Interfaces, and also gives you a declarative editor with automatic JSON generation. It is well maintained and used as a reference for Interface design. Consider using it for building your interfaces.","ref":"029-interface_design_guide.html#use-the-right-tools","title":"Interface Design Guide - Use the right tools","type":"extras"},{"doc":"Without going into deeper details on what concerns Astarte's DB internals, there are some considerations one should always keep in mind when designing interfaces. Querying an Interface is fast, querying across Interfaces is painful Astarte's data modeling is designed to optimize queries within a single interface. Querying across interfaces is supported, but might affect performances significantly, especially if done frequently and with complex queries. This is especially true for triggers, as they could be evaluated very frequently. In general, if you plan on having different mappings which are frequently queried altogether, or dependent on each other for several triggers, you might be better off in having them all in the same Interface. Aggregation makes a difference Aggregation is a powerful feature, which comes with price and benefits. Even though each series has only one timestamp for all values, it is also true that losing granularity for endpoints might cause storage of redundant data if only one of the aggregated mappings change value. Moreover, in terms of data modeling, Aggregated interfaces imply the creation of a dedicated Cassandra table. Having a lot of aggregated interfaces might end up putting additional pressure on the Cassandra Cluster in terms of memory and overall performance. Your Cluster administrator might (rightfully) choose to limit the amount of installed aggregate interfaces in a Realm, or in the overall Cluster.","ref":"029-interface_design_guide.html#rationale","title":"Interface Design Guide - Rationale","type":"extras"},{"doc":"Rule of thumb: Favor extreme atomicity in case you expect your interfaces to change often, be as atomic as reasonably possible in case you want to favor performance and flexibility in querying data.","ref":"029-interface_design_guide.html#interface-atomicity","title":"Interface Design Guide - Interface Atomicity","type":"extras"},{"doc":"Managing Interfaces Interfaces define how data is exchanged over Astarte. For a Device to be capable of exchanging data into its Realm, its interfaces have to be registered into the Realm first. Let's walk over the whole process. It is assumed that you have read the Interface design guide before, to avoid bad surprises once your fleet starts rolling.","ref":"030-manage_interfaces.html","title":"Managing Interfaces","type":"extras"},{"doc":"Listing Interfaces You can list all installed interfaces in a given Realm. This will return all the valid installed Interface names, without any versioning. List Interfaces using astartectl $ astartectl realm-management interfaces list [com.my.Interface1 com.my.Interface2 com.my.Interface3] List Interfaces using Astarte Dashboard From your Dashboard, after logging in, click on &quot;Interfaces&quot; in the left menu. List Interfaces using Realm Management API GET &lt;astarte base API URL&gt;/realmmanagement/v1/test/interfaces {&quot;data&quot;: [&quot;com.my.Interface1&quot;,&quot;com.my.Interface2&quot;,&quot;com.my.Interface3&quot;]} Listing Major Versions for an Interface For each installed Interface, there can be any number of Major versions installed. This information can be retrieved by listing the available Major versions for a specific interface. In a realm, only the latest minor version of each major version of an Interface is kept. This can be done due to the fact that Semantic Versioning implies a new minor version doesn't introduce any breaking change (e.g.: deleting or renaming a mapping), and as such querying an older version of an interface using a newer one as a model is always compatible - some mappings might be empty, as expected, and will be disregarded. Astarte ensures upon Interface installation for this constraint, and as such you can always query the latest minor version of an Interface safely. List Versions using astartectl $ astartectl realm-management interfaces versions com.my.Interface1 [0 1 2] List Versions using Astarte Dashboard In the Dashboard's Interface page, click on any Interface name. A drop-down will appear, showing installed major versions for that Interface name. List Versions using Realm Management API GET &lt;astarte base API URL&gt;/realmmanagement/v1/test/interfaces/com.my.Interface1 {&quot;data&quot;: [0,1,2]} Getting an Interface Definition Astarte allows you to retrieve the Interface Definition for a given Name and Major Version pair. The definition is in the standard Interface JSON format. Get Interface Definition using astartectl $ astartectl realm-management interfaces show com.my.Interface1 0 { &quot;data&quot;: { &quot;version_minor&quot;: 2, &quot;version_major&quot;: 0, &quot;type&quot;: &quot;properties&quot;, &quot;ownership&quot;: &quot;device&quot;, &quot;mappings&quot;: [ { &quot;type&quot;: &quot;integer&quot;, &quot;path&quot;: &quot;/myValue&quot;, &quot;description&quot;: &quot;This is quite an important value.&quot; }, { &quot;type&quot;: &quot;integer&quot;, &quot;path&quot;: &quot;/myBetterValue&quot;, &quot;description&quot;: &quot;A better revision, introduced in minor 2, supported only by some devices&quot; }, { &quot;type&quot;: &quot;boolean&quot;, &quot;path&quot;: &quot;/awesome&quot;, &quot;allow_unset&quot;: true, &quot;description&quot;: &quot;Introduced in minor 1, tells you if the device is awesome. Optional.&quot; } ], &quot;interface_name&quot;: &quot;com.my.Interface1&quot; } } Get Interface Definition using Astarte Dashboard From the Interfaces page, click on an Interface name, and click on the Major version for which you'd like to see the definition. The Interfaces Editor window will open, with the Interface definition in the text box on the right. From the Editor page, it is also possible to add new mappings to the Interface and bump it to a new Minor. Get Interface Definition using Realm Management API GET &lt;astarte base API URL&gt;/realmmanagement/v1/test/interfaces/com.my.Interface1/0 { &quot;data&quot;: { &quot;version_minor&quot;: 2, &quot;version_major&quot;: 0, &quot;type&quot;: &quot;properties&quot;, &quot;ownership&quot;: &quot;device&quot;, &quot;mappings&quot;: [ { &quot;type&quot;: &quot;integer&quot;, &quot;path&quot;: &quot;/myValue&quot;, &quot;description&quot;: &quot;This is quite an important value.&quot; }, { &quot;type&quot;: &quot;integer&quot;, &quot;path&quot;: &quot;/myBetterValue&quot;, &quot;description&quot;: &quot;A better revision, introduced in minor 2, supported only by some devices&quot; }, { &quot;type&quot;: &quot;boolean&quot;, &quot;path&quot;: &quot;/awesome&quot;, &quot;allow_unset&quot;: true, &quot;description&quot;: &quot;Introduced in minor 1, tells you if the device is awesome. Optional.&quot; } ], &quot;interface_name&quot;: &quot;com.my.Interface1&quot; } }","ref":"030-manage_interfaces.html#querying-interfaces","title":"Managing Interfaces - Querying Interfaces","type":"extras"},{"doc":"Interfaces are supposed to change over time, and are dynamic. As such, they can be installed and updated. Interface installation means adding either a whole new Interface (as in: an Interface with a new name), or a new major version of an already known Interface. Interface update means updating a specific, existing interface name/major version with a new minor version. When designing interfaces, it is strongly advised to use Astarte Interface Editor. The Editor is embedded into any Astarte Dashboard installation but, in case your Astarte installation does not provide you with a Dashboard, you can use Astarte Interface Editor public online instance . Use it to write and validate your definitions, and install the resulting JSON file through either astartectl or Realm Management APIs. Synchronizing interfaces using astartectl astartectl provides a handy sync command that, given a list of Interface files, will synchronize the state of the Astarte Realm with your local interfaces. It is handy in those cases where your Realm has several interfaces, and you're storing Interfaces in a common place, such as a Git Repository - this is the average case for Astarte-based applications/clouds. Assuming you have a set of Interface files in your folder all with the .json extension, invoking astartectl realm-management interfaces sync will result in something like this: $ astartectl realm-management interfaces sync *.json Will install interface com.my.Interface1 version 0.2 Will install interface com.my.Interface2 version 1.1 Will update interface com.my.Interface3 to version 1.4 Do you want to continue? [y/n] y Interface com.my.Interface1 installed successfully Interface com.my.Interface2 installed successfully Interface com.my.Interface3 updated successfully to version 1.4 After invocation, your Astarte Realm will be up to date with all Interfaces in your local directory. Note: astartectl realm-management interfaces sync currently synchronizes Interfaces only from your local machine to the Realm, and not the other way round. In case the Realm has a more recent version of an interface compared to your local files, or it has some interfaces which are not referenced by your local files, no action will be taken. Install an Interface using Astarte Dashboard Access the Editor by going to the Interfaces page, and clicking on &quot;Install a New Interface...&quot; in the top-right corner. The Editor will open. From there, you can either paste in an existing JSON definition, which will be validated and will update the left-screen declarative Editor, or you can build a whole new Interface from scratch. Once you're done, hit the &quot;Install Interface&quot; button at the bottom of the declarative Editor (left side) to install the Interface in the Realm. Install an Interface using astartectl First of all, ensure that you have the Interface you'd like to install saved in a file on your local machine. We will assume the interface is available as interface1.json . $ astartectl realm-management interfaces install interface1.json ok Install an Interface using Realm Management API Realm Management currently implements a completely asynchronous API for Interface installation - as such, the only feedback received by the API is that the Interface is valid and the request was accepted by the backend. However, this is no guarantee that the Interface will be installed successfully. As a best practice, it is advised to either wait a few seconds in between Realm Management API invocations, or verify through a GET operation whether the Interface has been installed or not. POST &lt;astarte base API URL&gt;/realmmanagement/v1/test/interfaces The POST request must have the following request body, with content type application/json { &quot;data&quot;: { &quot;version_minor&quot;: 2, &quot;version_major&quot;: 0, &quot;type&quot;: &quot;properties&quot;, &quot;ownership&quot;: &quot;device&quot;, &quot;mappings&quot;: [ { &quot;type&quot;: &quot;integer&quot;, &quot;path&quot;: &quot;/myValue&quot;, &quot;description&quot;: &quot;This is quite an important value.&quot; }, { &quot;type&quot;: &quot;integer&quot;, &quot;path&quot;: &quot;/myBetterValue&quot;, &quot;description&quot;: &quot;A better revision, introduced in minor 2, supported only by some devices&quot; }, { &quot;type&quot;: &quot;boolean&quot;, &quot;path&quot;: &quot;/awesome&quot;, &quot;allow_unset&quot;: true, &quot;description&quot;: &quot;Introduced in minor 1, tells you if the device is awesome. Optional.&quot; } ], &quot;interface_name&quot;: &quot;com.my.Interface1&quot; } } The call will return either 201 Created or an error. Most common failure cases are: The interface/major combination already exists in the Realm The interface schema fails validation In any case, the API returns details on what caused the error and how to solve it through Astarte's standard error reply schema. Update an Interface using astartectl First of all, ensure that you have the Interface you'd like to update saved in a file on your local machine. We will assume the interface is available as interface1_3.json . $ astartectl realm-management interfaces update interface1_3.json ok Update an Interface using Astarte Dashboard Go to the Interfaces page, click on the Interface Name you'd like to update, and click on the Major version which is referred by your upgrade (e.g.: if you're updating from 1.2 to 1.3, you want to click on Major Version 1). The Editor will appear, populated with the currently installed Interface definition. Paste in your updated JSON file, or use the declarative editor to make your changes. The editor will be limited to Semantic Version-compatible operations (as in - adding new mappings). Once you're done, hit the &quot;Apply Changes&quot; button at the bottom of the declarative Editor (left side) to update the Interface in the Realm. Update an Interface using Realm Management API To update an existing interface, issue a PUT /interfaces/&lt;name&gt;/&lt;major&gt; endpoint of the realm with the very same semantics as the Installation procedure. The call will return either 201 Created or an error. Apart from the very same errors that could be triggered upon installation, Update will also fail if the interface doesn't provide a compatible upgrade path from the previously installed minor. Interface update limitations Major version updates Major version updates have no intrinsic limitations as they are not meant to ensure compatibility with older versions of the same interface. Therefore, if you plan to bump your interface major you are allowed to update your interface at your preference. Please, refer to the Interface Design Guide to follow the best practices while developing your new updated interface. Minor version updates Minor version updates are conceived to guarantee retro-compatibility and, as such, they allows only for a limited subset of update operations. Currently, based on the interface type and aggregation, different update capabilities are provided: properties : at interface root level, doc and description updates are allowed; at mapping level, doc and description updates are allowed. Moreover, an arbitrary number of new mappings can be added; individual datastream : at interface root level, doc and description updates are allowed; at mapping level, doc , description and explicit_timestamp updates are allowed. Moreover, an arbitrary number of new mappings can be added; object aggregated datastream : currently, due to a limitation in how data are stored within Cassandra, the doc , descriprion and explicit-timestamp fields can not be updated; at mapping level, an arbitrary number of mappings can be added. Where not explicitly stated, all the other values are to be considered as not updatable. In case you need to update one of those fields, please consider updating your interface major version.","ref":"030-manage_interfaces.html#installing-updating-an-interface","title":"Managing Interfaces - Installing/Updating an interface","type":"extras"},{"doc":"Interfaces are versioned through a semantic versioning-like mechanism. A Realm can hold any number of interfaces and any number of major versions of a single interface. It holds, however, only the latest installed minor version of each major version, due to the inherent compatibility of Semantic Versioning. There is no significant cost in adding a non-aggregated interface to a Realm or updating a non-aggregated interface frequently - keep in mind, however, that you might incur in dangling data in your devices if you don't plan your interface update strategy accurately. For what concerns Aggregated interfaces, instead, there is an inherent cost which might end up in putting pressure on your Cluster . Once an interface has been installed in a Realm, it can't be uninstalled without performing manual operations on Astarte's DB, unless its major version number is 0 . This is a safety measure to prevent dangling data from appearing in the cluster. For this reason, when developing an Astarte-based interface, it is strongly advised to keep its major number to 0 to allow quick changes at the expense of data loss. Please note, however, that deleting a major 0 interface is possible if the Realm has no devices left declaring that specific interface in their introspection. This is done to avoid forever dangling data and potential consistency errors. This limitation might be lifted in the future through a mass-deletion mechanism, but there is no guarantee this will ever be done. It is advised to test new interfaces on a limited number of devices to ease operations.","ref":"030-manage_interfaces.html#interfaces-lifecycle","title":"Managing Interfaces - Interfaces lifecycle","type":"extras"},{"doc":"There is a clear difference between how Interfaces are managed in a Realm and its Devices (e.g.: the device Introspection). Whereas a Realm can have any number of versions of a single interface, a Device is allowed to expose in its introspection only a single, specific version of an Interface. In general, Realm interfaces are kept as a shared agreement between its entities, but when it comes to interacting with a Device, the Realm honors its introspection (as long as the Device declares interfaces the Realm is knowledgeable about). As such, installing an interface in a Realm is a completely safe and non-disruptive operation: by design, Devices aren't aware of which interfaces a Realm supports, and Realms don't impose any interface versioning on a Device.","ref":"030-manage_interfaces.html#realm-vs-device-interface-relationship","title":"Managing Interfaces - Realm vs. Device Interface relationship","type":"extras"},{"doc":"Due to how minor versions work, it is responsibility of the end user to prevent accidental data loss due to missing data. Every mapping declared in a new minor release must be assumed as optional, as there is no guarantee that a Device will be able to publish (or receive) data on that specific mapping. Minor version bumps work great in case they represents additional, optional features which might be available on an arbitrarly large subset of Devices implementing that interface's major version, and are not necessary or fundamental for normal operations. If that is not the case, consider a major version update or a whole new interface instead. Also, please keep in mind that designing interfaces in the right way, especially being as atomic as reasonably possible, helps a lot in preventing situations where a minor interface update can't be done without disrupting operations. Again, the Interface design guide covers this topic extensively.","ref":"030-manage_interfaces.html#caveats","title":"Managing Interfaces - Caveats","type":"extras"},{"doc":"In several situations, it is possible to have dangling data inside Astarte. This happens by design, as the liquid nature of a Device makes it possible for data to be stored in interfaces no longer present in its introspection. Astarte does not delete data unless requested explicitly: as such, data remains available inside its database, but potentially inaccessible through the cluster's APIs and standard mechanism. As of the current version, Astarte has no mechanism for retrieving and acting upon a device's dangling data - this is a limitation that will be lifted in future releases with additions to the current API. Interface major version change If a device upgrades one of its interfaces to a new major version, the previous interface is parked and its data remains dangling. Every API call, trigger, or reference to the interface will always target the major version declared in the introspection, regardless of the fact that a more recent version might have been installed in the realm. Interface deletion from device A device might arbitrarly decide to remove an interface from its introspection. In such a case, Astarte won't return any data and will consider all data previously pushed to said interface inaccessible. In case the interface comes back again in the introspection, previously pushed data will be available as if nothing happened.","ref":"030-manage_interfaces.html#dangling-data","title":"Managing Interfaces - Dangling data","type":"extras"},{"doc":"Registering a Device Devices are Astarte's main entities for exchanging data. Even though a Device usually represents the physical Device communicating with Astarte, they might as well be mapped to other entities, such as individual sensors or aggregated gateways. A Device always belongs to a Realm and is identified by a Device ID , which has to be unique at least within its Realm. Devices communicate with Astarte through Transports - in most installations, this means through an MQTT Broker (VerneMQ with Astarte's plugin). Before this happens, though, Devices must obtain credentials for accessing their Transport and, most of all, make themselves known to Astarte. This happens through the Registration process. In Astarte, Registering a device means obtaining an unique Credentials Secret (Registration Credentials), univocally associated to a Device ID, through a well-known workflow and pipeline. If you are not familiar with these concepts, please refer to Pairing Architecture to learn more about Pairing's workflow basics. The Credentials Secret can then be used by the Device for accessing Pairing API and getting information and Credentials for its Transport. As such, registration happens only once during a Device's lifecycle, and is a security-sensitive process. As such, this process is usually carried over (in production scenarios) through an Agent .","ref":"035-register_device.html","title":"Registering a Device","type":"extras"},{"doc":"An Agent 's purpose is to perform Registration on behalf of a Device. Agents should be the only components in your infrastructure with enough credentials to access Pairing's Agent APIs (as a rule of thumb, it is a bad idea to give access to Pairing API to anything which isn't an Agent). When setting up an Astarte project, it is fundamental to define beforehand how your Devices will be registered and hence where your Agent(s) will belong. There's two main ways for implementing an Agent, even though in production scenarios On Board Agents are strongly discouraged as they expose a single point of failure in terms of a Realm's whole fleet security. On Board Agent Please keep in mind that On Board Agents are not advised in production, as a single compromised device/token might compromise the Registration routine for your entire fleet. They should be used only in non-critical use cases or during testing and development. On Board Agents are provided as a feature by Astarte's SDK, and hide the detail of Device registration by integrating an Agent into the SDK itself. This allows to deliver the same credentials to each device belonging to a Realm. Of course, this also opens up a single point of failure in the whole fleet's security, as Credentials aren't tied to a specific device - as such, if compromised, they might allow an attacker to register an arbitrary device into a Realm, unless other policies prevent him from doing so. To create a On Board Agent, you simply need to emit a long-enough lived token from your Realm's private key with access to Pairing's Agent APIs . This token should then be delivered to your devices and provided to the SDK in order to carry over the Registration. The SDK will do this automatically and without any need for additional code, as long as you set the agentKey configuration key to a meaningful value, and no Credentials Secret has been set. 3rd Party Agent A more secure approach to the Registration process is having a 3rd Party agent. In such a case, an external component is in charge of requesting a Credentials Secret to Pairing and delivering it to the target Device. This approach has a number of benefits: in terms of Security, the Agent uses a short-lived token and can follow the Realm's authentication workflow just like any other application. For what concerns daily operations, the Agent can implement any arbitrary logic to make a decision on whether a Device should be registered or not. In such cases, Devices have an out-of-band communication mechanism with the Agent in which the Credentials are exchanged. Usually, these cases fall under two main categories: &quot;Local&quot; or &quot;Plant&quot; Agents In this scenario, devices are imprinted with their Credentials Secret in the production plant. The Device might not even be connected to the Internet, whereas the machine running the Agent has access to the target Astarte Cluster and adequate Credentials for Registration. Once the Agent acquires the Device ID of the Device which should be registered, it issues the request to Astarte's Pairing API and obtains the Device's Credentials Secret . At this stage, the Agent is in charge of delivering the Credentials Secret to the Device the way it sees fit. As a best practice, the Credentials Secret should then be saved to an OTP area or a dedicated secure storage in the device to prevent tampering or accidental loss. Even though this is arguably the most secure mechanism available for Registering a Device, it might not fit every use case as the Device will be irrevocabily assigned to a specific Astarte Cluster and a specific Realm in that Cluster before it even connects. &quot;Remote&quot; Agents If your use case demands more flexibility, Registering a Device in a plant might not fit your Device's lifecycle. This could be likely if, for example, Realm or Cluster assignment should be done dynamically once the Device reaches its final user. In this case, this role is usually delegated to an external web application acting as an Agent. In this case, it's up to the user setting up all mechanisms for delivering the Credentials Secret to the Device, which includes securing the communication channel. On the other hand, this allows an extremely flexible approach to Registration, which can be implemented through an entirely custom logic.","ref":"035-register_device.html#registration-agent","title":"Registering a Device - Registration Agent","type":"extras"},{"doc":"Credentials Secrets are meant to be immutable - as such, they should be handled with extreme care. Credentials Secrets are used only for interacting with Pairing, hence to obtain Credentials for a Transport which, on the other hand, are meant to be volatile. A Device can be Registered an arbitrary number of times before its Credentials Secret is used for the first time for interacting with Pairing. This is done to ensure the entire Registration process, including any kind of external custom logic of the Agents, has been carried over successfully, allowing a de-facto &quot;retry&quot; until there's certainty the Device has access to its Credentials Secret . Please note that when Registering a Device, a new Credentials Secret is generated every time.","ref":"035-register_device.html#credentials-secret-lifecycle","title":"Registering a Device - Credentials Secret Lifecycle","type":"extras"},{"doc":"Once the Credentials Secret is used for retrieving Credentials for a Transport for the first time, Astarte prevents further registration of the same Device again. If there's the need of registering the device again (e.g.: a Device has been tampered and got back to its plant with its previous Credentials Secret compromised), it is possible to explicitly unregister the device to obtain a new Credentials Secret using Pairing's Agent APIs or with astartectl (see the output of astartectl pairing agent unregister -h for more documentation).","ref":"035-register_device.html#unregistering-a-device","title":"Registering a Device - Unregistering a device","type":"extras"},{"doc":"Connecting a Device Once a Device has been Registered in Astarte, it is capable of connecting to it. Devices connect to Astarte through the use of Transports . A Transport is an arbitrary protocol implementation which maps Astarte's concepts (mainly Interfaces) to a communication channel. Astarte's main supported Transport is Astarte/MQTT, implemented on top of VerneMQ through an additional plugin , and it is used by Astarte's SDKs for communication. However, virtually any protocol can be integrated in Astarte by creating a corresponding Transport. Transports also define the authentication/authorization mechanism of their Devices. For instance, Astarte/MQTT uses mutual SSL Authentication with Certificate Rotation for securing its Ingress and identifying its clients. To manage their Transport(s) and Credentials, Devices have to interact with Pairing.","ref":"040-connect_device.html","title":"Connecting a Device","type":"extras"},{"doc":"Once a Device has performed its first registration through an Agent, it holds its Credentials Secret . This Credentials Secret is the token the device uses for performing the actual Pairing routine, which results in the device obtaining its Credentials for accessing its designated Transport. A Device's Credentials Secret allows access to Pairing API's Device REST API , which is then used for obtaining information about which Transports the Device can use for communicating, and for obtaining Credentials for its assigned Transports. The ability to request Credentials of a Device can be inhibited with AppEngine API or using astartectl with this command: astartectl appengine devices credentials inhibit &lt;device_id_or_alias&gt; true \\ -k &lt;appengine-key&gt; -r &lt;realm-name&gt; -u &lt;astarte-api-url&gt; Once its credentials_inhibited field is set to true , a Device is not able to request new Credentials. Note that Credentials that were already emitted will still be valid until their expiration. As, from a user's standpoint, the way a Device communicates with Astarte is entirely Transport-specific, this guide will cover using Astarte/MQTT through one of Astarte's SDKs. If you are using a different Transport, please refer to its User Guide, or if you wish to implement your own, head over to Transport Developer Documentation .","ref":"040-connect_device.html#credentials-secret-pairing-and-transports","title":"Connecting a Device - Credentials Secret, Pairing and Transports","type":"extras"},{"doc":"If you are using one of Astarte's SDK, the Pairing routine is entirely managed, and you won't need to do any of the aforementioned steps. Just make sure your Credentials Secret is passed as the apiKey configuration key, to allow the SDK to perform automatically the Pairing routine when needed. The SDK does a number of automated things under the hood. Its flow is: The SDK verifies if a SSL certificate for connecting to the broker is present. If it is, it attempts connecting to the Transport. If the Transport doesn't accept the connection due to an SSL error, it queries Pairing API about its certificate status. If Pairing API returns a problem with the certificate or, in general, the certificate isn't valid, the certificate is erased and the Pairing procedure begins. The SDK invokes Pairing API until it manages to obtain a valid Certificate for the Transport. The SDK considers a Device successfully paired when it has a valid certificate and manages to connect to the Transport. Once in this state, the Device can start exchanging data. Note: the Pairing procedure is secure as long as Pairing API is queried using HTTPS. Plain HTTP installations are vulnerable to a number of different attacks and should NEVER be used in production. Interfaces and Introspection A Device must have some installed interfaces to be capable of exchanging data. These interfaces must be made known to the SDK and installed in the Device's Realm, as previously explained . The SDK expects the user to provide a directory containing a set of valid interfaces. It then takes care of making Astarte aware of its registered interfaces through a process called Introspection. Introspection is a special control message in Astarte's protocol which makes Astarte aware of a list of Interfaces and relative versions which are installed on the Device. Again, Astarte's SDK, given a directory, is capable of performing the correct procedures for keeping Introspecting in sync correctly without any kind of user intervention. Astarte's SDK also takes care of updating a Device's Introspection if its interfaces change. Exchanging data When a Device connects successfully, it must then subscribe to its server Interfaces. The SDK takes care of this detail and exposes a higher level interface. For example, using the Qt5 SDK: { m_sdk = new AstarteDeviceSDK(QStringLiteral(&quot;/path/to/transport-astarte.conf&quot;), QStringLiteral(&quot;/path/to/interfaces&quot;), deviceId); connect(m_sdk-&gt;init(), &amp;Hemera::Operation::finished, this, &amp;AstarteStreamQt5Test::checkInitResult); connect(m_sdk, &amp;AstarteDeviceSDK::dataReceived, this, &amp;AstarteStreamQt5Test::handleIncomingData); } void AstarteStreamQt5Test::handleIncomingData(const QByteArray &amp;interface, const QByteArray &amp;path, const QVariant &amp;value) { qDebug() &lt;&lt; &quot;Received data, interface: &quot; &lt;&lt; interface &lt;&lt; &quot;path: &quot; &lt;&lt; path &lt;&lt; &quot;, value: &quot; &lt;&lt; value &lt;&lt; &quot;, Qt type name: &quot; &lt;&lt; value.typeName(); } Applications can simply connect to the handleIncomingData signal and have data correctly formatted and delivered as it runs through the transport. On the other hand, for sending data: m_sdk-&gt;sendData(interface, path, value); The SDK will check if data is coherent with its introspection, and send data onto the transport in the correct way. Reliability, retention and persistency in the SDK Astarte's SDK has an internal concept of persistency, depending on the behaviour defined in its installed Interfaces. The retention parameter, specifically, tells Astarte's SDK how hard it should try to send a specific message. In case the Transport is unreachable, the SDK might try to persist, either in memory or on disk, and send the message when the connection is available again. Please note that these parameters declared in Interfaces are to be considered on a best effort basis. In case your SDK does not support persistency or has persistency disabled, a number of warranties requested by an Interface might not be satisfied. Make sure your SDK is configured correctly before moving to production.","ref":"040-connect_device.html#using-astarte-mqtt-through-astarte-sdk","title":"Connecting a Device - Using Astarte/MQTT through Astarte SDK","type":"extras"},{"doc":"Astarte Device SDKs","ref":"041-astarte_device_sdks.html","title":"Astarte Device SDKs","type":"extras"},{"doc":"Astarte Device SDKs are ready to use libraries that provide communication and pairing primitives. They allow to connect any device to an Astarte instance. While an SDK is not strictly required to connect an application to Astarte using MQTT, it enables rapid development and a pleasant developer experience. Astarte Device SDKs should not be confused with client SDKs, as they are not meant for client to device communications. If one is interested in an abstraction layer on top of existing APIs instead, an optional Astarte Client SDK (such as astarte-go ) is to be used. Under the hood Astarte Device SDKs make use of MQTT, BSON, HTTP, persistence and crypto libraries to implement Astarte MQTT v1 Protocol and all the other useful features. They can be easily integrated into new or existing IoT projects written in any of the supported languages or platforms. At the moment the following SDKs are available: C ESP32: astarte-device-sdk-esp32 C++ Qt5: astarte-device-sdk-qt5 Elixir: astarte-device-sdk-elixir Go: astarte-device-sdk-go Java Android: astarte-device-sdk-java Generic: astarte-device-sdk-java Python: astarte-device-sdk-python Rust: astarte-device-sdk-rust Further languages and platforms will be supported in the near future. Requests for new SDKs are welcome.","ref":"041-astarte_device_sdks.html#introduction","title":"Astarte Device SDKs - Introduction","type":"extras"},{"doc":"MQTT Connection Astarte Device SDKs make use of platform specific MQTT libraries and they hide all MQTT connection management details, including smart reconnection (randomized reconnection backoff is used). Device ID Generation Some of the Astarte Device SDKs (such as the ESP32) offer optional device id generation utils that can use the hardware id as seed. Automatic Registration (Agent) Astarte Device SDKs can provide an optional automatic registration mechanism that can be used on the field, avoiding any manual data entry or additional operations. This optional component can be disabled when performing registration during manufactoring process. Client SSL Certs Request and Renewal Astarte Device SDKs make use of short lived SSL certificates which are automatically renewed before their expiration. Astarte Device SDKs take care of the complete process from the certificate generation to the certificate signing request. Data Serialization and Protocol Management MQTT payloads are format agnostic, hence a serialization format should be used before transmitting data. For this specific purpose Astarte makes use of BSON format which easily maps to JSON. Astarte Device SDKs take care on user behalf of data serialization to BSON. Last but not least some additional signaling messages are exchanged such as the introspection, Astarte Device SDKs take care of automatically sending them and applying data compression when necessary. Data Persistence and Automatic Retransmission Astarte Device SDKs allow configuring persitence and reliability policies. In case of connection loss data is stored to memory or disk (according to mappings configuration) and they are automatically retransmitted as soon as the device is back online. This feature is not available yet on Elixir, ESP32, Go and Python SDKs and might be not avilable on other platforms with constrained resources. Smart Properties Sync Astarte has support for the concept of properties, which are kept synchronized between the server and the device. Thanks to the Astarte MQTT v1 Protocol an incremental approach is employed therefore only changed properties are synchronized. This feature is not available yet on Elixir, Go and Python SDKs and might be not avilable on other SDKs with no session_present support. Data Validation Astarte Device SDKs take care of data validation before sending any data, hence errors are reported locally on the device improving troubleshooting experience. This feature is not available yet on ESP32 and is WIP on Rust and Python.","ref":"041-astarte_device_sdks.html#sdks-features","title":"Astarte Device SDKs - SDKs Features","type":"extras"},{"doc":"A device must be registered beforehand to obtain its credentials-secret . While there are some manual options (such as using the astartectl command or using the Astarte Dashboard ), almost all Astarte Device SDKs allow to programmatically register a Device. For Go you can use the astarte_go client. Device id Device ids are 128-bit long url-safe base64 strings without padding. They can be deterministic (UUID v5) or random (UUID v4). UUID v5 are obtained from a namespace UUID and a payload (a string). While all SDKs work with user-provided device ids, some also provide utilities to for UUID generation. C (ESP32) with an unique hardware ID using device MAC address and other identification bits: // deterministic id astarte_err_t astarte_hwid_get_id(&amp;hw_id); C++ (Qt5): not supported. Elixir: UUIDv5 can be obtained using the elixir_uuid library . # random id device_id = :crypto . strong_rand_bytes ( 16 ) |&gt; Base . url_encode64 ( padding : false ) #deterministic id device_id = UUID . uuid5 ( namespace_uuid , payload , :raw ) |&gt; Astarte.Core.Device . encode_device_id ( ) Go (using the Astarte Go Client ): // Random id random_id, err := GenerateRandomAstarteId() // Namespaced id namespaced_id, err := GetNamespacedAstarteDeviceID(namespaceUuid,payload) Java/Android: // Random id String randomID = AstarteDeviceIdUtils.generateId(); // Namespaced id String deviceID = AstarteDeviceIdUtils.generateId(namespaceUuid, payload); Python: not supported. Rust: /// Random id let random_uuid = astarte_sdk::registration::generate_random_uuid(); ///Namespaced id let namespaced_id = astarte_sdk::registration::generate_uuid(namespaceUuid, &amp;payload); Automatic Registration (Agent) You can refer to the Astarte API for device registration for more details. C (ESP32): astarte_pairing_config cfg = { .base_url = &amp;base_astarte_url; .jwt = &amp;jwt_token; .realm = &amp;realm; .hw_id = &amp;device_id; .credentials_secret = &amp;credentials_secret; }; astarte_err_t err = astarte_pairing_register_device(&amp;astarte_pairing_config); C++ (Qt5): registration is done on device instantiation, see the next section. Elixir: { :ok , %{ body : %{ &quot;data&quot; =&gt; %{ &quot;credentials_secret&quot; =&gt; credentials_secret } } } } = Agent . register_device ( client , device_id ) Go (using the Astarte Go Client ): credentials_secret, err := client.Pairing.RegisterDevice(realm, deviceID) Java/Android: AstartePairingService astartePairingService = new AstartePairingService(pairing_url, realm); String credentialsSecret = astartePairingService.registerDevice(jwt_token, device_id); Python: credentials_secret = register_device_with_jwt_token(device_id, realm, jwt_token, pairing_base_url) or credentials_secret = register_device_with_private_key(device_id, realm, private_key_file, pairing_base_url) Rust: let credentials_secret = astarte_sdk::registration::register_device(&amp;jwt_token, &amp;pairing_url, &amp;realm, &amp;device_id) .await?; Device Unregistration Unregistering a device boils down to making its credentials secret invalid. Just as device registration, there are manual or programmatic options. In all cases, you can use the astartectl command astartectl , the Astarte Dashboard ), or the Astarte API for device unregistration . For Go and Elixir, you can also do this programmatically. C (ESP32): not supported. C++ (Qt5): not supported. Elixir: :ok = Agent . unregister_device ( client , device_id ) Go (using the Astarte Go Client ): err := client.Pairing.UnregisterDevice(realm, deviceID) Java/Android: not supported. Python: not supported. Rust: not supported.","ref":"041-astarte_device_sdks.html#device-registration","title":"Astarte Device SDKs - Device Registration","type":"extras"},{"doc":"Each device must declare the set of supported interfaces and their version. Astarte needs to know which interfaces the device advertises before processing any further data publish. This message in Astarte jargon is called introspection and it's performed by publishing on the device root topic the list of interfaces that are installed on the device. The Astarte Device SDKs take care of performing the introspection on user behalf. In order to do so, the Astarte Device SDKs need to have some informations about the registered device: the Astarte realm in which the device is registered its device id its credentials_secret the url of Astarte pairing service the path of the desired interfaces. Then the Astarte Device SDKs will be able to connect the device to Astarte and perform introspection. C (ESP32): astarte_device_config_t cfg = { .data_event_callback = astarte_data_events_handler, .connection_event_callback = astarte_connection_events_handler, .disconnection_event_callback = astarte_disconnection_events_handler, }; astarte_device_handle_t device = astarte_device_init(&amp;cfg); if (!device) { ESP_LOGE(TAG, &quot;Failed to init astarte device&quot;); return; } astarte_device_add_interface(device, &amp;device_example_interface); if (astarte_device_start(device) != ASTARTE_OK) { ESP_LOGE(TAG, &quot;Failed to start astarte device&quot;); return; } C++ (Qt5): // declare device options and interfaces m_sdk = new AstarteDeviceSDK(QDir::currentPath() + QStringLiteral(&quot;./examples/device_sdk.conf&quot;).arg(deviceId), QDir::currentPath() + QStringLiteral(&quot;./examples/interfaces&quot;), deviceId.toLatin1()); // initialize device connect(m_sdk-&gt;init(), &amp;Hemera::Operation::finished, this, &amp;AstarteStreamQt5Test::checkInitResult); // set data handlers connect(m_sdk, &amp;AstarteDeviceSDK::dataReceived, this, &amp;AstarteStreamQt5Test::handleIncomingData) Elixir: # declare device options opts = [ pairing_url : pairing_url , realm : realm , device_id : device_id , interface_provider : &quot;./examples/interfaces&quot; , credentials_secret : credentials_secret ] # start device and connect asynchronously { :ok , pid } = Device . start_link ( opts ) # blocking (optional) :ok &lt;- Device . wait_for_connection ( device_pid ) Go: // Create device d, err := device.NewDevice(deviceID, deviceRealm, credentialsSecret, apiEndpoint) if err != nil { fmt.Println(err.Error()) os.Exit(1) } // Load interface - fix this path(s) to load the right interface byteValue, err := ioutil.ReadFile(&quot;/examples/interfaces/com.example.Interface.json&quot;) if err != nil { fmt.Println(err.Error()) os.Exit(1) } iface := interfaces.AstarteInterface{} if iface, err = interfaces.ParseInterface(byteValue); err != nil { fmt.Println(err.Error()) os.Exit(1) } if err = d.AddInterface(iface); err != nil { fmt.Println(err.Error()) os.Exit(1) } // Set up callbacks d.OnConnectionStateChanged = func(d *device.Device, state bool) { fmt.Printf(&quot;Device connection state: %t\\n&quot;, state) } // Connect the device and listen to the connection status channel c := make(chan error) d.Connect(c) if err := &lt;-c; err == nil { fmt.Println(&quot;Connected successfully&quot;) } else { fmt.Println(err.Error()) os.Exit(1) } Java: // Device creation // connectionSource allows to connect to a db for persistency // The interfaces supported by the device are populated by ExampleInterfaceProvider AstarteDevice device = new AstarteGenericDevice( deviceId, realm, credentialsSecret, new ExampleInterfaceProvider(), pairingUrl, connectionSource); // ExampleMessageListener listens for device connection, disconnection and failure. device.setAstarteMessageListener(new ExampleMessageListener()); // Connect the device device.connect(); Python: # declare device options device = Device(device_id, realm, credentials_secret, pairing_base_url) # load device interfaces device.add_interface(json.loads(&quot;/examples/interfaces/com.example.Interface.json&quot;)) #register a callback that will be invoked everytime the device successfully connects device.on_connected(callback) #connect the device asynchronously device.connect() Rust: /// declare device options let mut sdk_options = AstarteOptions::new(&amp;realm, &amp;device_id, &amp;credentials_secret, &amp;pairing_url); /// load interfaces from a directory sdk_options .add_interface_files(&quot;./examples/interfaces&quot;) .unwrap(); /// build Astarte client sdk_options.build().await.unwrap(); /// connect the device let mut device = sdk_options.connect().await.unwrap();","ref":"041-astarte_device_sdks.html#declaring-interfaces-introspection","title":"Astarte Device SDKs - Declaring interfaces / Introspection","type":"extras"},{"doc":"All Astarte Device SDKs have a primitive for sending data to a remote Astarte instance. Using Individual Aggregated Interfaces In Astarte interfaces with individual aggregation, each mapping is treated as an independent value and is managed individually. Following examples show how to send a value that will be inserted into the &quot;/test0/value&quot; time series which is defined by &quot;/%{sensor_id}/value&quot; parametric endpoint (that is part of &quot;org.astarte-platform.genericsensors.Values&quot; datastream interface). C (ESP32): struct timeval tv; gettimeofday(&amp;tv, NULL); uint64_t ts = tv-&gt;tv_sec * 1000 + tv-&gt;tv_usec / 1000; astarte_err_t err = astarte_device_stream_double_with_timestamp(device, &quot;org.astarte-platform.genericsensors.Values&quot;, &quot;/test0/value&quot;, 0.3, ts, 0); C++ (Qt5): m_sdk-&gt;sendData(&quot;org.astarte-platform.genericsensors.Values&quot;, &quot;/test0/value&quot;, 0.3, QDateTime::currentDateTime()); Elixir: Device . send_datastream ( pid , &quot;org.astarte-platform.genericsensors.Values&quot; , &quot;/test0/value&quot; , 0.3 , timestamp : DateTime . utc_now ( ) ) Go: d.SendIndividualMessageWithTimestamp(&quot;org.astarte-platform.genericsensors.Values&quot;, &quot;/test0/value&quot;, 0.3, time.Now()) Java: genericSensorsValuesInterface.streamData(&quot;/test0/value&quot;, 0.3, DateTime.now()); Python: device.send(&quot;org.astarte-platform.genericsensors.Values&quot;, &quot;/test0/value&quot;, 0.3, timestamp=datetime.now()) Rust device.send_with_timestamp(&quot;org.astarte-platform.genericsensors.Values&quot;, &quot;/test0/value&quot;, 3, chrono::offset::Utc::now()).await?; Using Object Aggregated Interfaces In Astarte interfaces with object aggregation, Astarte expects the owner to send all of the interface's mappings at the same time, packed in a single message. In this case, all of the mappings share some core properties. Following examples show how to send a value for an object aggregated interface. In this examples, lat and long will be sent together and will be inserted into the &quot;/coords&quot; time series which is defined by &quot;/coords&quot; endpoint (that is part of &quot;com.example.GPS&quot; datastream interface). C (ESP32): astarte_bson_serializer_init(&amp;bs); astarte_bson_serializer_append_double(&amp;bs, &quot;lat&quot;, 45.409627); astarte_bson_serializer_append_double(&amp;bs, &quot;long&quot;, 11.8765254); astarte_bson_serializer_append_end_of_document(&amp;bs); int size; const void *coord = astarte_bson_serializer_get_document(&amp;bs, &amp;size); struct timeval tv; gettimeofday(&amp;tv, NULL); uint64_t ts = tv-&gt;tv_sec * 1000 + tv-&gt;tv_usec / 1000; astarte_device_stream_aggregate_with_timestamp(device, &quot;com.example.GPS&quot;, &quot;/coords&quot;, coords, ts, 0); C++ (Qt5): QVariantHash coords; coords.insert(QStringLiteral(&quot;lat&quot;), 45.409627); coords.insert(QStringLiteral(&quot;long&quot;), 11.8765254); m_sdk-&gt;sendData(&quot;com.example.GPS&quot;, &quot;/coords&quot;, coords, QDateTime::currentDateTime()); Elixir: coords = %{ lat : 45.409627 , long : 11.8765254 } Device . send_datastream ( pid , &quot;com.example.GPS&quot; , &quot;/coords&quot; , coords , timestamp : DateTime . utc_now ( ) ) Go: coords := map[string]double{&quot;lat&quot;: 45.409627, &quot;long&quot;: 11.8765254} d.SendAggregateMessageWithTimestamp(&quot;com.example.GPS&quot;, &quot;/coords&quot;, coords, time.Now()) Java: Map&lt;String, Double&gt; coords = new HashMap&lt;String, Double&gt;() { { put(&quot;lat&quot;, 45.409627); put(&quot;long&quot;, 11.8765254); } }; exampleGPSInterface.streamData(&quot;/coords&quot;, coords, DateTime.now()); Python: coords = {'lat': 45.409627, 'long': 11.8765254} device.send_aggregate(&quot;com.example.GPS&quot;, &quot;/coords&quot;, coords, timestamp=datetime.now()) Rust: /// Coords must implement the Serializable trait let coords = Coords{lat: 45.409627, long: 11.8765254}; device.send_object_with_timestamp(&quot;com.example.GPS&quot;, &quot;/coords&quot;, coords, chrono::offset::Utc::now()).await?; Setting and Unsetting Properties properties represent a persistent, stateful, synchronized state with no concept of history or timestamping. From a programming point of view, setting and unsetting properties of device-owned interface is rather similar to sending messages on datastream interfaces. Following examples show how to send a value that will be inserted into the &quot;/sensor0/name&quot; property which is defined by &quot;/%{sensor_id}/name&quot; parametric endpoint (that is part of &quot;org.astarte-platform.genericsensors.AvailableSensors&quot; device-owned properties interface). C (ESP32): // set property (one function for each type) astarte_device_set_string_property(device, &quot;org.astarte-platform.genericsensors.AvailableSensors&quot;, &quot;/sensor0/name&quot;, &quot;foobar&quot;); // unset property astarte_device_unset_path(device, &quot;org.astarte-platform.genericsensors.AvailableSensors&quot;, &quot;/sensor0/name&quot;); C++ (Qt5): // set property (same as datastream) m_sdk-&gt;sendData(m_interface, m_path, value, QDateTime::currentDateTime()); // unset property m_sdk-&gt;sendUnset(m_interface, m_path); Elixir: # set property (same as datastream) Device . set_property ( pid , &quot;org.astarte-platform.genericsensors.AvailableSensors&quot; , &quot;/sensor0/name&quot; , &quot;foobar&quot; ) # unset property Device . unset_property ( pid , &quot;org.astarte-platform.genericsensors.AvailableSensors&quot; , &quot;/sensor0/name&quot; ) Go: // set property d.SetProperty(&quot;org.astarte-platform.genericsensors.AvailableSensors&quot;, &quot;/sensor0/name&quot;, &quot;foobar&quot;) // unset property d.UnsetProperty(&quot;org.astarte-platform.genericsensors.AvailableSensors&quot;, &quot;/sensor0/name&quot;) Java: // set property availableSensorsInterface.setProperty(&quot;/sensor0/name&quot;, &quot;foobar&quot;); // unset property propertyInterface.unsetProperty(&quot;/sensor0/name&quot;); Python: # set property (same as datastream) device.send(&quot;org.astarte-platform.genericsensors.AvailableSensors&quot;, &quot;/sensor0/name&quot;, &quot;foobar&quot;) # unset property device.unset_property(&quot;org.astarte-platform.genericsensors.AvailableSensors&quot;, &quot;/sensor0/name&quot;) Rust: /// set property (same as datastream) device.send(&quot;org.astarte-platform.genericsensors.AvailableSensors&quot;, &quot;/sensor0/name&quot;, &quot;foobar&quot;); /// unset property device.unset(&quot;org.astarte-platform.genericsensors.AvailableSensors&quot;, &quot;/sensor0/name&quot;);","ref":"041-astarte_device_sdks.html#streaming-data","title":"Astarte Device SDKs - Streaming data","type":"extras"},{"doc":"Device errors This page details the errors that can affect a device while it's sending data. The user can monitor device errors by installing a device trigger on device_error or checking the Devices tab in the Astarte Dashboard. The same errors are also provided as log messages on Data Updater Plant.","ref":"045-device_errors.html","title":"Device errors","type":"extras"},{"doc":"The device is trying to write on a server owned interface. The device can only push data on device owned interfaces.","ref":"045-device_errors.html#write_on_server_owned_interface","title":"Device errors - write_on_server_owned_interface","type":"extras"},{"doc":"The interface name received in the message is invalid.","ref":"045-device_errors.html#invalid_interface","title":"Device errors - invalid_interface","type":"extras"},{"doc":"The path received in the message is invalid. This might happen when a path does not have a valid path format or it's not a valid UTF-8 string.","ref":"045-device_errors.html#invalid_path","title":"Device errors - invalid_path","type":"extras"},{"doc":"The path received in the message can't be found in the interface mappings. This could be the result of the device having a more recent version of the inteface than the one installed in the realm or an interface with the same name and version but different contents.","ref":"045-device_errors.html#mapping_not_found","title":"Device errors - mapping_not_found","type":"extras"},{"doc":"The target interface was not found in the database. Usually this means the interface is not installed in the realm, but the error can also derive from the database being temporarily unavailable.","ref":"045-device_errors.html#interface_loading_failed","title":"Device errors - interface_loading_failed","type":"extras"},{"doc":"The path received in the message can't be mapped univocally on a mapping. This is often the result of an incomplete path.","ref":"045-device_errors.html#ambiguous_path","title":"Device errors - ambiguous_path","type":"extras"},{"doc":"The payload of the message can't be decoded as BSON.","ref":"045-device_errors.html#undecodable_bson_payload","title":"Device errors - undecodable_bson_payload","type":"extras"},{"doc":"The value of the message does not have the expected type ( e.g. the mapping expects a string value but an integer value was received instead).","ref":"045-device_errors.html#unexpected_value_type","title":"Device errors - unexpected_value_type","type":"extras"},{"doc":"The value of the message exceeds the maximum size of its type. The size limitations of the types are documented here .","ref":"045-device_errors.html#value_size_exceeded","title":"Device errors - value_size_exceeded","type":"extras"},{"doc":"An object aggregated value with an unexpected key was received.","ref":"045-device_errors.html#unexpected_object_key","title":"Device errors - unexpected_object_key","type":"extras"},{"doc":"The introspection sent from the device can't be parsed correctly. The introspection format is documented here .","ref":"045-device_errors.html#invalid_introspection","title":"Device errors - invalid_introspection","type":"extras"},{"doc":"The device sent a message on an unhandled control path. The supported control paths are detailed in the protocol documentation .","ref":"045-device_errors.html#unexpected_control_message","title":"Device errors - unexpected_control_message","type":"extras"},{"doc":"Data Updater Plant failed to push data towards the device. This could result from the device being currently offline and not having a persistent session on the MQTT broker or from the device not having all the MQTT subscriptions required by the Astarte protocol","ref":"045-device_errors.html#device_session_not_found","title":"Device errors - device_session_not_found","type":"extras"},{"doc":"Data Updater Plant failed to resend the properties of an interface. This could result from the device declaring a uninstalled properties interface in its introspection right before an emptyCache.","ref":"045-device_errors.html#resend_interface_properties_failed","title":"Device errors - resend_interface_properties_failed","type":"extras"},{"doc":"The empty cache operation for a device failed. This could result from a temporary database failure.","ref":"045-device_errors.html#empty_cache_error","title":"Device errors - empty_cache_error","type":"extras"},{"doc":"Querying a Device Once you have your devices connected, up and running in Astarte, you can start interacting with them.","ref":"050-query_device.html","title":"Querying a Device","type":"extras"},{"doc":"First things first, you can check if your device is correctly registered in Astarte, and its current status. Let's assume our Device has f0VMRgIBAQAAAAAAAAAAAA as its id. A Device's status includes a number of useful information, among which whether it is connected or not to its Transport, its introspection, the amount of exchanged data and more. Query Device status using astartectl $ astartectl appengine devices show f0VMRgIBAQAAAAAAAAAAAA Device ID: f0VMRgIBAQAAAAAAAAAAAA Connected: false Last Connection: 2018-02-07 18:38:57.266 +0000 UTC Last Disconnection: 2018-02-08 09:49:26.566 +0000 UTC Introspection: com.example.ExampleInterface v1.0 exchanged messages: 20 exchanged bytes: 200B org.example.TestInterface v0.2 exchanged messages: 8 exchanged bytes: 147B Received Messages: 221 Data Received: 11.7K Last Seen IP: 203.0.113.89 Last Credentials Request IP: 203.0.113.201 First Registration: 2018-01-31 17:10:59.270 +0000 UTC First Credentials Request: 2018-01-31 17:10:59.270 +0000 UTC Query Device status using Astarte Dashboard After logging in to Astarte dashboard, go to the &quot;Devices&quot; page clicking on the menu on your left. A list of available Device IDs will appear. If you do not see your device at a glance, use the search bar on the top right to find it. Clicking on the Device ID will take you to its details page. Query Device status using AppEngine API GET api.&lt;your astarte domain&gt;/appengine/v1/test/devices/f0VMRgIBAQAAAAAAAAAAAA { &quot;data&quot;: { &quot;total_received_msgs&quot;: 221, &quot;total_received_bytes&quot;: 11660, &quot;last_seen_ip&quot;: &quot;203.0.113.89&quot;, &quot;last_credentials_request_ip&quot;: &quot;203.0.113.201&quot;, &quot;last_disconnection&quot;: &quot;2018-02-07T18:38:57.266Z&quot;, &quot;last_connection&quot;: &quot;2018-02-08T09:49:26.556Z&quot;, &quot;id&quot;: &quot;f0VMRgIBAQAAAAAAAAAAAA&quot;, &quot;first_registration&quot;: &quot;2018-01-31T17:10:59.270Z&quot;, &quot;connected&quot;: true, &quot;introspection&quot;: { &quot;com.example.ExampleInterface&quot; : { &quot;major&quot; : 1, &quot;minor&quot; : 0, &quot;exchanged_msgs&quot;: 20, &quot;exchanged_bytes&quot;: 200 }, &quot;org.example.TestInterface&quot; : { &quot;major&quot; : 0, &quot;minor&quot; : 2, &quot;exchanged_msgs&quot;: 8, &quot;exchanged_bytes&quot;: 147 } }, &quot;aliases&quot;: { &quot;name&quot;: &quot;device_a&quot; }, &quot;attributes&quot;: { &quot;attributes_key&quot;: &quot;attributes_value&quot; }, &quot;groups&quot;: [ &quot;my_group&quot;, ], &quot;previous_interfaces&quot;: [ { &quot;name&quot;: &quot;com.example.ExampleInterface&quot;, &quot;major&quot; : 0, &quot;minor&quot; : 2, &quot;exchanged_msgs&quot;: 3, &quot;exchanged_bytes&quot;: 120 } ] } } Through the API, it is also possible to get the Introspection of the device only: GET api.&lt;your astarte domain&gt;/appengine/v1/test/devices/f0VMRgIBAQAAAAAAAAAAAA/interfaces { &quot;data&quot;: [ &quot;com.example.ExampleInterface&quot;, &quot;com.example.TestInterface&quot; ] } This returns the Interfaces which the device reported in its Introspection and which are known to the Realm. Arbitrary information can be added to the device by means of attributes : they allow to store any number of string values associated to a corresponding string key. To set, modify and delete attributes , a PATCH on the device endpoint is required: PATCH api . &lt; your astarte domain &gt; / appengine / v1 / test / devices / f0VMRgIBAQAAAAAAAAAAAA In the request body, the data JSON object should have a attributes key which bears a dictionary of strings. A valid request body which changes only device attributes, for example, is {&quot;data&quot;:{&quot;attributes&quot;: {&quot;&lt;key&gt;&quot;: &quot;&lt;value&gt;&quot;}}} . To delete an attribute entry, set the value of the corresponding key to null . For example, POSTing {&quot;data&quot;:{&quot;attributes&quot;: {&quot;my_key&quot;: null}}} will remove the my_key attribute entry from the device. Depending on the aggregation and ownership of the Interface, you can GET / PUT / POST on the interface itself or one of its mappings, or use astartectl to perform the same operation on the command line. Some examples are: Get data from an aggregate device properties interface astartectl invocation: astartectl appengine devices data-snapshot f0VMRgIBAQAAAAAAAAAAAA com.example.ExampleInterface AppEngine API invocation: GET api.&lt;your astarte domain&gt;/appengine/v1/test/devices/f0VMRgIBAQAAAAAAAAAAAA/interfaces/com.example.ExampleInterface Get last sent value from an individual device datastream interface astartectl invocation: astartectl appengine devices data-snapshot f0VMRgIBAQAAAAAAAAAAAA com.example.TestInterface AppEngine API invocation: GET api.&lt;your astarte domain&gt;/appengine/v1/test/devices/f0VMRgIBAQAAAAAAAAAAAA/interfaces/com.example.TestInterface/myValue?limit=1 Set values in an individual server datastream interface astartectl invocation: astartectl appengine devices send-data f0VMRgIBAQAAAAAAAAAAAA com.example.OtherTestInterface /myOtherValue &lt;value&gt; AppEngine API invocation: POST api.&lt;your astarte domain&gt;/appengine/v1/test/devices/f0VMRgIBAQAAAAAAAAAAAA/interfaces/com.example.OtherTestInterface/myOtherValue Request body: {&quot;data&quot;: &lt;value&gt;} API Query semantics In general, to query AppEngine, the following things must be kept in mind When sending data, use PUT if dealing with properties , POST if dealing with datastream . When GET ting, if you are querying an aggregate interface, make sure to query the interface itself rather than its mappings. When GET ting datastream , keep in mind that AppEngine's default behavior is to return a large as possible timeseries.","ref":"050-query_device.html#device-status","title":"Querying a Device - Device status","type":"extras"},{"doc":"The Datastream case is significant, as it might be common to have a lot of values for each endpoint/interface. As such, returning all of them in a single API call is most of the times not desirable nor recommended. To avoid putting the cluster under excessive pressure, AppEngine API is configured with a hard cap on the maximum number of returned results for each single call, with a sane default of 10000 . Although this hard cap is entirely configurable, please be aware that AppEngine API is designed to process a lot of reasonably small requests in the shortest possible time, and hence is not optimised nor strongly tested against big requests . Make sure that AppEngine API has enough resources available to cope with the maximum dataset size. AppEngine API provides you with a variety of mechanisms to make retrieval and navigation of large data sets as smooth and efficient as possible. Limit Adding a limit=n to the URL query tells AppEngine to return no more than n results. This acts similarly to a LIMIT SQL statement, but, as it stands, it does not impose a hard limit on the whole retrieved dataset but on the amount of the results displayed by the API call - see Pagination and Time Windows for more details on this topic and the performance implications of different limits in queries. If the specified limit is beyond the hard cap, the query won't fail, but will return at most the amount set by the hard cap, without further warnings. Since/To/Since After Results can be limited to a specific time window. since and to can be set to a ISO 8601 valid timestamp to limit on an upper and lower bound the result set. This can also be combined with limit to make sure that no more than n results are returned. Also, since and to can as well be set independently to provide only an upper or lower bound. In case you're dealing with a very large dataset and you want to dump it, it is likely that you need to go beyond what a reasonable default limit looks like. In those cases, you can use the since_after query parameter to retrieve parameters within a time window. since_after slices the time window just like since does, but it does not include values matching the specified timestamp, if any. This is especially useful when paginating, to start right after a returned result. Pagination and time windows AppEngine API provides you automatically with a time window-based pagination. When GET ting a datastream , if more results are available beyond the chosen time window/limit, a links map will be provided, in JSON-API style, to allow the user to paginate the results accordingly using since_after . You can use limit to determine each page's size. When specifying a valid limit , the links will keep the page size consistent over the next calls. However, limit should be used wisely to lower the pressure on the cluster. Each API call maps to a query that, no matter how efficient, has a computational cost. A few mid-sized queries should always be preferred over a large amount of smaller queries. Given your cluster is configured correctly, limit should be omitted in most cases when paginating, and you should rather trust your cluster's hard cap to be the sweet spot in efficiency and cluster pressure. Downsampling Especially when plotting graphs, retrieving all points in a time series isn't desirable. Astarte provides you with an implementation of the LTTB Downsampling Algorithm , which is used to return only a fixed number of samples from a time series. When setting downsample_to=n , AppEngine will return a maximum of n results, which are the most significant over the considered time series according to the algorithm. Due to how LTTB works, downsample_to must be &gt;2 , as the algorithm will return the two ends of the considered value bucket, and n-2 values which are the picked samples. Please refer to the LTTB implementation used by Astarte to learn more about how this algorithm affects samples and its limitations. downsample_to=x can be used in conjunction with other query parameters, including limit=y . When doing so, Astarte will downsample to x samples the dataset composed of the last y values. Every feature previously outlined is in fact available with downsampling, including pagination - bear in mind, though, that for how the algorithm works, some options have drastically different semantic effects. Also, the hard cap has a very different meaning in downsampling. In this case, the hard cap applies to downsample_to instead of limit . limit can be an arbitrarly large amount of samples taken out of the DB, and can be used mainly to alleviate pressure in case of extremely large datasets which would require a lot of time for being processed by LTTB - even though, most of the time, you might want to define a time window to downsample instead. Astarte is also capable of downsampling aggregated interfaces, as long as a downsample_key is specified, which has to match the last token of an endpoint of the queried interface (i.e. in case the interface has a /%{id}/myValue mapping which should be used as the downsample_key , you should specify downsample_key=myValue in the query). When doing so, the aggregate will be downsampled using the chosen endpoint value as the y axis value, whereas its other endpoints will be disregarded when applying the algorithm. Please note that, no matter what downsample_key is used, a sample will be composed by the whole aggregation. If there is no way an interface can be downsampled (this is true, for example, if no downsample_key has been specified for aggregations , or for types such as strings ), AppEngine API will return a 4xx error. In general, downsampling is a powerful mechanism with a lot of limitations which really shines when plotting. Once again, this is a fundamental factor to consider when designing your interfaces .","ref":"050-query_device.html#navigating-and-retrieving-datastream-results-through-apis","title":"Querying a Device - Navigating and retrieving Datastream results through APIs","type":"extras"},{"doc":"The http REST API returns a static result, therefore API clients should either poll the REST API when displaying real-time changes or use a WebSocket. WebSockets are called Astarte Channels in Astarte jargon, and they should be considered as a more efficient alternative to polling. When using Astarte Channels the REST API should be used to retrieve the initial status.","ref":"050-query_device.html#real-time-updates","title":"Querying a Device - Real-Time Updates","type":"extras"},{"doc":"astartectl implements some convenience methods that make navigation easier. In particular, astartectl allows for any of the AppEngine API query parameters/mechanisms, but also implements automated pagination, snapshots and more. Data Snapshot astartectl has a unique feature that allows to retrieve a &quot;Data Snapshot&quot; of a device, namely the last known value for every interface available in the Device's introspection. This is extremely useful to have an at-a-glance view of the Device status with regards to data. Simply invoke astartectl appengine devices data-snapshot &lt;device ID&gt; , or astartectl appengine devices data-snapshot &lt;device ID&gt; &lt;interface name&gt; to get a snapshot for a single interface. Advanced querying astartectl appengine devices get-samples is astartectl 's frontend to advanced query. Refer to the command line documentation to learn about all available parameters, which match all of the parameters found in AppEngine API. The main difference is that, in case a query would break the boundaries of the page limit, astartectl will automatically paginate the request, and return all of the samples. Exporting Devices Data with astartectl The previous feature makes astartectl extremely useful when it comes to export or dump data. Moreover, get-samples features a --output option, which allows to print the results in different formats, such as json or CSV . This way, exporting values becomes extremely easy, as get-samples can easily tap into an Interface's entire data set and print it into a CSV file.","ref":"050-query_device.html#astartectl-specific-features","title":"Querying a Device - astartectl-specific features","type":"extras"},{"doc":"Using Astarte Channels (WebSockets) Especially when building Frontend applications, it is useful to receive real-time updates about data sent from Devices. Astarte leverages Phoenix Channels to provide such a thing over WebSockets in AppEngine API. WebSockets can be used natively from a Web Browser and follow the same authentication pattern as a standard HTTP call. Astarte Channels define a semantic on top of Phoenix Channels which allows read-only monitoring of device Interfaces. Authentication and Authorization over Channels happens in the very same way as AppEngine , and the a_ch claim in the token is respected when joining rooms and installing triggers. See Authentication and Authorization for more details on Auth semantics in Astarte.","ref":"052-using_channels.html","title":"Using Astarte Channels (WebSockets)","type":"extras"},{"doc":"Rooms in Astarte Channels map 1:1 to Topics in Phoenix Channels, and can be joined in the very same way. Once a connection is established, the user can join any number of rooms, given he is authorized to do so . A Room is identified by a topic with the following semantics: rooms:&lt;realm&gt;:&lt;name&gt; . For example, rooms:test:myroom will join the Room myroom in the Realm test . A room can be joined by any number of concurrent users. Rooms serve as containers for Transient Triggers, which can be installed by any authorized user. Transient Triggers are actual Triggers , with the difference that they exist within a Channels Room rather than within a Realm - this mostly affects their timespan - and that the action can't be configured - every time a Condition is triggered an event is delivered to users in the Room. Events Everytime a Condition of an installed Trigger is triggered, an event is sent to the Phoenix Channel, with a similar payload: { &quot;device_id&quot;: &quot;f0VMRgIBAQAAAAAAAAAAAA&quot;, &quot;event&quot;: { &quot;type&quot;: &quot;device_connected&quot;, &quot;device_ip_address&quot;: &quot;1.2.3.4&quot; } } device_id is always present (as long as the trigger matches a device) and identifies the device emitting the event. event , instead, depends on the kind of installed trigger. It always carries a type string, which identifies the content of the object. The complete list of possible event payloads can be found here . Lifecycle Once a room is created, it remains valid and active with all of its subscriptions. There's little overhead in having a large number of rooms, as the only components leeching resources are Transient Triggers. As of today, Transient Triggers never expire - it is responsibility of the user to clean them up once the room becomes empty, if needed. In future versions, Transient Triggers will likely expire after some time, if left in an empty room.","ref":"052-using_channels.html#rooms","title":"Using Astarte Channels (WebSockets) - Rooms","type":"extras"},{"doc":"To install a Transient Trigger, one should issue a watch event in the Channel, given he is authorized to do so. The payload of such an event is identical to a Trigger definition, hence it looks like this: { &quot;name&quot;: &quot;datatrigger&quot;, &quot;device_id&quot;: &quot;f0VMRgIBAQAAAAAAAAAAAA&quot;, &quot;simple_trigger&quot;: { &quot;type&quot;: &quot;data_trigger&quot;, &quot;on&quot;: &quot;incoming_data&quot;, &quot;interface_name&quot;: &quot;org.astarte-platform.genericsensors.Values&quot;, &quot;interface_major&quot;: 0, &quot;match_path&quot;: &quot;/streamTest/value&quot;, &quot;value_match_operator&quot;: &quot;&gt;&quot;, &quot;known_value&quot;: 0.6 } } This installs in the Room a Transient Trigger which will trigger an event everytime a value higher than 0.6 is sent on the path /streamTest/value of the datastream interface org.astarte-platform.genericsensors.Values by the device f0VMRgIBAQAAAAAAAAAAAA , and will be received by every user currently in the room. If a user isn't in the room at the time of the event, he will not get it, and there's no way he can retrieve it if he joined at a later time. Triggers can be uninstalled by issuing an unwatch event in the Channel. The payload of the event should be the name of the trigger which should be uninstalled. Group Triggers Transient triggers can also target an Astarte group instead of a single device. To install a group volatile trigger, pass the group_name key in the JSON payload instead of the device_id key. For example, the trigger below is equivalent to the one in the previous section, but it targets all devices that are in the group mygroup . { &quot;name&quot;: &quot;groupdevicetrigger&quot;, &quot;group_name&quot;: &quot;mygroup&quot;, &quot;simple_trigger&quot;: { &quot;type&quot;: &quot;data_trigger&quot;, &quot;on&quot;: &quot;incoming_data&quot;, &quot;interface_name&quot;: &quot;org.astarte-platform.genericsensors.Values&quot;, &quot;interface_major&quot;: 0, &quot;match_path&quot;: &quot;/streamTest/value&quot;, &quot;value_match_operator&quot;: &quot;&gt;&quot;, &quot;known_value&quot;: 0.6 } } Note that the devices belonging to the group are evaluated when the trigger is installed, i.e. if a device is added to the group when the trigger is already installed, the trigger will not target the newly added device. The same goes for devices removed from the group, that will still be targeted by the trigger until it is removed.","ref":"052-using_channels.html#managing-transient-triggers","title":"Using Astarte Channels (WebSockets) - Managing Transient Triggers","type":"extras"},{"doc":"Just like any other Astarte component, Authorization is encapsulated in a token claim, in particular the a_ch claim. However, the mechanism is rather different compared to a REST API, and uses different verbs. JOIN The JOIN verb implies that a user can join a room. This only allows him to receive events and to interact in a read-only fashion with the room itself. There is no restriction to which events a user sees - if he is authorized to enter in a room, he will be capable of seeing all events flowing in. More granular permissions can be done simply by creating more rooms in which different triggers will be installed. The JOIN verb has the following semantic: JOIN::&lt;regex&gt; , where regex matches a room name (the room name is what follows rooms:&lt;realm&gt;: - the realm is implicit in the context of the authorization token). For example, a user authorized with the JOIN::test.* claim in the test realm will be able to join, for example, rooms:test:testthis , rooms:test:testme , rooms:test:test . The realm is always implicit in the regex, as the token is authenticated in the context of a Realm. WATCH The WATCH verb allows a user to install a Trigger within a room. Its semantics define which kind of trigger, and upon which entities the user is allowed to act. Watch semantics are WATCH::&lt;regex&gt; , where regex is a regular expression which matches a device, path or interface (or a mixture of them) in almost very same fashion as the a_aea claim (which is used in AppEngine). Given different kind of triggers impact different Astarte entities, the Authorization claim implicitly defines which kind of triggers a user will be able to install. For example, f0VMRgIBAQAAAAAAAAAAAA/org.astarte-platform.genericsensors.Values.* will allow installing data triggers such as the one shown in the previous example, but won't let the user install device-wide triggers (such as connect/disconnect events). A claim such as f0VMRgIBAQAAAAAAAAAAAA or f0VMRgIBAQAAAAAAAAAAAA.* , instead, will allow device-level triggers to be installed.","ref":"052-using_channels.html#authorization","title":"Using Astarte Channels (WebSockets) - Authorization","type":"extras"},{"doc":"Using Triggers Triggers allow receiving notifications when a device connects, disconnects or publishes specific data. More details on Triggers can be found in the Architecture Documentation . Astarte allows you to install and delete Triggers dynamically through its clients. Upon installation or deletion, changes to the Trigger infrastructure might take some time to propagate, and some devices might pick up changes at a later time. If a Trigger shows as installed, it will eventually be loaded. This propagation can take up to 10 minutes.","ref":"060-using_triggers.html","title":"Using Triggers","type":"extras"},{"doc":"At any time, you can list existing Triggers in a Realm and fetch their details and definitions. Listing and querying Triggers using Astarte Dashboard After logging in, navigate to the Triggers page using the menu on the left. The list of Triggers installed in the Realm will be shown in the page. Clicking on a Trigger will open the Trigger editor in view-only mode, showing its definition on the right panel. Listing and querying Triggers using astartectl To list all existing Triggers in a Realm: $ astartectl realm-management triggers list [my_trigger other_trigger my_connection_trigger my_data_trigger] To get a Trigger definition: $ astartectl realm-management triggers show my_connection_trigger { &quot;name&quot;: &quot;my_connection_trigger&quot;, &quot;action&quot;: { &quot;http_url&quot;: &quot;&lt;url&gt;&quot;, &quot;http_method&quot;: &quot;&lt;method&gt;&quot; }, &quot;simple_triggers&quot;: [ { &quot;type&quot;: &quot;device_trigger&quot;, &quot;device_id&quot;: &quot;*&quot;, &quot;on&quot;: &quot;device_connected&quot; } ] } Listing and querying Triggers using Realm Management API To list all existing Triggers in a Realm: GET api.&lt;astarte base URL&gt;/realmmanagement/v1/&lt;realm name&gt;/triggers { &quot;data&quot;: [ &quot;my_trigger&quot;, &quot;other_trigger&quot;, &quot;my_connection_trigger&quot;, &quot;my_data_trigger&quot; ] } To get a Trigger definition: GET api.&lt;astarte base URL&gt;/realmmanagement/v1/&lt;realm name&gt;/triggers/my_connection_trigger { &quot;data&quot;: { &quot;name&quot;: &quot;my_connection_trigger&quot;, &quot;action&quot;: { &quot;http_url&quot;: &quot;&lt;url&gt;&quot;, &quot;http_method&quot;: &quot;&lt;method&gt;&quot; }, &quot;simple_triggers&quot;: [ { &quot;type&quot;: &quot;device_trigger&quot;, &quot;device_id&quot;: &quot;*&quot;, &quot;on&quot;: &quot;device_connected&quot; } ] } }","ref":"060-using_triggers.html#listing-triggers","title":"Using Triggers - Listing Triggers","type":"extras"},{"doc":"To install a Trigger, you need its JSON definition. If you have access to the Astarte Dashboard, you can use its Trigger Editor to build your JSON definition and install the Trigger directly. If you already have a JSON definition instead, you can either use astartectl or Realm Management APIs. The name of the Trigger must be unique within the Realm, or an error will be returned. Installing a Trigger using Astarte Dashboard After logging in, navigate to the Triggers page using the menu on the left. Click on &quot;Install a new Trigger...&quot; in the top-right corner. The Trigger Editor will open, and you can either paste/write a JSON definition, or use the declarative editor. When you are done, click on the &quot;Install Trigger&quot; button at the bottom of the declarative editor to install the Trigger in the Realm. Installing a Trigger using astartectl Assuming the Trigger definition is contained in my_connection_trigger.json , $ astartectl realm-management triggers install my_connection_trigger.json ok Installing a Trigger using Realm Management APIs POST api.&lt;astarte base URL&gt;/realmmanagement/v1/&lt;realm name&gt;/triggers The POST request must have the following request body, with content type application/json { &quot;data&quot;: { &quot;name&quot;: &quot;my_connection_trigger&quot;, &quot;action&quot;: { &quot;http_url&quot;: &quot;&lt;url&gt;&quot;, &quot;http_method&quot;: &quot;&lt;method&gt;&quot; }, &quot;simple_triggers&quot;: [ { &quot;type&quot;: &quot;device_trigger&quot;, &quot;device_id&quot;: &quot;*&quot;, &quot;on&quot;: &quot;device_connected&quot; } ] } }","ref":"060-using_triggers.html#installing-a-trigger","title":"Using Triggers - Installing a Trigger","type":"extras"},{"doc":"To delete a Trigger, you need to know its name. Just like when installing a Trigger, deleting a Trigger might not stop the data flow out of the Trigger immediately, which will eventually terminate at some point. Deleting a Trigger using Astarte Dashboard After logging in, navigate to the Triggers page using the menu on the left. Click on &quot;Install a new Trigger...&quot; in the top-right corner. Click on the Trigger name you want to delete. The Trigger Editor will open, and a &quot;Delete&quot; button will become available next to the Trigger name. Click on it to delete the Trigger. Deleting a Trigger using astartectl $ astartectl realm-management triggers delete my_connection_trigger ok Deleting a Trigger using Realm Management APIs DELETE api.&lt;astarte base URL&gt;/realmmanagement/v1/&lt;realm name&gt;/triggers/my_connection_trigger","ref":"060-using_triggers.html#deleting-a-trigger","title":"Using Triggers - Deleting a Trigger","type":"extras"},{"doc":"This section outlines two examples for the two main Trigger types (connection and data), and a sample payload for its HTTP Post URL action. Connection Trigger This trigger will send a POST request to &lt;url&gt; every time any device connects to its transport. This is the JSON representation of the trigger: { &quot;name&quot;: &quot;my_connection_trigger&quot;, &quot;action&quot;: { &quot;http_url&quot;: &quot;&lt;url&gt;&quot;, &quot;http_method&quot;: &quot;post&quot; }, &quot;simple_triggers&quot;: [ { &quot;type&quot;: &quot;device_trigger&quot;, &quot;device_id&quot;: &quot;*&quot;, &quot;on&quot;: &quot;device_connected&quot; } ] } If the Trigger is installed, when a device connects, &lt;url&gt; will receive the following JSON payload: { &quot;timestamp&quot;: &quot;&lt;timestamp&gt;&quot;, &quot;device_id&quot;: &quot;&lt;device_id&gt;&quot;, &quot;event&quot;: { &quot;type&quot;: &quot;device_connected&quot;, &quot;device_ip_address&quot;: &quot;&lt;device_ip_address&gt;&quot; } } Data Trigger This trigger will send a POST request to http://www.example.com/hook every time a device sends data to the org.astarte-platform.genericsensors.Values major version 0 interface on the /streamTest/value path. This is the JSON representation of the trigger { &quot;name&quot;: &quot;my_data_trigger&quot;, &quot;action&quot;: { &quot;http_url&quot;: &quot;http://www.example.com/hook&quot;, &quot;http_method&quot;: &quot;post&quot; }, &quot;simple_triggers&quot;: [ { &quot;type&quot;: &quot;data_trigger&quot;, &quot;on&quot;: &quot;incoming_data&quot;, &quot;interface_name&quot;: &quot;org.astarte-platform.genericsensors.Values&quot;, &quot;interface_major&quot;: 0, &quot;match_path&quot;: &quot;/streamTest/value&quot;, &quot;value_match_operator&quot;: &quot;*&quot; } ] } If the Trigger is installed, when a device sends data to the interface/path defined above, &lt;url&gt; will receive the following JSON payload: { &quot;timestamp&quot;: &quot;&lt;timestamp&gt;&quot;, &quot;device_id&quot;: &quot;&lt;device_id&gt;&quot;, &quot;event&quot;: { &quot;type&quot;: &quot;incoming_data&quot;, &quot;interface&quot;: &quot;org.astarte-platform.genericsensors.Values&quot;, &quot;path&quot;: &quot;/streamTest/value&quot;, &quot;value&quot;: &lt;value&gt; } }","ref":"060-using_triggers.html#trigger-examples","title":"Using Triggers - Trigger examples","type":"extras"},{"doc":"Both device and data triggers accept the device_id and group_name keys to restrict a trigger to a single device or a single group. Triggers containing the device_id key will be triggered only for the specified device, while triggers containing the group_name key will be triggered only if the device is member of the group that is indicated in the group_name key. Note that when devices in a group are added or removed, the changes are not reflected immediately in group triggers. It can take up to 10 minutes to see the propagation of said changes.","ref":"060-using_triggers.html#restricting-triggers-to-a-single-device-or-group","title":"Using Triggers - Restricting triggers to a single device or group","type":"extras"},{"doc":"Managing Groups Devices can be divided in groups to provide group-specific access to the APIs. The examples below will use astartectl but you can achieve the same results using AppEngine API.","ref":"065-managing-groups.html","title":"Managing Groups","type":"extras"},{"doc":"Some prefixes are reserved for internal use. It's not possible to create groups with a name starting with the ~ and @ characters.","ref":"065-managing-groups.html#reserved-group-prefixes","title":"Managing Groups - Reserved group prefixes","type":"extras"},{"doc":"You can create a group with astartectl with this command astartectl appengine groups create mygroup &lt;device_identifier&gt;,&lt;device_identifier&gt; device_identifier can be a Device ID or an Alias, and you can put multiple devices by separating them with a comma. You can check the group was created by listing groups in your realm astartectl appengine groups list","ref":"065-managing-groups.html#creating-a-group","title":"Managing Groups - Creating a group","type":"extras"},{"doc":"Once you created a group, you can add or remove devices from it. To add a device, use: astartectl appengine groups devices add &lt;device_identifier&gt; To remove a device, use: astartectl appengine groups devices remove &lt;device_identifier&gt; Keep in mind that a group exists as long as it has at least one device in it, so if you remove the last device from a group, the group will cease to exist. You can always check which devices are in a group with: astartectl appengine groups devices list","ref":"065-managing-groups.html#adding-or-removing-a-device-to-from-a-group","title":"Managing Groups - Adding or removing a device to/from a group","type":"extras"},{"doc":"Once a device is in a group, you can access to its data on this URL: https://&lt;astarte-api&gt;/appengine/v1/groups/&lt;group_name&gt;/devices/&lt;device_id&gt; The hierarchy is exactly the same that is found under https://&lt;astarte-api&gt;/appengine/v1/devices/&lt;device-id&gt; which is documented here , but this makes it possible to emit a JWT that only allows access to devices belonging to a specific group.","ref":"065-managing-groups.html#accessing-devices-in-a-group-with-astarte-appengine-api","title":"Managing Groups - Accessing Devices in a group with Astarte AppEngine API","type":"extras"},{"doc":"Connect 3rd party applications","ref":"070-connect_application.html","title":"Connect 3rd party applications","type":"extras"},{"doc":"Astarte Datasource Plugin for Grafana Astarte Datasource Plugin conveys data from Astarte to Grafana , the open-source platform for monitoring and observability, developed by Grafana Labs . Actual data visualisation is provided by Grafana via its plugins . You can browse the source code of this plugin on its GitHub repository .","ref":"080-grafana_datasource.html","title":"Astarte Datasource Plugin for Grafana","type":"extras"},{"doc":"When deploying locally using docker-compose as mentioned in the Astarte in 5 mins tutorial , Astarte Datasource Plugin will be automatically installed. You may then access Grafana by visiting http://localhost:3000. When first logging into Grafana, you will be prompted to change default credentials user admin , password: admin . Configure the datasource In order to get data from Astarte, you will need to create a new datasource referring to your own Astarte instance. You will need to provide Astarte API URLs, the realm name and Astarte AppEngine token. Save the configuration by clicking on Save &amp; Test","ref":"080-grafana_datasource.html#try-it","title":"Astarte Datasource Plugin for Grafana - Try it!","type":"extras"},{"doc":"After successfully configuring your datasources, you will be able to select them as a source for your graph as depicted below. You will then be able to choose which device and interface data should be retrieved from.","ref":"080-grafana_datasource.html#setting-up-a-graph","title":"Astarte Datasource Plugin for Grafana - Setting up a graph","type":"extras"},{"doc":"Grafana offers data-aggregation features, for more information check the official Grafana documentation","ref":"080-grafana_datasource.html#data-manipulation","title":"Astarte Datasource Plugin for Grafana - Data manipulation","type":"extras"},{"doc":"Troubleshooting Be sure to check known issues to see if your problem is already covered there.","ref":"090-troubleshooting.html","title":"Troubleshooting","type":"extras"},{"doc":"Devices cannot connect to Astarte There might be some network issues or network misconfiguration Devices need a working network connection in order to communicate with Astarte. There might be some temporary network issues, or any network setting or appliance might not be properly configured. Make sure that devices are allowed to make outbound connections on ports 443 (https) and any port the transport needs for accepting connections from devices. For Astarte/VerneMQ, this defaults to 8883 (MQTT over SSL), but might also be configured otherwise. SSL issues Devices need to be able to connect to Astarte using SSL. Make sure that the clock has been synched to avoid certificate issue/expiry date errors, make also sure to have all the root CAs up to date. Device gets disconnected from Astarte Some interfaces might be missing When a device reports an interface that Astarte doesn't have, it gets disconnected when the introspection is published. Make sure that all device interfaces have been previously installed on Astarte. Make also sure that interface name and major exactly matches installed version. Device is publishing unexpected or malformed data When a device sends invalid, malformed or unexpected data it gets disconnected, make sure that the device is sending valid data. An interface mismatch might be the most common reason for this kind of issues. e.g. the interface has been declared device owned on the device, and astarte owned on astarte. Make sure to use exactly the same JSON file on both ends.","ref":"090-troubleshooting.html#devices","title":"Troubleshooting - Devices","type":"extras"},{"doc":"Triggers are not executed Triggers have not been loaded yet Triggers might take some time before being loaded for devices that have been recently connected, make sure to wait some time before the triggers cache is populated again. If you are on a hurry make sure to test a trigger on a device that has not been recently connected yet.","ref":"090-troubleshooting.html#triggers","title":"Troubleshooting - Triggers","type":"extras"},{"doc":"Known issues This page collects some notable issues which affect Astarte v1.0 . This is by no means an exhaustive list and you should also check Github issues to see if your problem is already covered there.","ref":"095-known_issues.html","title":"Known issues","type":"extras"},{"doc":"Astarte v1.0 introduces the possibility of deleting a Realm, but currently devices which have a valid certificate are not disconnected from the Realm. The issue is tracked here . Since publishing with devices on unexisting realms can cause problems (namely: RabbitMQ data queues filling up) which can also impact devices on other realms, a realm should be deleted only after ensuring that no devices are connected to it. Due to the problems that realm deletion can cause, currently the feature must be explicitly enabled with a feature gate, i.e. by adding features: realmDeletion: true components: ... to the Astarte Custom Resource (which maps to setting the HOUSEKEEPING_ENABLE_REALM_DELETION environment variable to true in the astarte_housekeeping container). We also encourage avoiding to recreate realms with the same name to avoid having devices from the old realm reconnecting back to the new one.","ref":"095-known_issues.html#realm-deletion","title":"Known issues - Realm deletion","type":"extras"},{"doc":"Currently Astarte authorization mechanism doesn't allow permissions on groups with a device granularity. Specifically there's no way to authorize a user to add only specific devices to a group. The issue is tracked here . This means that right now the best way to allow users to add or remove devices from a group they have access to is to provide a backend which is able to perform the necessary authorization checks and then performs the necessary additions/removals, while the user only has a read access to the group resource. In the long term a minor semantic change is going to employed, therefore currently we discourage emitting long living tokens which allow a non-root user to manage groups (i.e. create and modify them) since the current tokens could become incompatible with future changes.","ref":"095-known_issues.html#group-permissions","title":"Known issues - Group permissions","type":"extras"},{"doc":"In some circumstances, prior to Astarte v1.0 , a device might be mistakenly reported as connected. This bug has been fixed in v1.0 , however this bug may still affect devices that have connected last time while using v0.11 (prior to the upgrade to v1.0 ). This issue is likely to happen when upgrading to v1.0 since it might be caused by VerneMQ shutdown. A device reconnection fixes this issue, and the connection state will always be reliably reported.","ref":"095-known_issues.html#ghost-connected-devices","title":"Known issues - Ghost connected devices","type":"extras"},{"doc":"Introduction This documentation page describes a development version, for production systems please use the stable version instead. This guide is meant for System Administrators who need to deal with Astarte clusters installation, maintenance and upgrade. The guide will cover prerequisites, installation in different supported environments, and common maintenance operations. Before you begin, it is fundamental you are familiar with Astarte's architecture, design and concepts , especially for what concerns its components and 3rd party services.","ref":"001-intro_administrator.html","title":"Introduction","type":"extras"},{"doc":"System Requirements Astarte is a Native Kubernetes application, and as such Kubernetes is a hard requirement. It is possible to run Astarte outside Kubernetes, although a number of features won't be available - these setups are outside the scope of this document.","ref":"010-system_requirements.html","title":"System Requirements","type":"extras"},{"doc":"Astarte requires at least Kubernetes 1.19, and strives to be compatible with all newer Kubernetes versions. It is advised to consult Astarte Operator's compatibility matrix in the README to ensure a specific Kubernetes setup is supported. The Astarte Operator does not require any unstable feature gate in Kubernetes 1.19, and is actively tested against KinD and major Managed Kubernetes installations on various Cloud Providers.","ref":"010-system_requirements.html#kubernetes-requirements","title":"System Requirements - Kubernetes Requirements","type":"extras"},{"doc":"Astarte Operator requires cert-manager to enable Webhooks. This documentation will detail all needed steps for installing cert-manager in the cluster in case it's not installed yet.","ref":"010-system_requirements.html#dependencies","title":"System Requirements - Dependencies","type":"extras"},{"doc":"Depending on the kind of setup, Astarte might require different resource configurations when it comes to nodes. In addition, if one is planning on a redundant setup, a minimum of 3 physical nodes is required. To spin up a testing instance you should allocate at least 4 vCPU and 8GB of memory just for Astarte. Please keep in mind that additional applications running within the cluster and the Kubernetes overhead itself must be accounted when sizing your Astarte cluster.","ref":"010-system_requirements.html#resource-requirements","title":"System Requirements - Resource Requirements","type":"extras"},{"doc":"Prerequisites As much as Astarte's Operator is capable of creating a completely self-contained installation, there's a number of prerequisites to be fulfilled depending on the use case.","ref":"020-prerequisites.html","title":"Prerequisites","type":"extras"},{"doc":"In your local machine, you'll need two main tools: kubectl and astartectl . Ensure you have a kubectl version matching your target Kubernetes cluster version, and a recent astartectl version.","ref":"020-prerequisites.html#on-your-machine","title":"Prerequisites - On your machine","type":"extras"},{"doc":"Astarte currently features only one supported Managed Ingress, based on NGINX . NGINX provides routing, SSL termination and more, and as of today is the preferred/advised way to run Astarte in production. Astarte Operator is capable of interacting with NGINX through its dedicated AstarteDefaultIngress resource, as long as an NGINX ingress controller is installed. Installing the ingress controller is as simple as running a few helm commands: $ helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx $ helm repo update $ helm install ingress-nginx ingress-nginx/ingress-nginx -n ingress-nginx \\ --set controller.service.externalTrafficPolicy=Local \\ --create-namespace Please, be aware that trying to deploy multiple ingress controllers in your cluster may result in all of them trying simultaneously to handle the Astarte ingress resource. Consider using ingress classes for avoiding confusing situations as outlined here . In the end, you won't need to create NGINX ingresses yourself: the Astarte Operator itself will take care of this task.","ref":"020-prerequisites.html#nginx","title":"Prerequisites - NGINX","type":"extras"},{"doc":"Until Astarte v1.0.0, the only supported Managed Ingress was the Voyager based AstarteVoyagerIngress . Starting from Dec the 31st 2021, according to the Voyager announcement , the support for Voyager will be dropped as stated here . An alternative NGINX based Managed Ingress has been developed to replace the Voyager based solution (for reference, see the previous section).","ref":"020-prerequisites.html#voyager-deprecated","title":"Prerequisites - Voyager (deprecated)","type":"extras"},{"doc":"Astarte requires cert-manager to be installed in the cluster in its default configuration (installed in namespace cert-manager as cert-manager ). If you are using cert-manager in your cluster already you don't need to take any action - otherwise, you will need to install it. Astarte is actively tested with cert-manager 1.7, but should work with any 1.0+ releases of cert-manager . If your cert-manager release is outdated, please consider upgrading to a newer version according to this guide . cert-manager documentation details all needed steps to have a working instance on your cluster - however, in case you won't be using cert-manager for other components beyond Astarte or, in general, if you don't have very specific requirements, it is advised to install it through its Helm chart. To do so, run the following commands: $ helm repo add jetstack https://charts.jetstack.io $ helm repo update $ kubectl create namespace cert-manager $ helm install \\ cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --version v1.7.0 \\ --set installCRDs=true This will install cert-manager 1.7.0 and its CRDs in the cluster.","ref":"020-prerequisites.html#cert-manager","title":"Prerequisites - cert-manager","type":"extras"},{"doc":"In production deployments, it is strongly advised to have a separate Cassandra cluster interacting with the Kubernetes installation. This is due to the fact that Cassandra Administration is a critical topic, especially with mission critical workloads. Astarte Operator includes only basic management of Cassandra, which is deprecated since v1.0 and as such it should not be relied upon when dealing with production environments. Furthermore, in the near future, Cassandra support is planned to be removed from Astarte Operator in favor of the adoption of a dedicated Kubernetes Operator (e.g. Scylla Operator ). In case an external Cassandra cluster is deployed, be aware that Astarte lives on the assumption it will be the only application managing the Cluster - as such, it is strongly advised to have a dedicated cluster for Astarte.","ref":"020-prerequisites.html#external-cassandra-scylla","title":"Prerequisites - External Cassandra / Scylla","type":"extras"},{"doc":"When deploying external components, it is important to take in consideration how Kubernetes behaves with the underlying infrastructure. Most modern Cloud Providers have a concept of Virtual Private Cloud, by which the internal Kubernetes Network stack directly integrates with their Network stack. This, in short, enables deploying Pods in a shared private network, in which other components (such as Virtual Machines) can be deployed. This is the preferred, advised and supported configuration. In this scenario, there's literally no difference between interacting with a VM or a Pod, enabling a hybrid infrastructure without having to pay the performance cost.","ref":"020-prerequisites.html#kubernetes-and-external-components","title":"Prerequisites - Kubernetes and external components","type":"extras"},{"doc":"Installing Astarte Operator The most simple and common installation procedure exploits the Astarte Operator's Helm chart . Helm is intended to be used as the operator's lifecycle management tool, thus make sure you are ready with a working Helm installation . Please, before starting with the Operator's install procedure make sure that any prerequisite has been satisfied.","ref":"030-installation_kubernetes.html","title":"Installing Astarte Operator","type":"extras"},{"doc":"Installing the Operator is as simple as $ helm repo add astarte https://helm.astarte-platform.org $ helm repo update $ helm install astarte-operator astarte/astarte-operator -n kube-system This command will take care of installing all needed components for the Operator to run. This includes all the RBAC roles, Custom Resource Definitions, Webhooks, and the Operator itself. You can use the --version switch to specify a version to install. When not specified, the latest stable version will be installed instead.","ref":"030-installation_kubernetes.html#installation","title":"Installing Astarte Operator - Installation","type":"extras"},{"doc":"The procedure for upgrading the Operator depends on the version of the Operator you want to upgrade from. Please refer to the Upgrade Guide section that fits your needs.","ref":"030-installation_kubernetes.html#upgrading-the-operator","title":"Installing Astarte Operator - Upgrading the Operator","type":"extras"},{"doc":"WARNING - Understanding the consequences of the uninstall procedure is fundamental to avoid catastrophic aftermaths. Please read carefully this section to understand how the uninstall procedure may impact your Astarte instance. Be aware that the following statements hold: the Astarte's CRDs are installed and handled by the Operator's Helm chart; uninstalling the Operator causes the Astarte's CRDs to be marked for deletion; the deletion of CRDs leads to the destruction of all the Kubernetes instances of the CRDs (i.e. Astarte will be destroyed). The Advanced Operations section outlines all the relevant information to handle your Astarte instance when uninstalling the Operator, explains how to recover your Astarte instance and highlights in a more exhaustive way what's happening under the hood. To uninstall the Operator, use the dedicated helm uninstall command. This operation is responsible for the deletion of both RBACs and the Operator's deployment itself. Moreover, all the CRDs installed by the Operator's Helm chart are marked for deletion. $ helm uninstall astarte-operator -n kube-system So, what should you expect after uninstalling the Operator? After executing the helm uninstall command your Operator's deployment will be destroyed, along with the AstarteVoyagerIngress and Flow CRDs and resources (when they exist). Both the Astarte CRD and its instance will not be immediately destroyed as their deletion is allowed after the Astarte finalizer is executed. Please refer to the Advanced Operations section to learn how to handle your Astarte instance and how to restore its functionalities.","ref":"030-installation_kubernetes.html#uninstalling-the-operator","title":"Installing Astarte Operator - Uninstalling the Operator","type":"extras"},{"doc":"Manual Operator Installation In case you do not want to use helm to manage the Operator, this guide will run you through all the steps needed to set up Astarte Kubernetes. To come along with this guide, the following components are required: operator-sdk kustomize Please make sure that the version of operator-sdk matches or is compatible with the version of the operator-sdk module in the Operator's go.mod file. Moreover, please make sure that the cluster kubectl is pointing to is the one you want to target with the installation. Note: Please be aware that this method is to be used only if you have very specific reasons why not to use helm , for example: you're running a fork of the Operator, you're running the Operator outside of the cluster, or you're on the very bleeding edge. helm automates internally all of this guide and should be your main choice in production.","ref":"040-manual_kubernetes.html","title":"Manual Operator Installation","type":"extras"},{"doc":"First of all, you will need to clone the Operator repository, as this is where some of the needed resources for the Operator are. Ensure you're cloning the right branch for the Operator Version you'd like to install, in this case v1.0: git clone https://github.com/astarte-platform/astarte-kubernetes-operator.git cd astarte-kubernetes-operator","ref":"040-manual_kubernetes.html#clone-the-operator-repository","title":"Manual Operator Installation - Clone the Operator Repository","type":"extras"},{"doc":"The Operator requires a number of RBAC roles to run, and will also require Astarte CRDs to be installed. To install all the required components, simply run: make install","ref":"040-manual_kubernetes.html#install-rbacs-and-crds","title":"Manual Operator Installation - Install RBACs and CRDs","type":"extras"},{"doc":"Running the Operator inside the cluster is as simple as executing the following: make deploy Actually, the above command does more than just deploying the Operator, as it also install RBACs, CRDs. The deployment therefore can be performed in just one command. To check if the deployment is successful: kubectl get deployment -n kube-system astarte-operator","ref":"040-manual_kubernetes.html#running-the-operator-inside-the-cluster","title":"Manual Operator Installation - Running the Operator inside the Cluster","type":"extras"},{"doc":"Note: Running the operator outside the cluster is not advised in production. Usually, you need such a deployment if you plan on developing the Operator itself. However, this scenario is tested in the e2e tests, and as such provides the very same features of the in-cluster Deployment, which remains the go-to scenario for production. From the root directory of your clone, run: make run ENABLE_WEBHOOKS=false This will bring up the Operator (with all the webhooks disabled) and connect it to your current Kubernetes context. In case you need to run the Operator with webhooks, please refer to the Operator-SDK documentation . Caveats When running the Operator locally, you're bound to a single namespace, and to all limitations of operator-sdk run . This is out of the scope of this guide, and you should be confident with operator-sdk 's User Guide if you plan on running the Operator outside the Cluster.","ref":"040-manual_kubernetes.html#running-the-operator-outside-the-cluster","title":"Manual Operator Installation - Running the Operator outside the Cluster","type":"extras"},{"doc":"Handling Astarte certificates Astarte heavily requires SSL in a number of interactions, even though this can be bypassed with ssl: false . In general, there are two alternative scenarios when dealing with certificates: you already purchased SSL certificates for your domains, you want your certificates to be handled by Let's Encrypt through cert-manager. The two alternative procedures for securing your Astarte deployment are outlined in the following sections.","ref":"050-handling_certificates.html","title":"Handling Astarte certificates","type":"extras"},{"doc":"If you already own certificates for your domains, all it's needed is creating a TLS secret in the namespace in which Astarte resides. Assuming that the certificate and key are saved respectively as cert.pem and privkey.pem , simply run: $ kubectl create secret tls astarte-tls-cert -n astarte \\ --cert=cert.pem --key=privkey.pem","ref":"050-handling_certificates.html#use-your-own-certificates","title":"Handling Astarte certificates - Use your own certificates","type":"extras"},{"doc":"The process of obtaining a TLS certificate from Let's Encrypt is handled by cert-manager using a cluster issuer. The issuer will query the Let's Encrypt API and handles the challenge to confirm that you are the right owner of the specified domain. Two types of challenges are supported, namely DNS01 and HTTP01. Ensure all the prerequisites are satisfied and that both cert-manager and the NGINX ingress controller are deployed within your cluster. If you haven't installed them yet, you can do it with these simple commands: install cert-manager: $ helm repo add jetstack https://charts.jetstack.io $ helm repo update $ kubectl create namespace cert-manager $ helm install \\ cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --version v1.7.0 \\ --set installCRDs=true install NGINX ingress controller: $ helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx $ helm repo update $ helm install ingress-nginx ingress-nginx/ingress-nginx -n ingress-nginx \\ --set controller.service.externalTrafficPolicy=Local \\ --create-namespace HTTP01 Challenge The current section outlines the procedure for setting up a ClusterIssuer to solve the HTTP01 challenge. Find the external IP assigned to the ingress controller Knowing the external IP of the NGINX ingress controller is crucial for solving the HTTP01 challenge. You can find the external IP under the EXTERNAL-IP field when inspecting the output of the following command: $ kubectl get svc -n ingress-nginx ingress-nginx-controller Configure your DNS Once the external IP of the ingress controller is known, make sure all your Astarte domains point to the NGINX Ingress controller IP. In particular, the list of the domains is: api.your-domain.example.com dashboard.your-domain.example.com (if deployed) broker.your-domain.example.com Create a ClusterIssuer Define a ClusterIssuer and save it as cluster-issuer.yaml : apiVersion: cert-manager.io/v1 kind: ClusterIssuer metadata: name: letsencrypt spec: acme: server: https://acme-v02.api.letsencrypt.org/directory email: your-email@email.com privateKeySecretRef: name: letsencrypt solvers: - http01: ingress: class: nginx Then, apply the resource with the following: $ kubectl apply -f cluster-issuer.yaml Create a Certificate resource Once the ClusterIssuer has been created, add a Certificate resource in the Astarte namespace referencing the ClusterIssuer , and save it as certificate.yaml : apiVersion: cert-manager.io/v1 kind: Certificate metadata: name: astarte-default-ingress-certificate namespace: astarte spec: dnsNames: - &lt;your-dns.names&gt; secretName: astarte-tls-cert issuerRef: name: letsencrypt kind: ClusterIssuer Then, apply the Certificate resource: $ kubectl apply -f certificate.yaml Wait the HTTP challenge to complete As soon as the HTTP challenge completes, a Kubernetes secret of type kubernetes.io/tls called astarte-tls-cert will be created in the astarte namespace. Now you can reference the TLS secret in both the Astarte and AstarteDefaultIngress resources where required. DNS01 challenge The current section describes the procedure for setting up a ClusterIssuer to use Google CloudDNS to solve the DNS01 challenge. Therefore, when needed, the rest of this section will make use of the gcloud CLI . If your Astarte deployment is hosted by another cloud provider, please refer to the cert-manager specific documentation . Define a DNS Zone for your project First, ensure that a DNS Zone is already defined for your project . If this requirement is not satisfied, this page provides guidance for the creation of the DNS Zone for a project hosted on Google Cloud. If your cluster is hosted by any other cloud provider, please ensure to follow the needed steps to fulfill the requirement. Set up a Service Account with privileges of DNS Administrator To set up a service account with privileges of DNS Administrator, run the following command: $ PROJECT_ID=&lt;your-project-id&gt; $ gcloud iam service-accounts create dns01-solver --display-name &quot;dns01-solver&quot; $ gcloud projects add-iam-policy-binding $PROJECT_ID \\ --member serviceAccount:dns01-solver@$PROJECT_ID.iam.gserviceaccount.com \\ --role roles/dns.admin Create a Service Account secret To access the service account, cert-manager uses a key stored in a Kubernetes Secret. Therefore, create a key and download it as a json file: $ gcloud iam service-accounts keys create key.json \\ --iam-account dns01-solver@$PROJECT_ID.iam.gserviceaccount.com and create a secret named clouddns-dns01-solver-svc-acct in the cert-manager namespace from the key.json file: $ kubectl create secret generic -n cert-manager \\ clouddns-dns01-solver-svc-acct \\ --from-file=key.json Create a ClusterIssuer that uses CloudDNS Define a ClusterIssuer resource which uses the secret, and save it as cluster-issuer.yaml : apiVersion: cert-manager.io/v1 kind: ClusterIssuer metadata: name: letsencrypt-dns-cluster-issuer spec: acme: server: https://acme-v02.api.letsencrypt.org/directory email: your-email@email.com privateKeySecretRef: # Secret resource that will be used to store the account's private key. name: letsencrypt-cluster-issuer-key solvers: - dns01: cloudDNS: # The ID of the GCP project project: &lt;your-project-id&gt; # This is the secret used to access the service account serviceAccountSecretRef: name: clouddns-dns01-solver-svc-acct key: key.json Apply the resource simply running the following: $ kubectl apply -f cluster-issuer.yaml Create a Certificate resource Once the ClusterIssuer has been created, add a Certificate resource in the Astarte namespace referencing the ClusterIssuer , and save it as certificate.yaml : apiVersion: cert-manager.io/v1 kind: Certificate metadata: name: astarte-default-ingress-certificate namespace: astarte spec: dnsNames: - &lt;your-dns.names&gt; secretName: astarte-tls-cert issuerRef: name: letsencrypt-dns-cluster-issuer kind: ClusterIssuer Thus, apply the Certificate resource: $ kubectl apply -f certificate.yaml Wait the DNS challenge to complete As soon as the DNS challenge completes, a Kubernetes secret of type kubernetes.io/tls called astarte-tls-cert will be created in the astarte namespace. Now you can reference the TLS secret in both the Astarte and AstarteDefaultIngress resources where required.","ref":"050-handling_certificates.html#use-let-s-encrypt-certificates-with-cert-manager","title":"Handling Astarte certificates - Use Let's Encrypt certificates with cert-manager","type":"extras"},{"doc":"The current page describes how to handle SSL certificates for securing your Astarte instance. In particular the following use cases are analyzed: certificates have already been purchased and needs to be properly deployed, let cert-manager generate and handle certificates in the following cases: solving HTTP01 ACME challenges, solving DNS01 ACME challenges. At the end of each procedure you will end up with a Kubernetes TLS secret, named astarte-tls-cert , deployed in the Astarte namespace. Reference the secret in your Astarte and AstarteDefaultIngress resources where required to secure your Astarte deployment.","ref":"050-handling_certificates.html#conclusions","title":"Handling Astarte certificates - Conclusions","type":"extras"},{"doc":"Setting up the Cluster Once the Astarte Operator has been installed , and any prerequisite has been fulfilled , you can move forward and deploy an Astarte Cluster.","ref":"060-setup_cluster.html","title":"Setting up the Cluster","type":"extras"},{"doc":"The standard way of deploying an Astarte instance is by creating your own Astarte Custom Resource. This gives you an high degree of customization, allowing you to tweak any single parameter in the Astarte setup. The main Astarte CRD contains extensive documentation on the available fields in OpenAPIv3 format. Just create your Astarte Custom Resource, which will look something like this: apiVersion: api.astarte-platform.org/v1alpha1 kind: Astarte metadata: name: astarte namespace: astarte spec: # This is the most minimal set of reasonable configuration to spin up an Astarte # instance with reasonable defaults and enough control over the deployment. version: 1.0.1 api: host: &quot;api.astarte.yourdomain.com&quot; # MANDATORY rabbitmq: resources: requests: cpu: 300m memory: 512M limits: cpu: 1 memory: 1000M # this configuration deploys cassandra in cluster. This is not advised for production environments cassandra: maxHeapSize: 1024M heapNewSize: 256M storage: size: 30Gi resources: requests: cpu: 1 memory: 1024M limits: cpu: 2 memory: 2048M vernemq: host: &quot;broker.astarte.yourdomain.com&quot; sslListener: true sslListenerCertSecretName: &lt;your-tls-secret&gt; resources: requests: cpu: 200m memory: 1024M limits: cpu: 1000m memory: 2048M cfssl: resources: requests: cpu: 100m memory: 128M limits: cpu: 200m memory: 256M storage: size: 2Gi components: # Global resource allocation. Automatically allocates resources to components weighted in a # reasonable way. resources: requests: cpu: 1200m memory: 3072M limits: cpu: 3000m memory: 6144M Starting from Astarte v1.0.1, traffic coming to the broker is TLS terminated ad VerneMQ level. The two fields controlling this features, namely sslListener and sslListenerCertSecretName can be found within the vernemq section of the Astarte CR. In a nutshell, their meaning is: sslListener controls whether TLS termination is enabled at VerneMQ level or not, sslListenerCertSecretName is the name of TLS secret used for TLS termination (more on how to deal with Astarte certificates here ). When sslListener is true, the secret name must be set. You can simply apply this resource in your Kubernetes cluster with kubectl apply -f . The Operator will take over from there.","ref":"060-setup_cluster.html#using-a-standard-astarte-cr","title":"Setting up the Cluster - Using a standard Astarte CR","type":"extras"},{"doc":"Setting up Astarte Default Ingress Once your Cluster is up and running , to expose it to the outer world you need to set up an Ingress. Currently, the only managed and supported Ingress is based upon NGINX , and this guide will cover only this specific case. Please, note that the previously supported Voyager based ingress is deprecated and should not be used (see the Voyager announcement and the related Astarte issue for further details). If you want to migrate away from AstarteVoyagerIngress to the new AstarteDefaultIngress, please refer to the procedure outlined here .","ref":"064-setup_astartedefaultingress.html","title":"Setting up Astarte Default Ingress","type":"extras"},{"doc":"Before proceeding with the deployment of the Astarte Default Ingress, the following requirements must be fulfilled: TLS certificates must be deployed as a secret within the namespace in which Astarte resides (see the Handling Astarte Certificates section). To check if the TLS secret is correctly deployed, you can run: $ kubectl get secrets -n astarte and make sure your certificate is stored in a secret of type kubernetes.io/tls in that list; Astarte must be configured such that TLS termination is handled at VerneMQ level: this can be done simply editing the Astarte resource and, in the vernemq section, setting the sslListener and sslListenerCertSecretName . Your Astarte CR will look something like: apiVersion: api.astarte-platform.org/v1alpha2 kind: Astarte ... spec: ... vernemq: sslListener: true sslListenerCertSecretName: &lt;your-tls-secret-name&gt; ... ingress-nginx ingress controller must be deployed within your cluster. You can install it following the instructions reported here .","ref":"064-setup_astartedefaultingress.html#prerequisites","title":"Setting up Astarte Default Ingress - Prerequisites","type":"extras"},{"doc":"Most information needed for exposing your Ingress have already been given in your main Astarte resource. If your Kubernetes installation supports LoadBalancer ingresses (most managed ones do), you should be able to get away with the most standard CR: apiVersion: ingress.astarte-platform.org/v1alpha1 kind: AstarteDefaultIngress metadata: name: adi namespace: astarte spec: ### Astarte Default Ingress CRD astarte: astarte tlsSecret: &lt;your-astarte-tls-cert&gt; api: exposeHousekeeping: true dashboard: deploy: true ssl: true host: &lt;your-astarte-dashboard-host&gt; broker: deploy: true serviceType: LoadBalancer # loadBalancerIP is needed if your certificate is obtained with the solution of the HTTP # challenge, othewise it's optional. Please, be aware that the possibilities and modes for # assigning a loadBalancerIP to a service depend on your cloud provider. loadBalancerIP: &lt;your-loadbalancerIP&gt; There's one very important thing to be noted: the astarte field must reference the name of an existing Astarte installation in the same namespace, and the Ingress will be configured and attached to that instance.","ref":"064-setup_astartedefaultingress.html#creating-an-astartedefaultingress","title":"Setting up Astarte Default Ingress - Creating an AstarteDefaultIngress","type":"extras"},{"doc":"When the AstarteDefaultIngress resource is created, the Astarte Operator ensures that the following resources are created according to your configuration: an NGINX ingress which is devoted to routing requests to the Astarte APIs and to the Astarte Dashboard, a service of kind LoadBalancer which exposes the Astarte broker to the outer world. The following commands will help you in the task of retrieving the external IPs assigned to both the ingress and the broker service. Assuming that your Astarte instance and AstarteDefaultIngress are respectively named astarte and adi , and that they are deployed within the astarte namespace, simply run: $ # retrieve information about the ingress $ kubectl get ingress -n astarte NAME CLASS HOSTS ADDRESS PORTS AGE adi-api-ingress nginx &lt;your-hosts&gt; X.Y.W.Z 80, 443 6s and $ # retrieve information about the broker service $ kubectl get service -n astarte adi-broker-service NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE adi-broker-service LoadBalancer x.x.x.x A.B.C.D 443:32149/TCP 17s","ref":"064-setup_astartedefaultingress.html#what-happens-after-installing-the-astartedefaultingress-resource","title":"Setting up Astarte Default Ingress - What happens after installing the AstarteDefaultIngress resource?","type":"extras"},{"doc":"Astarte heavily requires SSL in a number of interactions, even though this can be bypassed with ssl: false . If you do not have any SSL certificates for your domains, you can leverage cert-manager capabilities. Simply follow the instructions outlined here to learn how to handle your certificates.","ref":"064-setup_astartedefaultingress.html#ssl-and-certificates","title":"Setting up Astarte Default Ingress - SSL and Certificates","type":"extras"},{"doc":"When your certificate is issued after the solution of an HTTP challenge, to ensure the renewal of the certificate itself you must ensure that the NGINX ingress and the broker service are exposed on the same external IP. Given that the ingress external IP is obtained after the deployment of the NGINX ingress controller, all you have to do is ensuring that the broker service is exposed on the ingress IP. Thus, set the loadBalancerIP field in your AstarteDefaultIngress resource: apiVersion: ingress.astarte-platform.org/v1alpha1 kind: AstarteDefaultIngress ... spec: ... broker: deploy: true serviceType: LoadBalancer loadBalancerIP: &lt;same-IP-of-your-ingress&gt; Please, be aware that the possibility of setting the loadBalancerIP is dependent on your cloud provider. For example, if your Astarte instance is hosted by Google, you will need to reserve the IP before assigning it to the broker service (see this page for further details). Discussing how other cloud providers handle this specific task is out of the scope of this guide and is left to the reader.","ref":"064-setup_astartedefaultingress.html#how-to-support-automatic-certificate-renewal-for-http-challenges","title":"Setting up Astarte Default Ingress - How to support automatic certificate renewal for HTTP challenges?","type":"extras"},{"doc":"AstarteDefaultIngress deploys a well-known tree of APIs to the host you specified in the main Astarte resource. In particular, assuming your API host was api.astarte.yourdomain.com : Housekeeping API base URL will be: https://api.astarte.yourdomain.com/housekeeping Realm Management API base URL will be: https://api.astarte.yourdomain.com/realmmanagement Pairing API base URL will be: https://api.astarte.yourdomain.com/pairing AppEngine API base URL will be: https://api.astarte.yourdomain.com/appengine","ref":"064-setup_astartedefaultingress.html#api-paths","title":"Setting up Astarte Default Ingress - API Paths","type":"extras"},{"doc":"AstarteDefaultIngress has a number of advanced options that can be used to accommodate needs of the most diverse deployments. Consult the CRD Documentation to learn more.","ref":"064-setup_astartedefaultingress.html#further-customization","title":"Setting up Astarte Default Ingress - Further customization","type":"extras"},{"doc":"Setting up the Astarte Voyager Ingress IMPORTANT : Due to changes in Voyager policies and to the announcement that, starting from Dec 31st 2021, it will not possible to pull older Voyager docker images the Astarte Voyager Ingress is deprecated and will be dropped in a future release (i.e.: v1.1 ). Please, consider using the NGINX based drop-in replacement for Astarte called AstarteDefaultIngress . Once your Cluster is up and running , to expose it to the outer world you need to set up an Ingress. Currently, the only managed and supported Ingress is based upon Voyager , and this guide will cover only this specific case. Of course, ensure you have installed Voyager Operator before you begin.","ref":"065-setup_astartevoyageringress.html","title":"Setting up the Astarte Voyager Ingress","type":"extras"},{"doc":"Most information needed for exposing your Ingress have already been given in your main Astarte resource. If your Kubernetes installation supports LoadBalancer ingresses (most managed ones do), you should be able to get away with the most standard CR: apiVersion: api.astarte-platform.org/v1alpha1 kind: AstarteVoyagerIngress metadata: name: example-minimal namespace: astarte spec: # The Astarte Instance the Ingress will be attached to astarte: example-minimal api: exposeHousekeeping: true dashboard: ssl: true host: &quot;dashboard.astarte.yourdomain.com&quot; # When not specified, dashboard will be deployed in /dashboard in the API host. letsencrypt: use: true acmeEmail: info@yourdomain.com challengeProvider: dns: provider: digitalocean credentialSecretName: voyager-digitalocean As you might see, there's only one very important thing to be noted: the astarte field must reference the name of an existing Astarte installation in the same namespace, and the Ingress will be configured and attached to that instance.","ref":"065-setup_astartevoyageringress.html#creating-an-astartevoyageringress","title":"Setting up the Astarte Voyager Ingress - Creating an AstarteVoyagerIngress","type":"extras"},{"doc":"Astarte heavily requires SSL in a number of interactions, even though this can be bypassed with ssl: false . If you do not have any SSL Certificates for your domains, you can leverage Voyager's Let's Encrypt integration. AstarteVoyagerIngress integrates directly with Voyager's native types, and you can follow along Voyager's Let's Encrypt guide . Simply set letsencrypt.use to true , and fill the challengeProvider with the right parameters.","ref":"065-setup_astartevoyageringress.html#ssl-and-certificates","title":"Setting up the Astarte Voyager Ingress - SSL and Certificates","type":"extras"},{"doc":"AstarteVoyagerIngress deploys a well-known tree of APIs to the host you specified in the main Astarte resource. In particular, assuming your API host was api.astarte.yourdomain.com : Housekeeping API base URL will be https://api.astarte.yourdomain.com/housekeeping/v1 Realm Management API base URL will be https://api.astarte.yourdomain.com/realmmanagement/v1 Pairing API base URL will be https://api.astarte.yourdomain.com/pairing/v1 AppEngine API base URL will be https://api.astarte.yourdomain.com/appengine/v1","ref":"065-setup_astartevoyageringress.html#api-paths","title":"Setting up the Astarte Voyager Ingress - API Paths","type":"extras"},{"doc":"AstarteVoyagerIngress has a number of advanced options that can be used to accommodate needs of the most diverse deployments. Consult the CRD Documentation to learn more.","ref":"065-setup_astartevoyageringress.html#further-customization","title":"Setting up the Astarte Voyager Ingress - Further customization","type":"extras"},{"doc":"Migrating to the Astarte Default Ingress If your Astarte deployment is still being served by the deprecated AstarteVoyagerIngress, it is highly advised to move to the new managed ingress, namely, the AstarteDefaultIngress. The current page focuses on describing the procedure for migrating your ingress with ease, simply employing astartectl . Please, make sure you have read the entirety of this page and to understand all the concepts and the implications before performing the actual migration.","ref":"066-migrate_to_astartedefaultingress.html","title":"Migrating to the Astarte Default Ingress","type":"extras"},{"doc":"Before starting with the actual migration procedure, some preliminary activities are required: ensure that the version of the Astarte operator in your cluster is at least &gt;= v1.0.1 and stable. If this requirement is not fulfilled, please refer to the Upgrade Procedures section; the ingress-nginx ingress controller must be deployed in your cluster (see this section for the details). Be sure of taking note of the ingress-class of the controller which is meant to handle your Astarte ingress. This information will come handy during the migration itself; make sure the TLS secrets used to secure the communications to and from Astarte are deployed. For the details, please refer to the Handling Astarte certificates page; ensure that astartectl is installed on your machine and its version is at least &gt;= v1.0.0 .","ref":"066-migrate_to_astartedefaultingress.html#prerequisites-and-preliminary-checks","title":"Migrating to the Astarte Default Ingress - Prerequisites and preliminary checks","type":"extras"},{"doc":"Performing the actual ingress migration is as simple as executing an astartectl command: $ astartectl cluster instances migrate replace-voyager The replace-voyager command provides meaningful defaults so that, if your Astarte deployment relies on standard naming practices, you can simply omit all the flags. The following list of options is available: --namespace : the namespace in which the Astarte instance resides (default: &quot;astarte&quot;); --operator-name : the name of the Astarte Operator instance (default: &quot;astarte-operator-controller-manager&quot;); --operator-namespace : the namespace in which the Astarte Operator resides (default: &quot;kube-system&quot;); --ingress-name : the name of the AstarteVoyagerIngress to be migrated. When not set, the first ingress found in the cluster will be selected. To find the AstarteVoyagerIngress resources present in your cluster simply run: $ kubectl get avi -n &lt;astarte-namespace&gt; --out : the name of the file in which the AstarteVoyagerIngress custom resource will be saved (optional). To successfully complete the procedure, you will be prompted to interactively insert details such as: the name of the Astarte TLS secrets, the name of the to-be-installed AstarteDefaultIngress resource, the ingress class of the NGINX ingress controller. Before starting the migration routine, you will be asked to review the generated AstarteDefaultIngress custom resource. The migration will start only upon confirmation. Please, note that you can contextually dump your AstarteVoyagerIngress custom resource for backup purposes simply using the --out &lt;filename&gt; option. What happens under the hood? When invoking the replace-voyager command, astartectl interacts with your Astarte cluster and retrieves the AstarteVoyagerIngress resource which serves your Astarte instance. If no AstarteVoyagerIngresses are present, the procedure is immediately terminated as there is nothing to migrate. After all the required information is provided through the interactive prompt, the AstarteDefaultIngress resource is reviewed and the final confirmation is provided, the following tasks are performed: the Astarte resource is patched so that TLS termination is handled at the VerneMQ level: in particular, the fields sslListener and sslListenerCertSecretName are populated; the AstarteDefaultIngress resource is installed within your cluster. Once installed, the Astarte Operator takes over and ensures that: a service of kind LoadBalancer is created to serve the Astarte broker, an ingress resource is created to serve the Astarte APIs (and the Dashboard, if requested). If one of the previous tasks are not successful, the migration logic is reverted as not to leave your cluster in a broken state. At the end of the procedure, after the AstarteDefaultIngress is successfully created, the old AstarteVoyagerIngress resource will be deleted. Anyway, if any errors occur during the deletion of the AstarteVoyagerIngress, the migration procedure is not reverted (as the AstarteDefaultIngress resource is successfully deployed) and, as such, you are required to explicitly delete the AstarteVoyagerIngress resource by hand. Be aware that Voyager specific annotations cannot be mapped to the AstarteDefaultIngress. If any of those annotations are present, the replace-voyager command will print a warning message. It will be your responsibility confirming whether you want to proceed or abort the procedure.","ref":"066-migrate_to_astartedefaultingress.html#performing-the-migration","title":"Migrating to the Astarte Default Ingress - Performing the migration","type":"extras"},{"doc":"The current section focuses on some advanced configuration scenarios that might help you in handling specific non-standard use cases. Preserve the API and Broker IPs The need of preserving both the API and Broker IPs may arise in specific use cases when, for example, there are any number of impediments in updating your DNS zones. Please, be aware that the following instructions rely on the assumption that you can reserve (or you already reserved) external IPs. This task is highly dependent on your cloud service provider and, as such, you are required to ensure that it can be performed in your specific case. If your Astarte instance is exposed to the outer world through the AstarteVoyagerIngress, two external IPs are assigned to your services: one for the Broker and another for the Astarte APIs (and the dashboard, if deployed). Before migrating your ingress to the AstarteDefaultIngress, perform the following operations: ensure that both the API and the Broker IPs are reserved, patch your AstarteVoyagerIngress resource such that the loadBalancerIP field is set for the broker (if this field is already set, you can skip this step): broker: loadBalancerIP: &lt;the-broker-reserved-IP&gt; ... install (or update, if already installed) the ingress-nginx deployment by explicitly setting the IP for the ingress controller as to make it coincident with the IP assigned to the Astarte APIs. Be aware that, at first, the ingress controller external IP will remain in pending state until the AstarteVoyagerIngress will be deleted and, once that IP will be available, it will be correctly assigned to the ingress controller. $ helm upgrade --install &lt;ingress-nginx-name&gt; ingress-nginx/ingress-nginx \\ -n ingress-nginx \\ --set controller.service.externalTrafficPolicy=Local \\ --set controller.service.loadBalancerIP=&lt;the-API-reserved-IP&gt; Once the previous instructions are executed, you are ready to perform the migration to the AstarteDefaultIngress as described in the Performing the Migration section. As a final remark, if you are interested in preserving only one of the external IPs, please refer only to the instructions that apply to your needs (e.g.: the broker) while neglecting the remaining parts.","ref":"066-migrate_to_astartedefaultingress.html#advanced-use-cases","title":"Migrating to the Astarte Default Ingress - Advanced use cases","type":"extras"},{"doc":"Managing Realms Once the Cluster is set up, you can start managing it by creating Realms.","ref":"070-manage_realms.html","title":"Managing Realms","type":"extras"},{"doc":"When creating a new Cluster, Astarte Operator also creates a brand new keypair and stores it in the cluster. To retrieve it (assuming you deployed an instance named astarte in namespace astarte ): kubectl get secret -n astarte astarte-housekeeping-private-key -o=jsonpath={.data.private-key} | base64 -d &gt; housekeeping.key You can then use housekeeping.key to authenticate against Housekeeping API.","ref":"070-manage_realms.html#accessing-housekeeping-key","title":"Managing Realms - Accessing Housekeeping key","type":"extras"},{"doc":"This guide is not yet complete, as this part is a moving target within astartectl . Please refer to the API Documentation to manage Realms manually once here.","ref":"070-manage_realms.html#work-in-progress","title":"Managing Realms - Work in progress","type":"extras"},{"doc":"Monitoring Astarte is a complex, distributed system that may pose several challenges when deployed in production. Individual services report health and metrics to ensure production clusters can be properly monitored and proactive actions can be taken in case of faults or unexpected behavior.","ref":"090-monitoring.html","title":"Monitoring","type":"extras"},{"doc":"Every Astarte service, whether it's an API service or not, exposes an HTTP endpoint /health , without versioning, on its HTTP port. By default, services use port 4000 . /health is meant to be called frequently and reports the individual health state of a service. It will return 200 in case the service is healthy, or other errors in case the service is having issues. Among those issues, there might be failure in accessing RabbitMQ/RPC communications or failure in accessing the Database. Health checks and Kubernetes The aforementioned health checks are integrated in Kubernetes, when using Astarte Operator, as LivenessProbe and ReadinessProbe . As such, health monitoring and forced restarts are automatically handled without the need for the administrator to integrate any additional logic.","ref":"090-monitoring.html#health-checks","title":"Monitoring - Health checks","type":"extras"},{"doc":"Just like /health , every service exposes a /metrics endpoint. This endpoint exposes a series of metrics in Prometheus format, which can be easily integrated and queried from any Prometheus-compatible monitoring solution. Each service, besides exposing stats on its Erlang VM, resource consumption and HTTP stats (where applicable), also exposes a number of service-specific metric, which can be queried to obtain information about Astarte's usage and behavior. Authentication and access to metrics /metrics , being Prometheus-compatible, does not implement any kind of authentication or access control. Ideally, only your scraper should have access to /metrics , as it can leak sensitive information and should not be exposed to the outer world. Astarte Operator, by default, forbids access to /metrics through its ingress, as it assumes your scraper lives within the Kubernetes cluster or has means to access the cluster on its own. However, this behavior can be overridden through by setting serveMetrics: true in the api section. An additional parameter, serveMetricsToSubnet , can be specified to restrict access to /metrics only to source IPs in a specific subnet. It is strongly recommended to set this up in case an external scraper needs to have access to /metrics , to ensure access is restricted.","ref":"090-monitoring.html#service-metrics","title":"Monitoring - Service metrics","type":"extras"},{"doc":"Advanced operations This section provides guidance on some delicate operations that must be performed manually as they could potentially result in data loss or other types of irrecoverable damage. Always be careful while performing these operations! Advanced operations are described in the following sections: Manual deletion of interfaces Manual deletion of a device How to backup your Astarte resources How to restore your backed up Astarte instance Handling Astarte when uninstalling the Operator","ref":"095-advanced-operations.html","title":"Advanced operations","type":"extras"},{"doc":"Right now, Astarte only allows deleting draft interfaces, i.e. interfaces with major version 0 and not used by any device. If you want to delete an interface that has already published data, you must proceed manually with the steps described below. This guide assumes the aim of the operation is deleting the org.astarte-platform.genericsensors.Values interface in the test realm. The guide requires that cqlsh is connected to the Cassandra/ScyllaDB instance that your Astarte instance is using. Switch to the target keyspace The keyspace has the same name of the realm, in this case it is test : cqlsh &gt; use test ; Find out the interface id cqlsh :test &gt; SELECT interface_id FROM interfaces WHERE name = &#39;org.astarte-platform.genericsensors.Values&#39; AND major_version = 1 ; cqlsh will reply with the interface id: interface_id -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- c238b244 - b90f - 4 c6d - f276 - 25768 bf6abac Delete the interface WARNING: This is a destructive step that will erase the correlation between the Interface name and internal ID. Before proceeding, ensure you saved the interface ID, or you will end up with dangling data. Further steps in this guide will require the interface ID. To delete the interface, cqlsh :test &gt; DELETE FROM interfaces WHERE name = &#39;org.astarte-platform.genericsensors.Values&#39; AND major_version = 1 ; Keep in mind that after this step, all existing devices that attempt to publish on this interface will be disconnected as soon as they try to do so. Delete interface data The interface data is stored in a different place depending on the interface type ( datastream or properties ) and aggregation. Individual datastream interfaces store their data in the individual_datastreams table. Individual properties interfaces store their data in the individual_properties table. Object datastream interfaces store their data in a dedicated table which is created starting from the interface (e.g. an interface called com.test.Sensors with major version 1 creates a com_test_sensors_v1 table in the realm keyspace). To delete data from object datastreams, a simple DROP of the table where the data is stored is needed. Deleting data from individual interfaces requires more steps. In this example the interface is an individual datastream, but the procedure for individual properties is the same, but concerns the individual_properties table instead. To delete the interface data, first all relevant primary keys must be found: cqlsh :test &gt; SELECT DISTINCT device_id , interface_id , endpoint_id , path FROM individual_datastreams WHERE interface_id = c238b244 - b90f - 4 c6d - f276 - 25768 bf6abac ALLOW FILTERING ; This will return a set of primary keys of data belonging to that interface: device_id | interface_id | endpoint_id | path -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- | -- -- -- -- -- -- - 41 c1c072 - d416 - 4686 - ba23 - 673 fe4ad926f | c238b244 - b90f - 4 c6d - f276 - 25768 bf6abac | 33751412 - 3 e77 - ad1f - ad57 - 280 cc9fad581 | / test / value 81 c60277 - 4645 - 441 f - a49b - 66 a71ce54b83 | c238b244 - b90f - 4 c6d - f276 - 25768 bf6abac | 33751412 - 3 e77 - ad1f - ad57 - 280 cc9fad581 | / foo / value ... After that, all data belonging to those primary keys must be deleted: cqlsh :test &gt; DELETE FROM individual_datastreams WHERE device_id = 41 c1c072 - d416 - 4686 - ba23 - 673 fe4ad926f AND interface_id = c238b244 - b90f - 4 c6d - f276 - 25768 bf6abac AND endpoint_id = 33751412 - 3 e77 - ad1f - ad57 - 280 cc9fad581 AND path = &#39;/test/value&#39; ; cqlsh :test &gt; DELETE FROM individual_datastreams WHERE device_id = 81 c60277 - 4645 - 441 f - a49b - 66 a71ce54b83 AND interface_id = c238b244 - b90f - 4 c6d - f276 - 25768 bf6abac AND endpoint_id = 33751412 - 3 e77 - ad1f - ad57 - 280 cc9fad581 AND path = &#39;/foo/value&#39; ; ... devices-by-interface cleanup If this guide is being used so as to remove a draft interface (i.e. with major version 0 ) that cannot be deleted since it has data on it, an additional step is required for a complete cleanup. The information about which devices are using draft interfaces is kept in the kv_store table. You can inspect the groups with: cqlsh :test &gt; SELECT group FROM kv_store ; The group that has to be deleted may be easily identified by inspecting the returned group s, since it is the one with its name derived from the interface name. For example, if the purpose of the operation is removing all data from the org.astarte-platform.genericevents.DeviceEvents v0.1 interface, the corresponding group in kv_store will be devices-by-interface-org.astarte-platform.genericevents.DeviceEvents-v0 . As the target group is identified, just remove all its entries with: cqlsh :test &gt; DELETE FROM kv_store WHERE group = &#39;devices-by-interface-org.astarte-platform.genericevents.DeviceEvents-v0&#39; ; Conclusion After performing all the steps above, the interface will be completely removed from Astarte. You can then proceed to install a new interface with the same name and major version without any conflict. Remember to remove the interface also on the device side, otherwise devices will keep getting disconnected if they try to publish on the deleted interface.","ref":"095-advanced-operations.html#manual-deletion-of-interfaces","title":"Advanced operations - Manual deletion of interfaces","type":"extras"},{"doc":"Currently, the Astarte API allows for the unregistration and the inhibition of a specific device. If you want to entirely delete a device from your realm along with its data, a manual procedure is required. This section assumes: that cqlsh is connected to the Cassandra/ScyllaDB instance that your Astarte is using; that astartectl is installed on your machine. Please keep in mind that this is a destructive procedure. Before moving on, ensure you saved your device ID or you might end up with dangling data and possibly a damaged Astarte deployment. Retrieve the device uuid To interact with the device and its data, the device uuid must be retrieved. Assuming that the id of the device to be deleted is k3oPTXaGGGGGGGGGGGGGGG , its uuid can be obtained with the following: $ astartectl utils device-id to-uuid k3oPTXaGGGGGGGGGGGGGGG 937a0f4d-7686-1861-8618-618618618618 Please, make sure not to lose the device uuid as it will be employed in all the following steps of this section. Switch to the target keyspace The keyspace takes its name from the realm, in this case it is test . cqlsh &gt; use test ; Delete device data on a specific interface Depending on the interface type and aggregation, data published by the device is stored into different tables: data published over an individual datastream interface are available within the individual_datastreams table; data published over an individual property interface are available within the individual_properties table; data published over an object datastream interfaces are stored in a dedicated table named after the interface name: e.g. an interface called com.test.Sensors with major version 1 creates a com_test_sensors_v1 table in the realm keyspace. Delete device data from an individual_datastreams interface The first step consists in finding all the relevant primary keys for the device. To do so, simply run: cqlsh :test &gt; SELECT DISTINCT device_id , interface_id , endpoint_id , path FROM individual_datastreams WHERE device_id = 937 a0f4d - 7686 - 1861 - 8618 - 618618618618 ALLOW FILTERING ; The output will show a set of primary keys of data belonging to your device: device_id | interface_id | endpoint_id | path -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- | -- -- -- -- -- -- - 937 a0f4d - 7686 - 1861 - 8618 - 618618618618 | c238b244 - b90f - 4 c6d - f276 - 25768 bf6abac | 33751412 - 3 e77 - ad1f - ad57 - 280 cc9fad581 | / test / value 937 a0f4d - 7686 - 1861 - 8618 - 618618618618 | 1 e6fb841 - 9 ee3 - 0 e60 - 72 ed - 1 f55b334b832 | 33751412 - 3 e77 - ad1f - ad57 - 280 cc9fad581 | / foo / value ... It is now time to perform the actual data deletion: to do so, repeat the following instruction iterating over every combination of primary keys as obtained from the output of the previous command: cqlsh :test &gt; DELETE FROM individual_datastreams WHERE device_id = 937 a0f4d - 7686 - 1861 - 8618 - 618618618618 AND interface_id = c238b244 - b90f - 4 c6d - f276 - 25768 bf6abac AND endpoint_id = 33751412 - 3 e77 - ad1f - ad57 - 280 cc9fad581 AND path = &#39;/test/value&#39; ; Delete device data from an individual_properties interface The first step consists in retrieving the primary keys for the device. Just run: cqlsh :test &gt; SELECT DISTINCT device_id , interface_id FROM individual_properties WHERE device_id = 937 a0f4d - 7686 - 1861 - 8618 - 618618618618 ALLOW FILTERING ; The output will be similar to the following one: device_id | interface_id -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- 937 a0f4d - 7686 - 1861 - 8618 - 618618618618 | c238b244 - b90f - 4 c6d - f276 - 25768 bf6abac 937 a0f4d - 7686 - 1861 - 8618 - 618618618618 | 8 ed086db - 0 bcc - 5 a9f - 2 fc2 - ddf49c35e87d 937 a0f4d - 7686 - 1861 - 8618 - 618618618618 | c61879ce - c60c - adaf - c6b4 - d04b1e1b14c4 To perform the actual data deletion, run the following query for each pair of device_id and interface_id obtained from the previous query: cqlsh :test &gt; DELETE FROM individual_properties WHERE device_id = 937 a0f4d - 7686 - 1861 - 8618 - 618618618618 AND interface_id = c238b244 - b90f - 4 c6d - f276 - 25768 bf6abac ; Delete device data for object datastreams The first step consists in retrieving the primary keys for the device. For this particular example the sample interface named com.test.Sensors with major version v1 is employed. Please note that the upcoming steps must be repeated for each object datastream interface installed in your realm. cqlsh :test &gt; SELECT DISTINCT device_id , path FROM com_test_sensors_v1 WHERE device_id = 937 a0f4d - 7686 - 1861 - 8618 - 618618618618 ALLOW FILTERING ; The output will show something like: device_id | path -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- + -- -- -- 937 a0f4d - 7686 - 1861 - 8618 - 618618618618 | / foo ... It is now time to perform the actual data deletion: cqlsh :test &gt; DELETE FROM com_test_sensors_v1 WHERE device_id = 937 a0f4d - 7686 - 1861 - 8618 - 618618618618 AND path = &#39;/foo&#39; ; Delete device aliases If your device has one or more aliases you will find them in the names table. First, you have to find the primary key for the device: cqlsh :test &gt; SELECT object_name FROM names WHERE object_uuid = 937 a0f4d - 7686 - 1861 - 8618 - 618618618618 ALLOW FILTERING ; If your device has any aliases, the output will show object_name -- -- -- -- -- -- -- -- my - device - alias ... Thus, you can delete the alias simply executing: cqlsh :test &gt; DELETE FROM names WHERE object_name = &#39;my-device-alias&#39; ; Delete the device from groups To delete the device from a device group let's find the needed keys: SELECT group_name , insertion_uuid , device_id FROM grouped_devices WHERE device_id = 937 a0f4d - 7686 - 1861 - 8618 - 618618618618 ALLOW FILTERING ; If the device is contained in one or more groups, the output will be: group_name | insertion_uuid | device_id -- -- -- -- -- -- + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- + -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- my - group | c1a0dade - 43 bc - 11 ec - 95 be - 41 f7663270b3 | 937 a0f4d - 7686 - 1861 - 8618 - 618618618618 ... The actual deletion can be performed with: cqlsh :test &gt; DELETE FROM grouped_devices WHERE group_name = &#39;my-group&#39; AND insertion_uuid = c1a0dade - 43 bc - 11 ec - 95 be - 41 f7663270b3 AND device_id = 937 a0f4d - 7686 - 1861 - 8618 - 618618618618 ; Delete entries from kv_store If your device is publishing over one or more interfaces with version v0 , you will need to handle also the kv_store table. Retrieve all the entries that must be handled: cqlsh :test &gt; SELECT group , key FROM kv_store WHERE key = &#39;k3oPTXaGGGGGGGGGGGGGGG&#39; ALLOW FILTERING ; The output of the query will show something similar to group | key -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- - + -- -- -- -- -- -- -- -- -- -- -- -- devices - by - interface - com . test . Sensor - v0 | k3oPTXaGGGGGGGGGGGGGGG devices - with - data - on - interface - com . test . Sensor - v0 | k3oPTXaGGGGGGGGGGGGGGG ... To remove the entries, simply execute the following queries to remove the proper rows from the table. Please, make sure to remove all the entries referencing your device ID. cqlsh :test &gt; DELETE FROM kv_store WHERE group = &#39;devices-by-interface-com.test.Sensor-v0&#39; AND key = &#39;k3oPTXaGGGGGGGGGGGGGGG&#39; ; cqlsh :test &gt; DELETE FROM kv_store WHERE group = &#39;devices-with-data-on-interface-com.test.Sensor-v0&#39; AND key = &#39;k3oPTXaGGGGGGGGGGGGGGG&#39; ; Eventually delete your device Deleting your device from the devices table is as simple as cqlsh :test &gt; DELETE FROM devices WHERE device_id = 937 a0f4d - 7686 - 1861 - 8618 - 618618618618 ; Conclusions If you managed to remove all the device-related entries as described in the previous sections, then your device and its data have been properly deleted from Astarte. Before trying to reconnect your device you must make sure that the SSL certificate and all the credentials onboard your device are deleted. This is crucial for ensuring that new data published by the device can be properly ingested and processed by Astarte.","ref":"095-advanced-operations.html#manual-deletion-of-a-device","title":"Advanced operations - Manual deletion of a device","type":"extras"},{"doc":"Backing up your Astarte resources is crucial in all those cases when your Astarte instance has to be restored after an unforeseen event (e.g. accidental deletion of resources, deletion of the Operator - as it will be discussed later on - etc.). A full recovery of your Astarte instance along with all the persisted data is possible if and only if your Cassandra/Scylla instance is deployed independently from Astarte, i.e. it must be deployed outside of the Astarte CR scope. Provided that this condition is met, all the data persist in the database even when Astarte is deleted from your cluster. To restore your Astarte instance all you have to do is saving the following resources: Astarte CR; AstarteVoyagerIngress CR (if deployed); AstarteDefaultIngress CR (if deployed); CA certificate and key; and, assuming that the name of your Astarte is astarte and that it is deployed within the astarte namespace, it can be done simply executing the following commands: kubectl get astarte -n astarte -o yaml &gt; astarte-backup.yaml kubectl get avi -n astarte -o yaml &gt; avi-backup.yaml kubectl get adi -n astarte -o yaml &gt; adi-backup.yaml kubectl get secret astarte-devices-ca -n astarte -o yaml &gt; astarte-devices-ca-backup.yaml","ref":"095-advanced-operations.html#backup-your-astarte-resources","title":"Advanced operations - Backup your Astarte resources","type":"extras"},{"doc":"To restore your Astarte instance simply apply the resources you saved as described here . Please, be aware that the order of the operations matters. kubectl apply -f astarte-devices-ca-backup.yaml kubectl apply -f astarte-backup.yaml And when your Astarte resource is ready, to restore your AstarteVoyagerIngress: kubectl apply -f avi-backup.yaml while to restore your AstarteDefaultIngress resource: kubectl apply -f adi-backup.yaml At the end of this step, your cluster is restored. Please, notice that the external IP of the ingress services might have changed. Take action to ensure that the changes of the IP are reflected anywhere appropriate in your deployment.","ref":"095-advanced-operations.html#restore-your-backed-up-astarte-instance","title":"Advanced operations - Restore your backed up Astarte instance","type":"extras"},{"doc":"Installing the Astarte Operator is as simple as installing its Helm chart. Even if the install and upgrade procedures are very simple and straightforward, the design choices behind the development of the Operator must be taken into account to avoid undesired effects while handling the Operator's lifecycle. The installation of the Operator's Helm chart is responsible for the creation of RBACs, the creation of the Operator's deployment and the installation of Astarte CRDs. The fact that all the CRDs installed with the Helm chart are templated has some important consequences: if on one hand this characteristic ensures great flexibility in configuring your Astarte instance, on the other hand it entails the possibility of deleting the CRDs by simply uninstalling the Operator. The following sections will highlight what happens under the hood while uninstalling the Operator and show the suggested path to restore your Astarte instance after the removal of the Operator. Please, read carefully the following sections before taking any actions on your cluster and be aware that improper operations may have catastrophic effects on your Astarte instance. What happens when uninstalling the Operator The Operator's installation procedure marks all the Astarte CRDs as owned by the Operator itself. Therefore, when the Operator is uninstalled all the CRDs are seen as orphaned and the Kubernetes controller automatically sets them as ready to be deleted. Thus, when the Operator is uninstalled you end up with the following situation: Flow and AstarteVoyagerIngress CRDs are deleted, along with the custom resources depending on said CRDs; Astarte CRD is marked for deletion, but its removal is postponed until the moment in which the Astarte finalizer is executed. Backup your resources Even if removing the Operator can potentially destroy your Astarte instance, there is a way to restore it avoiding any data loss. Please, refer to this dedicated section to understand how to backup your resources. Uninstall the Operator Once the backup of your resources is completed you can helm uninstall the Operator as explained here . Once the Operator is deleted your Astarte instance will be marked for deletion. You can see it simply checking the Deletion timestamp field in the output of: kubectl describe astarte -n astarte Reinstalling the Operator Reinstalling the Operator is crucial to have a correct management of your Astarte instance. The installation is handled simply with an helm install command as explained here . When the first reconciliation loop is executed, the Operator becomes aware that the Astarte resource is marked for deletion, so it executes the Astarte finalizer and eventually destroys Astarte's CRD and its resources. Even if it might look like the status of the cluster is compromised, a simple command reestablishes order: helm upgrade --install astarte-operator astarte/astarte-operator -n kube-system This command simply upgrades the Operator and, as a result, installs the missing CRDs. Now it is time to restore the Astarte resources. Apply backed up resources To restore your Astarte instance simply follow the instructions outlined here . Conclusion The procedure presented in the current section allows to handle the deletion of the Operator from your cluster without losing any of Astarte's data. Currently some manual intervention is required to ensure that the integrity of your instance is not compromised by the uninstall procedure.","ref":"095-advanced-operations.html#handling-astarte-when-uninstalling-the-operator","title":"Advanced operations - Handling Astarte when uninstalling the Operator","type":"extras"},{"doc":"Upgrade Procedures The procedure for upgrading Astarte and Astarte Operator depends on the version you want to upgrade from: to upgrade from v0.10 to v0.11, click here to upgrade from v0.11 to v1.0, click here to upgrade from v1.0.0 to v1.0.x, click here","ref":"000-upgrade_index.html","title":"Upgrade Procedures","type":"extras"},{"doc":"Upgrade v0.10-v0.11 The upgrade procedure for both Astarte and Astarte Operator v0.10 is handled by astartectl , which is the tool to be employed to upgrade from v0.10 to v0.11 .","ref":"010-upgrade_010_011.html","title":"Upgrade v0.10-v0.11","type":"extras"},{"doc":"To upgrade the Operator, use the dedicated upgrade-operator command: astartectl cluster upgrade-operator This command upgrades the Operator to the last v0.11.x version available. However, for specific and non-standard use cases, the --version switch is provided to allow the user to specify the version to upgrade to. We highly encourage you to follow the standard approach and to land to the last v0.11.x version available.","ref":"010-upgrade_010_011.html#upgrade-astarte-operator","title":"Upgrade v0.10-v0.11 - Upgrade Astarte Operator","type":"extras"},{"doc":"To upgrade Astarte use the dedicated command: astartectl cluster instances upgrade &lt;your-astarte-release-name&gt; The command upgrades your Astarte instance to the last 0.11.x version available. The Astarte version to upgrade to can be set by the user. Please, see astartectl cluster instances upgrade --help for further details. Unless you have specific reasons, it is highly recommended upgrading Astarte to the last 0.11 version available.","ref":"010-upgrade_010_011.html#upgrade-astarte","title":"Upgrade v0.10-v0.11 - Upgrade Astarte","type":"extras"},{"doc":"Upgrade v0.11-v1.0","ref":"020-upgrade_011_10.html","title":"Upgrade v0.11-v1.0","type":"extras"},{"doc":"The upgrade procedure from v0.11 to v1.0 requires some manual intervention as the deployment and handling of the Operator's lifecycle has changed: if v0.11 is entirely handled with astartectl , v1.0 employs Helm charts. Helm is intended to be used as the operator's lifecycle management tool, thus make sure you are ready with a working Helm installation . Migrate CA certificate and key Currently you have to manually migrate the CA certificate and private key to the new installation. This is critical since the devices in your realm have certificates signed with those CA credentials, and if the CA certificate changes all devices will have invalid credentials and will have to request new credentials. tar must be installed onto your machine in order to successfully complete this step. Export the following enviroment variables and ensure they matches the name of the corresponding components within your cluster: ASTARTE_RELEASE_NAME : the name of the Astarte instance deployed in your cluster, ASTARTE_RELEASE_NAMESPACE : the namespace in which your Astarte instance resides. For instance, if you followed the standard naming conventions while installing Astarte it should be sufficient setting the following values: export ASTARTE_RELEASE_NAME=astarte export ASTARTE_RELEASE_NAMESPACE=astarte However, it is your responsibility checking that these values match the ones of your cluster . Now, migrate the CA certificates and key: kubectl cp $ASTARTE_RELEASE_NAMESPACE/$ASTARTE_RELEASE_NAME-cfssl-0:/data/ca-key.pem tls.key kubectl cp $ASTARTE_RELEASE_NAMESPACE/$ASTARTE_RELEASE_NAME-cfssl-0:/data/ca.pem tls.crt kubectl create secret tls $ASTARTE_RELEASE_NAME-devices-ca -n $ASTARTE_RELEASE_NAMESPACE \\ --cert=tls.crt --key=tls.key Remove Astarte Operator v0.11 Remove the Operator's Service Account, Cluster Roles and Cluster Role Bindings: kubectl delete serviceaccounts -n kube-system astarte-operator kubectl delete clusterroles.rbac.authorization.k8s.io astarte-operator kubectl delete clusterrolebindings.rbac.authorization.k8s.io astarte-operator Delete the Operator's deployment: kubectl delete deployments.app -n kube-system astarte-operator DO NOT delete Astarte's CRDs! This will lead to the deletion of the entire Astarte deployment with a consequent data loss. Install cert-manager Please, before proceeding to the next steps make sure to be compliant with the new requirements for v1.0 , i.e. if cert-manager is not installed yet, run the following commands: helm repo add jetstack https://charts.jetstack.io helm repo update kubectl create namespace cert-manager helm install \\ cert-manager jetstack/cert-manager \\ --namespace cert-manager \\ --version v1.7.0 \\ --set installCRDs=true Add Astarte Operator's Helm Chart Repository To restore the Operator's functionalities with v1.0, the first step is adding the Astarte Operator's Helm chart repository: helm repo add astarte https://helm.astarte-platform.org helm repo update Prepare the Cluster to the Operator v1.0 Installation Set some environment variables that will come handy for the upcoming migration procedure: ASTARTE_OP_TEMPLATE_DIR is the target directory in which the chart templates will be generated, ASTARTE_OP_RELEASE_NAME is the name of the Astarte Operator deployment, ASTARTE_OP_RELEASE_NAMESPACE is the namespace in which the Astarte Operator will reside. You can change the following values at your preference. However, the following values should be ok for the large majority of use cases. Note that you are responsible for checking that ASTARTE_OP_RELEASE_NAMESPACE exists within the cluster. export ASTARTE_OP_TEMPLATE_DIR=/tmp export ASTARTE_OP_RELEASE_NAME=astarte-operator export ASTARTE_OP_RELEASE_NAMESPACE=kube-system Generate the Helm templates with the following: helm template $ASTARTE_OP_RELEASE_NAME astarte/astarte-operator \\ --namespace $ASTARTE_OP_RELEASE_NAMESPACE \\ --output-dir $ASTARTE_OP_TEMPLATE_DIR The outcome of this command consists of a series of yaml files located in $ASTARTE_OP_TEMPLATE_DIR/astarte-operator/templates . Leveraging the templating capabilities of Helm, the generated templates can be customized according to your needs. For instance, if you want to refer to a particular Operator's tag all you have to do is to append --set image.tag=&lt;the-required-tag&gt; to the previous command. To check all the configurable values run helm show values astarte/astarte-operator . Before moving on, make sure that gawk is installed on your host machine. If you are on OSX, running the following command will be sufficient: $ brew install gawk while on any Debian based OS run: # apt install gawk Now it's time to prepare the cluster to allow the new operator installation by means of the templates generated in the previous step. The following tasks will be performed: replacement of the Astarte's and AstarteVoyagerIngress' CRDs with their updated versions, installation of the Flow's CRD, installation of the Operator's RBACs, installation of the Operator's Webhooks, annotation of the installed resources as to allow Helm to manipulate and take control of them. This bash script takes care of handling the aforementioned tasks. Download it and, assuming you saved it as upgrade-operator-011-10.sh , run the following: bash path/to/your/upgrade-operator-011-10.sh \\ -d $ASTARTE_OP_TEMPLATE_DIR \\ -n $ASTARTE_OP_RELEASE_NAME \\ -N $ASTARTE_OP_RELEASE_NAMESPACE In a more concise way you can perform the same task simply executing: ASTARTE_OP_UPGRADE_SCRIPT_URL=https://raw.githubusercontent.com/astarte-platform/astarte-kubernetes-operator/master/hack/upgrade-operator-011-10.sh curl -fsSL $ASTARTE_OP_UPGRADE_SCRIPT_URL &gt; /tmp/upgrade-operator-011-10.sh bash /tmp/upgrade-operator-011-10.sh \\ -d $ASTARTE_OP_TEMPLATE_DIR \\ -n $ASTARTE_OP_RELEASE_NAME \\ -N $ASTARTE_OP_RELEASE_NAMESPACE Install Astarte Operator v1.0 Now it's time to install the Astarte Operator v1.0. If during the preparation of the cluster you customized the chart values with the --set flag, please take care of setting the same values accordingly while installing Astarte Operator. To install the Operator, simply run: helm install $ASTARTE_OP_RELEASE_NAME astarte/astarte-operator -n $ASTARTE_OP_RELEASE_NAMESPACE \\ --skip-crds Note that the --skip-crds flag is required as, following the migration path, we already updated/installed the required CRDs. Version 1.0.0 is a safe landing version to perform the upgrade to. Upgrading to a more recent version may lead to a broken state with possible catastrophic aftermaths: if you choose to follow this path, make sure you know what you are doing. However deviating from the upgrade path outlined within the current page is strongly discouraged. After the successful migration to v1.0, please upgrade to a more recent Operator's versions following the instructions outlined in the Upgrade Operator v1.0.0-v1.0.x section. Caveats and Breaking Changes v0.11-v1.0 Operator v1.0 introduced some breaking changes with respect to v0.11, which are relevant if you deployed your own Ingress instead of relying on AstarteVoyagerIngress . With the upgrade to v1.0, some of the services were renamed: $ASTARTE_RELEASE_NAME-appengine --&gt; $ASTARTE_RELEASE_NAME-appengine-api $ASTARTE_RELEASE_NAME-housekeeping --&gt; $ASTARTE_RELEASE_NAME-housekeeping-api $ASTARTE_RELEASE_NAME-pairing --&gt; $ASTARTE_RELEASE_NAME-pairing-api $ASTARTE_RELEASE_NAME-realm-management --&gt; $ASTARTE_RELEASE_NAME-realm-management-api If you deployed your own Ingress, it is your responsibility renaming your services to ensure the cluster to be fully operational.","ref":"020-upgrade_011_10.html#upgrade-astarte-operator","title":"Upgrade v0.11-v1.0 - Upgrade Astarte Operator","type":"extras"},{"doc":"Once you migrated Astarte Operator from v0.11 to v1.0, it is time to upgrade your Astarte instance. To do so, simply edit the Astarte resource in the cluster updating the version field to the one you want to upgrate to. Open the yaml file describing the Astarte resource with: kubectl edit astarte -n astarte Find the version field in the Astarte Spec section and change it according to your needs. Once the yaml file will be saved, the Operator will take over ensuring the reconciliation of your Astarte instance to the requested version. Caveats CFSSL leftover persistent volume Astarte v0.11 employs a persistent volume to store CA certificate and private key, while upgrading to v1.0 involves a change in how device certificates are stored as, behind the scenes, these data are held as a Kubernetes TLS secret. Following the Kubernetes conventions, the formerly used persistent volume and its corresponding claim are left within the cluster even if not used anymore. If you followed the procedure described here you are free to remove the CFSSL persistent volume and claim without the need for your devices to request new credentials. AppEngine /socket route removal The /socket endpoint exposed by AppEngine to interact with Astarte Channels, which was already deprecated in Astarte v0.11, has been removed. You must use the new route /v1/socket instead.","ref":"020-upgrade_011_10.html#upgrade-astarte","title":"Upgrade v0.11-v1.0 - Upgrade Astarte","type":"extras"},{"doc":"Upgrade v1.0.0-v1.0.x The current section describes the required steps to upgrade your Astarte instance from v1.0.0 to v1.0.x . Currently, the last released patch version is v1.0.4 and, as such, the remainder of this page will refer to this version. The described upgrade path involves some heavy changes as a consequence of this Voyager announcement and the following Astarte design choice . Before moving on, it must be clear that AstarteVoyagerIngress is deprecated and that the only supported managed ingress is the AstarteDefaultIngress . The upcoming sections will cover the following topics: upgrading the Astarte Operator, upgrading the Astarte instance to allow for TLS termination at VerneMQ level, deployment of the AstarteDefaultIngress in place of the deprecated AstarteVoyagerIngress . Before starting with the upgrade procedure it is strongly advised to backup your Astarte resources .","ref":"030-upgrade_100_10x.html","title":"Upgrade v1.0.0-v1.0.x","type":"extras"},{"doc":"Astarte Operator's upgrade procedure is handled by Helm. However, according to the Helm policies, upgrading the CRDs must be handled manually. The current section assumes that the Operator's chart landing version is v1.0.4 . If a more recent chart version is available, it is your responsibility referencing to the v1.0.4 chart using the --version flag when running helm commands. To upgrade the Astarte CRDs, the following environment variables will be employed: ASTARTE_OP_TEMPLATE_DIR is the target directory in which the chart templates will be generated, ASTARTE_OP_RELEASE_NAME is the name of the Astarte Operator deployment, ASTARTE_OP_RELEASE_NAMESPACE is the namespace in which the Astarte Operator resides. Please, make sure that the values you set for both the Operator's name and namespace match the naming you already adopted when installing the Operator. A wrong naming can lead to a malfunctioning Astarte cluster. For standard deployments the following variables should be ok. However, it is your responsibility checking that the values you set are consistent with your setup: export ASTARTE_OP_TEMPLATE_DIR=/tmp export ASTARTE_OP_RELEASE_NAME=astarte-operator export ASTARTE_OP_RELEASE_NAMESPACE=kube-system Update your local Helm charts: $ helm repo update Render the Helm templates with the following: helm template $ASTARTE_OP_RELEASE_NAME astarte/astarte-operator \\ --namespace $ASTARTE_OP_RELEASE_NAMESPACE \\ --output-dir $ASTARTE_OP_TEMPLATE_DIR After these steps you will find the updated CRDs within $ASTARTE_OP_TEMPLATE_DIR/$ASTARTE_OP_RELEASE_NAME/templates/crds.yaml . Update the CRDs in your cluster by replacing the CRDs yaml file: kubectl replace -f $ASTARTE_OP_TEMPLATE_DIR/$ASTARTE_OP_RELEASE_NAME/templates/crds.yaml The previous command will raise an error saying customresourcedefinitions.apiextensions.k8s.io &quot;astartedefaultingresses.ingress.astarte-platform.org&quot; not found . It is nothing to worry about: under the hood the replace command has updated the CRDs for Astarte, AstarteVoyagerIngress and Flow, while it cannot replace the AstarteDefaultIngress CRD as it is not installed yet. This issue is easily fixed with the next command. To upgrade the Operator use the dedicated helm upgrade command: helm upgrade astarte-operator astarte/astarte-operator -n kube-system The optional --version switch allows to specify the version to upgrade to - when not specified, the latest version will be fetched and used. If you choose to upgrade to a specific version of the chart by using the --version flag, please make sure to generate the updated CRDs template using the same chart version. By design, Astarte Operator's Helm charts cannot univocally be mapped to Operator's releases in a one-to-one relationship. However each chart is tied to a specific Operator's version, which is user configurable. Therefore, upgrading a chart leads to an Operator's upgrade if and only if the Operator's tag referenced by the chart is changed. You can check the Operator's tag bound to the chart simply running: helm show values astarte/astarte-operator As usual, you can use the usual --version flag to point to a specific chart version.","ref":"030-upgrade_100_10x.html#upgrade-astarte-operator","title":"Upgrade v1.0.0-v1.0.x - Upgrade Astarte Operator","type":"extras"},{"doc":"To upgrade your Astarte instance simply edit the Astarte resource in the cluster updating the version field to the one you want to upgrade to. In order to properly expose your Astarte instance to the outer world through the AstarteDefaultIngress a configuration change for VerneMQ is required: in particular, TLS termination must be handled at VerneMQ level. Open the yaml file describing the Astarte resource with: kubectl edit astarte -n astarte Find the version field in the Astarte Spec section and change it according to your needs (i.e.: set it to 1.0.4 ). Moreover, in the vernemq configuration section two new fields must be added, namely sslListener and sslListenerCertSecretName : the first field is a boolean that, when true, set VerneMQ to handle TLS termination, while the latter set the secret containing the TLS certificate (further details on certificates can be found here ). To summarize, the needed changes will look like the following sample snippet: apiVersion: api.astarte-platform.org/v1alpha2 kind: Astarte ... spec: ... vernemq: sslListener: true sslListenerCertSecretName: &lt;your-tls-secret-name&gt; ... version: 1.0.4 Once the yaml file is applied, the Operator will take over ensuring the reconciliation of your Astarte instance. Caveats for Astarte Flow Currently, although Astarte Flow is a component of Astarte, it doesn't follow Astarte's release cycle. Therefore if you upgraded your Astarte instance to v1.0.4, Astarte Operator will try to deploy astarte/astarte_flow:1.0.4 which is currently not existent. All you have to do to overcome this temporary limitation is to edit your Astarte resource by explicitly setting the Astarte Flow image you plan to use: spec: ... components: ... flow: image: &lt;the-astarte-flow-image&gt; All the available Astarte Flow's tags can be found here .","ref":"030-upgrade_100_10x.html#upgrade-astarte","title":"Upgrade v1.0.0-v1.0.x - Upgrade Astarte","type":"extras"},{"doc":"The current section describes the procedure for replacing the deprecated AstarteVoyagerIngress with the new AstarteDefaultIngress . If the Voyager ingress is not deployed within your cluster, feel free to skip this section. The advised migration path involves the employment of astartectl : this is the most straightforward way of performing the migration task and, as soon as all the requirements are satisfied, it requires the execution of one single command. The Migrating to the AstarteDefaultIngress page extensively cover this topic.","ref":"030-upgrade_100_10x.html#deploy-astartedefaultingress-in-place-of-astartevoyageringress","title":"Upgrade v1.0.0-v1.0.x - Deploy AstarteDefaultIngress in place of AstarteVoyagerIngress","type":"extras"},{"doc":"Astarte in 5 minutes This documentation page describes a development version, for production systems please use the stable version instead. This tutorial will guide you through bringing up your Astarte instance, creating a realm and streaming your first data from a device simulator (or a real device) before your cup of tea is ready.","ref":"010-astarte_in_5_minutes.html","title":"Astarte in 5 minutes","type":"extras"},{"doc":"First of all, please keep in mind that this setup is not meant to be used in production : by default, no persistence is involved, the installation does not have any recovery mechanism, and you will have to restart services manually in case something goes awry. This guide is great if you want to take Astarte for a spin, or if you want to use an isolated instance for development. You will need a machine with at least 4GB of RAM, a recent 64-bit operating system with Docker , Docker Compose and astartectl installed. If you don't have astartectl installed on your machine yet, you should install it by following the instructions in astartectl's README Also, on the machine(s) or device(s) you will use as a client, you will need either Docker, or a Qt5 installation with development components if you wish to build and run components locally. Due to ScyllaDB requirements, if you're working on a Linux machine you should make sure that aio-max-nr is at least 1048576 : cat /proc/sys/fs/aio-max-nr 1048576 If it's less than that, you'll need to edit your /etc/sysctl.conf file fs . aio - max - nr = 1048576 and to persist this configuration sudo sysctl -p","ref":"010-astarte_in_5_minutes.html#before-you-begin","title":"Astarte in 5 minutes - Before you begin","type":"extras"},{"doc":"Docker version &gt;= 19 is recommended: $ docker -v Docker version 19.03.8 Docker compose version &gt;= 1.17 is recommended: $ docker-compose -v docker compose version 1.17.1, build unknown astartectl 1.0.x is recommended: $ astartectl version astartectl 1.1.0-dev This procedure has been tested on several systems, and is validated and maintained against Ubuntu 18.04 and macOS 10.15 Catalina, but any other modern operating system should work.","ref":"010-astarte_in_5_minutes.html#checking-prerequistes","title":"Astarte in 5 minutes - Checking prerequistes","type":"extras"},{"doc":"To get our Astarte instance running as fast as possible, we will install Astarte's standalone distribution. It includes a tunable Docker Compose which brings up Astarte and every companion service needed for it to work. To do so, simply clone Astarte's main repository and use its scripts to bring it up: $ git clone https://github.com/astarte-platform/astarte.git &amp;&amp; cd astarte $ docker run -v $(pwd)/compose:/compose astarte/docker-compose-initializer:1.0.0 $ docker-compose up -d docker-compose-initializer will generate a root CA for devices, a key pair for Housekeeping, and a self-signed certificate for the broker (note: this is a really bad idea in production). You can tune the compose file further to use legitimate certificates and custom keys, but this is out of the scope of this tutorial. Compose might take some time to bring everything up, but usually within a minute from the containers creation Astarte will be ready. Compose will forward the following ports to your machine: 4000 : Realm Management API 4001 : Housekeeping API 4002 : AppEngine API 4003 : Pairing API 4040 : Dashboard 8883 : MQTTS 1885 : MQTT with Proxy Protocol for SSL termination (won't be used) 80 : Let's Encrypt verification (won't be used) This example won't use Let's Encrypt with VerneMQ - in case binding to port 80 is a problem to you, you can comment it out in docker-compose.yml without affecting any functionality. To check everything went fine, use docker ps to verify relevant containers are up: Astarte itself, VerneMQ, PostgreSQL (used by CFSSL), CFSSL, RabbitMQ and ScyllaDB should be now running on your system. If any of them isn't up and running, docker ps -a should show it stopped or failed. In those cases, it is advised to issue docker-compose up -d again to fix potential temporary failures.","ref":"010-astarte_in_5_minutes.html#install-astarte","title":"Astarte in 5 minutes - Install Astarte","type":"extras"},{"doc":"Now that we have our instance up and running, we can start setting up a Realm for our device. We'll call our Realm test . Given we have no SSO or Authentication mechanism set up, we're just going to generate a public key to sign our JWTs with. You can create one with astartectl : $ astartectl utils gen-keypair test Also, we will need a JWT token to authenticate against Housekeeping. generate-compose-files.sh created a keypair automatically, which is in compose/astarte-keys/housekeeping_{private,public}.pem . To perform all of our Astarte interactions, we will use astartectl . Use astartectl to create a new Realm: $ astartectl housekeeping realms create test --housekeeping-url http://localhost:4001/ --realm-public-key test_public.pem -k compose/astarte-keys/housekeeping_private.pem This creates a test realm, which should be ready to be used almost immediately. To ensure your realm is available and ready, check if it exists in Astarte by issuing: $ astartectl housekeeping realms ls --housekeeping-url http://localhost:4001/ -k compose/astarte-keys/housekeeping_private.pem","ref":"010-astarte_in_5_minutes.html#create-a-realm","title":"Astarte in 5 minutes - Create a Realm","type":"extras"},{"doc":"We will use Astarte's Qt5 Stream Generator to feed data into Astarte. However before starting, we will have to install org.astarte-platform.genericsensors.Values interface into our new realm. To do that, we can use astartectl again: $ astartectl realm-management interfaces install standard-interfaces/org.astarte-platform.genericsensors.Values.json --realm-management-url http://localhost:4000/ -r test -k test_private.pem Now org.astarte-platform.genericsensors.Values should show up among our available interfaces: $ astartectl realm-management interfaces ls --realm-management-url http://localhost:4000/ -r test -k test_private.pem Our Astarte instance is now ready for our devices.","ref":"010-astarte_in_5_minutes.html#install-an-interface","title":"Astarte in 5 minutes - Install an interface","type":"extras"},{"doc":"We will also test Astarte's push capabilities with a trigger. This will send a POST to a URL of our choice every time the value generated by stream_test is above 0.6. Due to how triggers work, it is fundamental to install the trigger before a device connects. Doing otherwise will cause the trigger to kick in at a later time, and as such no events will be streamed for a while. Replace $TRIGGER_TARGET_URL with your target URL in the example below, you can use a Postbin service like Mailgun Postbin to generate a URL and see the POST requests. The resulting trigger would be: { &quot;name&quot;: &quot;my_trigger&quot;, &quot;action&quot;: { &quot;http_url&quot;: &quot;$TRIGGER_TARGET_URL&quot;, &quot;http_method&quot;: &quot;post&quot; }, &quot;simple_triggers&quot;: [ { &quot;type&quot;: &quot;data_trigger&quot;, &quot;on&quot;: &quot;incoming_data&quot;, &quot;interface_name&quot;: &quot;org.astarte-platform.genericsensors.Values&quot;, &quot;interface_major&quot;: 1, &quot;match_path&quot;: &quot;/streamTest/value&quot;, &quot;value_match_operator&quot;: &quot;&gt;&quot;, &quot;known_value&quot;: 0.6 } ] } Replace $TRIGGER_TARGET_URL with the URL your Trigger will target. Assuming you saved this as my_trigger.json , you can now install it through astartectl : $ astartectl realm-management triggers install my_trigger.json --realm-management-url http://localhost:4000/ -r test -k test_private.pem You can now check that your trigger is correctly installed: $ astartectl realm-management triggers ls --realm-management-url http://localhost:4000/ -r test -k test_private.pem","ref":"010-astarte_in_5_minutes.html#install-a-trigger","title":"Astarte in 5 minutes - Install a trigger","type":"extras"},{"doc":"If you already have an Astarte compliant device, you can configure it and connect it straight away, and it will just work with your new installation - provided you skip SSL checks on the broker's certificate. If you don't, you can use Astarte's stream-qt5-test to emulate an Astarte device and generate a datastream . You can do this either on the same machine where you are running Astarte, or from another machine or device on the same network. Using a container for stream-qt5-test Astarte's stream-qt5-test can be pulled from Docker Hub with: $ docker pull astarte/astarte-stream-qt5-test:snapshot Its most basic invocation (from your astarte repository tree) is: $ docker run --net=&quot;host&quot; -e &quot;DEVICE_ID=$(astartectl utils device-id generate-random)&quot; -e &quot;PAIRING_HOST=http://localhost:4003&quot; -e &quot;REALM=test&quot; -e &quot;AGENT_KEY=$(astartectl utils gen-jwt pairing -k test_private.pem)&quot; -e &quot;IGNORE_SSL_ERRORS=true&quot; astarte/astarte-stream-qt5-test:snapshot This will generate a random datastream from a brand new, random Device ID. You can tweak those parameters to whatever suits you better by having a look at the Dockerfile. You can spawn any number of instances you like, or you can have the same Device ID send longer streams of data by saving the container's persistency through a Docker Volume. If you wish to do so, simply add -v /persistency:&lt;your persistency path&gt; to your docker run invocation. Refer to stream-qt5-test README for more details on which variables can be passed to the container. Also, please note that the --net=&quot;host&quot; parameter is required to make localhost work. If this is not desirable, you can change PAIRING_HOST to an host reachable from within the container network. Obviously, that parameter isn't required if you're running the container on a different machine and PAIRING_HOST is pointing to a different URL.","ref":"010-astarte_in_5_minutes.html#stream-data","title":"Astarte in 5 minutes - Stream data","type":"extras"},{"doc":"Congratulations! Your devices or fake devices are now communicating with Astarte, and your tea should be ready by now. You can check if everything is working out by invoking AppEngine APIs to get some values. In case you are using stream-qt5-test , you can get the last sent value with astartectl : $ astartectl appengine devices get-samples &lt;your device id&gt; org.astarte-platform.genericsensors.Values /streamTest/value --count 1 --appengine-url http://localhost:4002 -r test -k test_private.pem If you get a meaningful value, congratulations - you have a working Astarte installation with your first datastream coming in! Moreover, Astarte's Docker Compose also installs Astarte Dashboard , from which you can manage your Realms and install Triggers, Interfaces and more from a Web UI. It is accessible by default at http://localhost:4040/ - remember that if you are not exposing Astarte from localhost , you have to change Realm Management API's URL in Dashboard's configuration file, to be found in compose/astarte-dashboard/config.json in Astarte's repository. You can generate a token for Astarte Dashboard, as usual, through astartectl utils gen-jwt all-realm-apis -k test_private.pem . By default, astartectl will generate a token valid for 8 hours, but you can set a specific expiration by using the -e &lt;seconds&gt; parameter. From here on, you can use all of Astarte's APIs and features from your own installation. You can add devices, experiment with interfaces, or develop your own applications on top of Astarte's triggers or AppEngine's APIs. And have a lot of fun!","ref":"010-astarte_in_5_minutes.html#grab-your-tea","title":"Astarte in 5 minutes - Grab your tea","type":"extras"},{"doc":"When you're done with your tests and developments, you can use docker-compose again to tear down your Astarte instance simply by issuing: $ docker-compose down Unless you add the -v option, persistencies will be kept and next time you will docker-compose up the cluster will come back in the very same state you left it last time. docker-compose down -v is extremely useful during development, especially if you want a clean slate for testing your applications or your routines every time.","ref":"010-astarte_in_5_minutes.html#cleaning-up","title":"Astarte in 5 minutes - Cleaning up","type":"extras"},{"doc":"Running Astarte through docker-compose is the fastest way for going from zero to hero. However, please keep in mind this setup is unlikely to hold for long in production, and is by design broken for large installations . We can't stop you from running such a thing in production, but do so as long as you know you voided your warranty by doing so. This method is great for development and for trying out the system. If you wish to deploy Astarte in a more robust environment, have a look at Astarte Enterprise or, if you want to go the DIY way, make sure that at least every service which requires persistency has reliable storage and adequate redundancy beneath it.","ref":"010-astarte_in_5_minutes.html#final-notes","title":"Astarte in 5 minutes - Final notes","type":"extras"},{"doc":"Introduction Astarte's APIs are documented through Swagger . Your Astarte installation probably already has Swagger UI support, which serves as the reference for your installed APIs. To browse API documentation online, follow this link .","ref":"001-intro_api.html","title":"Introduction","type":"extras"}]