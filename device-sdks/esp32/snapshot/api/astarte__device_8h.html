<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Astarte Device SDK ESP32: /home/runner/work/astarte-device-sdk-esp32/astarte-device-sdk-esp32/astarte-device-sdk-esp32/include/astarte_device.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Astarte Device SDK ESP32
   </div>
   <div id="projectbrief">ESP32 device SDK for the Astarte platform</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('astarte__device_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">astarte_device.h File Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Astarte device SDK high level API.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="astarte_8h_source.html">astarte.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="astarte__bson__deserializer_8h_source.html">astarte_bson_deserializer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="astarte__interface_8h_source.html">astarte_interface.h</a>&quot;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for astarte_device.h:</div>
<div class="dyncontent">
<div class="center"><img src="astarte__device_8h__incl.png" border="0" usemap="#a_2home_2runner_2work_2astarte-device-sdk-esp32_2astarte-device-sdk-esp32_2astarte-device-sdk-esp32_2include_2astarte__device_8h" alt=""/></div>
</div>
</div>
<p><a href="astarte__device_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structastarte__device__data__event__t.html">astarte_device_data_event_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structastarte__device__unset__event__t.html">astarte_device_unset_event_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structastarte__device__connection__event__t.html">astarte_device_connection_event_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structastarte__device__disconnection__event__t.html">astarte_device_disconnection_event_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structastarte__device__config__t.html">astarte_device_config_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ab045a849a750a034a244f07347038050" id="r_ab045a849a750a034a244f07347038050"><td class="memItemLeft" align="right" valign="top"><a id="ab045a849a750a034a244f07347038050" name="ab045a849a750a034a244f07347038050"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>ASTARTE_INVALID_TIMESTAMP</b>&#160;&#160;&#160;0</td></tr>
<tr class="separator:ab045a849a750a034a244f07347038050"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a8e6066c46bfa43d8aa10dac5bc5d16ea" id="r_a8e6066c46bfa43d8aa10dac5bc5d16ea"><td class="memItemLeft" align="right" valign="top"><a id="a8e6066c46bfa43d8aa10dac5bc5d16ea" name="a8e6066c46bfa43d8aa10dac5bc5d16ea"></a>
typedef struct astarte_device *&#160;</td><td class="memItemRight" valign="bottom"><b>astarte_device_handle_t</b></td></tr>
<tr class="separator:a8e6066c46bfa43d8aa10dac5bc5d16ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ff127c7fc09dc12b5ad79a0bfceed1b" id="r_a9ff127c7fc09dc12b5ad79a0bfceed1b"><td class="memItemLeft" align="right" valign="top"><a id="a9ff127c7fc09dc12b5ad79a0bfceed1b" name="a9ff127c7fc09dc12b5ad79a0bfceed1b"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>astarte_device_data_event_callback_t</b>) (<a class="el" href="structastarte__device__data__event__t.html">astarte_device_data_event_t</a> *event)</td></tr>
<tr class="separator:a9ff127c7fc09dc12b5ad79a0bfceed1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cf7b8c6e0144c87499a5453bd8ecb5" id="r_af3cf7b8c6e0144c87499a5453bd8ecb5"><td class="memItemLeft" align="right" valign="top"><a id="af3cf7b8c6e0144c87499a5453bd8ecb5" name="af3cf7b8c6e0144c87499a5453bd8ecb5"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>astarte_device_connection_event_callback_t</b>) (<a class="el" href="structastarte__device__connection__event__t.html">astarte_device_connection_event_t</a> *event)</td></tr>
<tr class="separator:af3cf7b8c6e0144c87499a5453bd8ecb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab44c3b5b5d2f677ec9cb53269eb6d5de" id="r_ab44c3b5b5d2f677ec9cb53269eb6d5de"><td class="memItemLeft" align="right" valign="top"><a id="ab44c3b5b5d2f677ec9cb53269eb6d5de" name="ab44c3b5b5d2f677ec9cb53269eb6d5de"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>astarte_device_disconnection_event_callback_t</b>) (<a class="el" href="structastarte__device__disconnection__event__t.html">astarte_device_disconnection_event_t</a> *event)</td></tr>
<tr class="separator:ab44c3b5b5d2f677ec9cb53269eb6d5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508d8e3535dfb1f123ea06e331cbdfc0" id="r_a508d8e3535dfb1f123ea06e331cbdfc0"><td class="memItemLeft" align="right" valign="top"><a id="a508d8e3535dfb1f123ea06e331cbdfc0" name="a508d8e3535dfb1f123ea06e331cbdfc0"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>astarte_device_unset_event_callback_t</b>) (<a class="el" href="structastarte__device__unset__event__t.html">astarte_device_unset_event_t</a> *event)</td></tr>
<tr class="separator:a508d8e3535dfb1f123ea06e331cbdfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6cb5a5d56bc877a8faf20ecfd2888329" id="r_a6cb5a5d56bc877a8faf20ecfd2888329"><td class="memItemLeft" align="right" valign="top">astarte_device_handle_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a6cb5a5d56bc877a8faf20ecfd2888329">astarte_device_init</a> (<a class="el" href="structastarte__device__config__t.html">astarte_device_config_t</a> *cfg)</td></tr>
<tr class="memdesc:a6cb5a5d56bc877a8faf20ecfd2888329"><td class="mdescLeft">&#160;</td><td class="mdescRight">initialize Astarte device.  <br /></td></tr>
<tr class="separator:a6cb5a5d56bc877a8faf20ecfd2888329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7101d473c2b008d9fe4efdfe24fcd3f1" id="r_a7101d473c2b008d9fe4efdfe24fcd3f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a7101d473c2b008d9fe4efdfe24fcd3f1">astarte_device_destroy</a> (astarte_device_handle_t device)</td></tr>
<tr class="memdesc:a7101d473c2b008d9fe4efdfe24fcd3f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">destroy Astarte device.  <br /></td></tr>
<tr class="separator:a7101d473c2b008d9fe4efdfe24fcd3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3a8773ceb649857fa67eed1e8ac30b" id="r_a2b3a8773ceb649857fa67eed1e8ac30b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a2b3a8773ceb649857fa67eed1e8ac30b">astarte_device_add_interface</a> (astarte_device_handle_t device, const <a class="el" href="structastarte__interface__t.html">astarte_interface_t</a> *interface)</td></tr>
<tr class="memdesc:a2b3a8773ceb649857fa67eed1e8ac30b"><td class="mdescLeft">&#160;</td><td class="mdescRight">add an interface to the device.  <br /></td></tr>
<tr class="separator:a2b3a8773ceb649857fa67eed1e8ac30b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41931e977d0752bf48e18445fa87ad41" id="r_a41931e977d0752bf48e18445fa87ad41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a41931e977d0752bf48e18445fa87ad41">astarte_device_start</a> (astarte_device_handle_t device)</td></tr>
<tr class="memdesc:a41931e977d0752bf48e18445fa87ad41"><td class="mdescLeft">&#160;</td><td class="mdescRight">start Astarte device.  <br /></td></tr>
<tr class="separator:a41931e977d0752bf48e18445fa87ad41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20aaaa94be7b173c521676ddf6c14c05" id="r_a20aaaa94be7b173c521676ddf6c14c05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a20aaaa94be7b173c521676ddf6c14c05">astarte_device_stop</a> (astarte_device_handle_t device)</td></tr>
<tr class="memdesc:a20aaaa94be7b173c521676ddf6c14c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">stop Astarte device.  <br /></td></tr>
<tr class="separator:a20aaaa94be7b173c521676ddf6c14c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19ed2145151ef2e181b9f635bed5a4d8" id="r_a19ed2145151ef2e181b9f635bed5a4d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a19ed2145151ef2e181b9f635bed5a4d8">astarte_device_stream_double</a> (astarte_device_handle_t device, const char *interface_name, const char *path, double value, int qos)</td></tr>
<tr class="memdesc:a19ed2145151ef2e181b9f635bed5a4d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a double value on a datastream endpoint.  <br /></td></tr>
<tr class="separator:a19ed2145151ef2e181b9f635bed5a4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025aee78f65bdce713354fc6193494a6" id="r_a025aee78f65bdce713354fc6193494a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a025aee78f65bdce713354fc6193494a6">astarte_device_stream_double_with_timestamp</a> (astarte_device_handle_t device, const char *interface_name, const char *path, double value, uint64_t ts_epoch_millis, int qos)</td></tr>
<tr class="memdesc:a025aee78f65bdce713354fc6193494a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a double value on a datastream endpoint with an explicit timestamp.  <br /></td></tr>
<tr class="separator:a025aee78f65bdce713354fc6193494a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1fa790fd368e9855638399fc5cd970" id="r_a9f1fa790fd368e9855638399fc5cd970"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a9f1fa790fd368e9855638399fc5cd970">astarte_device_stream_integer</a> (astarte_device_handle_t device, const char *interface_name, const char *path, int32_t value, int qos)</td></tr>
<tr class="memdesc:a9f1fa790fd368e9855638399fc5cd970"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a 32 bit integer value on a datastream endpoint.  <br /></td></tr>
<tr class="separator:a9f1fa790fd368e9855638399fc5cd970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392cd2086d86897770a0ec09f7a92039" id="r_a392cd2086d86897770a0ec09f7a92039"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a392cd2086d86897770a0ec09f7a92039">astarte_device_stream_integer_with_timestamp</a> (astarte_device_handle_t device, const char *interface_name, const char *path, int32_t value, uint64_t ts_epoch_millis, int qos)</td></tr>
<tr class="memdesc:a392cd2086d86897770a0ec09f7a92039"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a 32 bit integer value on a datastream endpoint with an explicit timestamp.  <br /></td></tr>
<tr class="separator:a392cd2086d86897770a0ec09f7a92039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36b8d0d64a9f7db8f378d97d2ccace6" id="r_ac36b8d0d64a9f7db8f378d97d2ccace6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#ac36b8d0d64a9f7db8f378d97d2ccace6">astarte_device_stream_longinteger</a> (astarte_device_handle_t device, const char *interface_name, const char *path, int64_t value, int qos)</td></tr>
<tr class="memdesc:ac36b8d0d64a9f7db8f378d97d2ccace6"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a 64 bit integer value on a datastream endpoint.  <br /></td></tr>
<tr class="separator:ac36b8d0d64a9f7db8f378d97d2ccace6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f310b9353c14dbdf3f1d90d09955166" id="r_a0f310b9353c14dbdf3f1d90d09955166"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a0f310b9353c14dbdf3f1d90d09955166">astarte_device_stream_longinteger_with_timestamp</a> (astarte_device_handle_t device, const char *interface_name, const char *path, int64_t value, uint64_t ts_epoch_millis, int qos)</td></tr>
<tr class="memdesc:a0f310b9353c14dbdf3f1d90d09955166"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a 64 bit integer value on a datastream endpoint with an explicit timestamp.  <br /></td></tr>
<tr class="separator:a0f310b9353c14dbdf3f1d90d09955166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7f34d4d90726598ecbb501c94ef1331" id="r_af7f34d4d90726598ecbb501c94ef1331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#af7f34d4d90726598ecbb501c94ef1331">astarte_device_stream_boolean</a> (astarte_device_handle_t device, const char *interface_name, const char *path, bool value, int qos)</td></tr>
<tr class="memdesc:af7f34d4d90726598ecbb501c94ef1331"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a boolean value on a datastream endpoint.  <br /></td></tr>
<tr class="separator:af7f34d4d90726598ecbb501c94ef1331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf5f082577f4b8eebdac638fc73f0272" id="r_abf5f082577f4b8eebdac638fc73f0272"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#abf5f082577f4b8eebdac638fc73f0272">astarte_device_stream_boolean_with_timestamp</a> (astarte_device_handle_t device, const char *interface_name, const char *path, bool value, uint64_t ts_epoch_millis, int qos)</td></tr>
<tr class="memdesc:abf5f082577f4b8eebdac638fc73f0272"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a boolean value on a datastream endpoint with an explicit timestamp.  <br /></td></tr>
<tr class="separator:abf5f082577f4b8eebdac638fc73f0272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa580c422aaf7ad4878be07cd8fd6559d" id="r_aa580c422aaf7ad4878be07cd8fd6559d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#aa580c422aaf7ad4878be07cd8fd6559d">astarte_device_stream_string</a> (astarte_device_handle_t device, const char *interface_name, const char *path, const char *value, int qos)</td></tr>
<tr class="memdesc:aa580c422aaf7ad4878be07cd8fd6559d"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a UTF8 encoded string on a datastream endpoint.  <br /></td></tr>
<tr class="separator:aa580c422aaf7ad4878be07cd8fd6559d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b3023852a97db477f7810c3652dd66" id="r_a22b3023852a97db477f7810c3652dd66"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a22b3023852a97db477f7810c3652dd66">astarte_device_stream_string_with_timestamp</a> (astarte_device_handle_t device, const char *interface_name, const char *path, const char *value, uint64_t ts_epoch_millis, int qos)</td></tr>
<tr class="memdesc:a22b3023852a97db477f7810c3652dd66"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a UTF8 encoded string on a datastream endpoint with an explicit timestamp.  <br /></td></tr>
<tr class="separator:a22b3023852a97db477f7810c3652dd66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ad8eb57f86dd44690a280e1106d74c" id="r_ae7ad8eb57f86dd44690a280e1106d74c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#ae7ad8eb57f86dd44690a280e1106d74c">astarte_device_stream_binaryblob</a> (astarte_device_handle_t device, const char *interface_name, const char *path, void *value, size_t size, int qos)</td></tr>
<tr class="memdesc:ae7ad8eb57f86dd44690a280e1106d74c"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a binary value on a datastream endpoint.  <br /></td></tr>
<tr class="separator:ae7ad8eb57f86dd44690a280e1106d74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa695e05ad1b7d4327f7f822654277111" id="r_aa695e05ad1b7d4327f7f822654277111"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#aa695e05ad1b7d4327f7f822654277111">astarte_device_stream_binaryblob_with_timestamp</a> (astarte_device_handle_t device, const char *interface_name, const char *path, void *value, size_t size, uint64_t ts_epoch_millis, int qos)</td></tr>
<tr class="memdesc:aa695e05ad1b7d4327f7f822654277111"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a binary value on a datastream endpoint with an explicit timestamp.  <br /></td></tr>
<tr class="separator:aa695e05ad1b7d4327f7f822654277111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e67e896a0c2da03fef0ba551f40f308" id="r_a3e67e896a0c2da03fef0ba551f40f308"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a3e67e896a0c2da03fef0ba551f40f308">astarte_device_stream_datetime</a> (astarte_device_handle_t device, const char *interface_name, const char *path, int64_t value, int qos)</td></tr>
<tr class="memdesc:a3e67e896a0c2da03fef0ba551f40f308"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a datetime value on a datastream endpoint.  <br /></td></tr>
<tr class="separator:a3e67e896a0c2da03fef0ba551f40f308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a865812ad0918d678f08e70e3022ef7c8" id="r_a865812ad0918d678f08e70e3022ef7c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a865812ad0918d678f08e70e3022ef7c8">astarte_device_stream_datetime_with_timestamp</a> (astarte_device_handle_t device, const char *interface_name, const char *path, int64_t value, uint64_t ts_epoch_millis, int qos)</td></tr>
<tr class="memdesc:a865812ad0918d678f08e70e3022ef7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a datetime value on a datastream endpoint with an explicit timestamp.  <br /></td></tr>
<tr class="separator:a865812ad0918d678f08e70e3022ef7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fe888862861e457f710bea636fda763" id="r_a0fe888862861e457f710bea636fda763"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a0fe888862861e457f710bea636fda763">astarte_device_stream_double_array_with_timestamp</a> (astarte_device_handle_t device, const char *interface_name, const char *path, const double *values, int count, uint64_t ts_epoch_millis, int qos)</td></tr>
<tr class="memdesc:a0fe888862861e457f710bea636fda763"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a double array value on a datastream endpoint with an explicit timestamp.  <br /></td></tr>
<tr class="separator:a0fe888862861e457f710bea636fda763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3715b669b6a31c0a8ab0e9d71dd61f6" id="r_af3715b669b6a31c0a8ab0e9d71dd61f6"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#af3715b669b6a31c0a8ab0e9d71dd61f6">astarte_device_stream_double_array</a> (astarte_device_handle_t device, const char *interface_name, const char *path, const double *values, int count, uint64_t ts_epoch_millis, int qos)</td></tr>
<tr class="memdesc:af3715b669b6a31c0a8ab0e9d71dd61f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a double array value on a datastream endpoint.  <br /></td></tr>
<tr class="separator:af3715b669b6a31c0a8ab0e9d71dd61f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac0ac9e1a724fd898277264da0895f67" id="r_aac0ac9e1a724fd898277264da0895f67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#aac0ac9e1a724fd898277264da0895f67">astarte_device_stream_integer_array_with_timestamp</a> (astarte_device_handle_t device, const char *interface_name, const char *path, const int32_t *values, int count, uint64_t ts_epoch_millis, int qos)</td></tr>
<tr class="memdesc:aac0ac9e1a724fd898277264da0895f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a 32 bit integer array value on a datastream endpoint with an explicit timestamp.  <br /></td></tr>
<tr class="separator:aac0ac9e1a724fd898277264da0895f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5564a109ed290cb43d1e6aa47a96f1f" id="r_ad5564a109ed290cb43d1e6aa47a96f1f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#ad5564a109ed290cb43d1e6aa47a96f1f">astarte_device_stream_integer_array</a> (astarte_device_handle_t device, const char *interface_name, const char *path, const int32_t *values, int count, int qos)</td></tr>
<tr class="memdesc:ad5564a109ed290cb43d1e6aa47a96f1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a 32 bit integer array value on a datastream endpoint.  <br /></td></tr>
<tr class="separator:ad5564a109ed290cb43d1e6aa47a96f1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b51b0c8c3167b2464127b6d4f24a6f" id="r_ab5b51b0c8c3167b2464127b6d4f24a6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#ab5b51b0c8c3167b2464127b6d4f24a6f">astarte_device_stream_longinteger_array_with_timestamp</a> (astarte_device_handle_t device, const char *interface_name, const char *path, const int64_t *values, int count, uint64_t ts_epoch_millis, int qos)</td></tr>
<tr class="memdesc:ab5b51b0c8c3167b2464127b6d4f24a6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a 64 bit integer array value on a datastream endpoint with an explicit timestamp.  <br /></td></tr>
<tr class="separator:ab5b51b0c8c3167b2464127b6d4f24a6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4c1b6a7569c28141be471694288716" id="r_aeb4c1b6a7569c28141be471694288716"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#aeb4c1b6a7569c28141be471694288716">astarte_device_stream_longinteger_array</a> (astarte_device_handle_t device, const char *interface_name, const char *path, const int64_t *values, int count, int qos)</td></tr>
<tr class="memdesc:aeb4c1b6a7569c28141be471694288716"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a 64 bit integer array value on a datastream endpoint.  <br /></td></tr>
<tr class="separator:aeb4c1b6a7569c28141be471694288716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c218701364538cd2991b74d69cc57f" id="r_aa1c218701364538cd2991b74d69cc57f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#aa1c218701364538cd2991b74d69cc57f">astarte_device_stream_boolean_array_with_timestamp</a> (astarte_device_handle_t device, const char *interface_name, const char *path, const bool *values, int count, uint64_t ts_epoch_millis, int qos)</td></tr>
<tr class="memdesc:aa1c218701364538cd2991b74d69cc57f"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a boolean array value on a datastream endpoint with an explicit timestamp.  <br /></td></tr>
<tr class="separator:aa1c218701364538cd2991b74d69cc57f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe8e977bc525835ece5900dcd957fa87" id="r_abe8e977bc525835ece5900dcd957fa87"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#abe8e977bc525835ece5900dcd957fa87">astarte_device_stream_boolean_array</a> (astarte_device_handle_t device, const char *interface_name, const char *path, const bool *values, int count, int qos)</td></tr>
<tr class="memdesc:abe8e977bc525835ece5900dcd957fa87"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a boolean array value on a datastream endpoint.  <br /></td></tr>
<tr class="separator:abe8e977bc525835ece5900dcd957fa87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69b59c1982fa9c4d67275daec06f5f8" id="r_aa69b59c1982fa9c4d67275daec06f5f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#aa69b59c1982fa9c4d67275daec06f5f8">astarte_device_stream_string_array_with_timestamp</a> (astarte_device_handle_t device, const char *interface_name, const char *path, const char *const *values, int count, uint64_t ts_epoch_millis, int qos)</td></tr>
<tr class="memdesc:aa69b59c1982fa9c4d67275daec06f5f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a string array value on a datastream endpoint with an explicit timestamp.  <br /></td></tr>
<tr class="separator:aa69b59c1982fa9c4d67275daec06f5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679c016f4b0727e2ccf86d237ae7a092" id="r_a679c016f4b0727e2ccf86d237ae7a092"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a679c016f4b0727e2ccf86d237ae7a092">astarte_device_stream_string_array</a> (astarte_device_handle_t device, const char *interface_name, const char *path, const char *const *values, int count, int qos)</td></tr>
<tr class="memdesc:a679c016f4b0727e2ccf86d237ae7a092"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a string array value on a datastream endpoint.  <br /></td></tr>
<tr class="separator:a679c016f4b0727e2ccf86d237ae7a092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ccbefb05b904c956a3f9edca3343343" id="r_a8ccbefb05b904c956a3f9edca3343343"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a8ccbefb05b904c956a3f9edca3343343">astarte_device_stream_binaryblob_array_with_timestamp</a> (astarte_device_handle_t device, const char *interface_name, const char *path, const void *const *values, const int *sizes, int count, uint64_t ts_epoch_millis, int qos)</td></tr>
<tr class="memdesc:a8ccbefb05b904c956a3f9edca3343343"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a binary blob array value on a datastream endpoint with an explicit timestamp.  <br /></td></tr>
<tr class="separator:a8ccbefb05b904c956a3f9edca3343343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a695421ff48ff8cee68b03c034590a43d" id="r_a695421ff48ff8cee68b03c034590a43d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a695421ff48ff8cee68b03c034590a43d">astarte_device_stream_binaryblob_array</a> (astarte_device_handle_t device, const char *interface_name, const char *path, const void *const *values, const int *sizes, int count, int qos)</td></tr>
<tr class="memdesc:a695421ff48ff8cee68b03c034590a43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a binary blob array value on a datastream endpoint with an explicit timestamp.  <br /></td></tr>
<tr class="separator:a695421ff48ff8cee68b03c034590a43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4233119a61127bbe20969541910fd44e" id="r_a4233119a61127bbe20969541910fd44e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a4233119a61127bbe20969541910fd44e">astarte_device_stream_datetime_array_with_timestamp</a> (astarte_device_handle_t device, const char *interface_name, const char *path, const int64_t *values, int count, uint64_t ts_epoch_millis, int qos)</td></tr>
<tr class="memdesc:a4233119a61127bbe20969541910fd44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a datetime value on a datastream endpoint with an explicit timestamp.  <br /></td></tr>
<tr class="separator:a4233119a61127bbe20969541910fd44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa579ae0b74464e8eeafb567ce1fe05" id="r_a1fa579ae0b74464e8eeafb567ce1fe05"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a1fa579ae0b74464e8eeafb567ce1fe05">astarte_device_stream_datetime_array</a> (astarte_device_handle_t device, const char *interface_name, const char *path, const int64_t *values, int count, int qos)</td></tr>
<tr class="memdesc:a1fa579ae0b74464e8eeafb567ce1fe05"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a datetime value on a datastream endpoint.  <br /></td></tr>
<tr class="separator:a1fa579ae0b74464e8eeafb567ce1fe05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bded8afb6018dfcaf46147470a1762" id="r_ac6bded8afb6018dfcaf46147470a1762"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#ac6bded8afb6018dfcaf46147470a1762">astarte_device_stream_aggregate</a> (astarte_device_handle_t device, const char *interface_name, const char *path_prefix, const void *bson_document, int qos)</td></tr>
<tr class="memdesc:ac6bded8afb6018dfcaf46147470a1762"><td class="mdescLeft">&#160;</td><td class="mdescRight">send an aggregate value on a datastream endpoint of an interface with object aggregation.  <br /></td></tr>
<tr class="separator:ac6bded8afb6018dfcaf46147470a1762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccea655d531f66140e19efcdaf8acc4" id="r_aeccea655d531f66140e19efcdaf8acc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#aeccea655d531f66140e19efcdaf8acc4">astarte_device_stream_aggregate_with_timestamp</a> (astarte_device_handle_t device, const char *interface_name, const char *path_prefix, const void *bson_document, uint64_t ts_epoch_millis, int qos)</td></tr>
<tr class="memdesc:aeccea655d531f66140e19efcdaf8acc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">send an aggregate value on a datastream endpoint of an interface with object aggregation with an explicit timestamp.  <br /></td></tr>
<tr class="separator:aeccea655d531f66140e19efcdaf8acc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d9d8843385b9581a75c5657106ad38" id="r_a79d9d8843385b9581a75c5657106ad38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a79d9d8843385b9581a75c5657106ad38">astarte_device_set_double_property</a> (astarte_device_handle_t device, const char *interface_name, const char *path, double value)</td></tr>
<tr class="memdesc:a79d9d8843385b9581a75c5657106ad38"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a double value on a properties endpoint.  <br /></td></tr>
<tr class="separator:a79d9d8843385b9581a75c5657106ad38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8b2d533f552356d3dee678d9131599" id="r_aea8b2d533f552356d3dee678d9131599"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#aea8b2d533f552356d3dee678d9131599">astarte_device_set_integer_property</a> (astarte_device_handle_t device, const char *interface_name, const char *path, int32_t value)</td></tr>
<tr class="memdesc:aea8b2d533f552356d3dee678d9131599"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a 32 bit integer value on a properties endpoint.  <br /></td></tr>
<tr class="separator:aea8b2d533f552356d3dee678d9131599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a138454cdcb8f4306143504871b26e" id="r_a50a138454cdcb8f4306143504871b26e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a50a138454cdcb8f4306143504871b26e">astarte_device_set_longinteger_property</a> (astarte_device_handle_t device, const char *interface_name, const char *path, int64_t value)</td></tr>
<tr class="memdesc:a50a138454cdcb8f4306143504871b26e"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a 64 bit integer value on a properties endpoint.  <br /></td></tr>
<tr class="separator:a50a138454cdcb8f4306143504871b26e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec925e23e0b774072d1f8f2d21b796a" id="r_a1ec925e23e0b774072d1f8f2d21b796a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a1ec925e23e0b774072d1f8f2d21b796a">astarte_device_set_boolean_property</a> (astarte_device_handle_t device, const char *interface_name, const char *path, bool value)</td></tr>
<tr class="memdesc:a1ec925e23e0b774072d1f8f2d21b796a"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a boolean value on a properties endpoint.  <br /></td></tr>
<tr class="separator:a1ec925e23e0b774072d1f8f2d21b796a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a5b41823cb0ffa6f0738d1ea0c15e6" id="r_ac7a5b41823cb0ffa6f0738d1ea0c15e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#ac7a5b41823cb0ffa6f0738d1ea0c15e6">astarte_device_set_string_property</a> (astarte_device_handle_t device, const char *interface_name, const char *path, const char *value)</td></tr>
<tr class="memdesc:ac7a5b41823cb0ffa6f0738d1ea0c15e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a UTF8 encoded string on a properties endpoint.  <br /></td></tr>
<tr class="separator:ac7a5b41823cb0ffa6f0738d1ea0c15e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6afacc008f801d4835e8099ba6112d" id="r_a7b6afacc008f801d4835e8099ba6112d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a7b6afacc008f801d4835e8099ba6112d">astarte_device_set_binaryblob_property</a> (astarte_device_handle_t device, const char *interface_name, const char *path, void *value, size_t size)</td></tr>
<tr class="memdesc:a7b6afacc008f801d4835e8099ba6112d"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a binary value on a properties endpoint.  <br /></td></tr>
<tr class="separator:a7b6afacc008f801d4835e8099ba6112d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed67cf81f0cbb8ab149d80777b871d0" id="r_a0ed67cf81f0cbb8ab149d80777b871d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a0ed67cf81f0cbb8ab149d80777b871d0">astarte_device_set_datetime_property</a> (astarte_device_handle_t device, const char *interface_name, const char *path, int64_t value)</td></tr>
<tr class="memdesc:a0ed67cf81f0cbb8ab149d80777b871d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">send a datetime value on a properties endpoint.  <br /></td></tr>
<tr class="separator:a0ed67cf81f0cbb8ab149d80777b871d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9359c554df96f2b58bf30aeff2fff62e" id="r_a9359c554df96f2b58bf30aeff2fff62e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a9359c554df96f2b58bf30aeff2fff62e">astarte_device_unset_path</a> (astarte_device_handle_t device, const char *interface_name, const char *path)</td></tr>
<tr class="memdesc:a9359c554df96f2b58bf30aeff2fff62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">unset a path belonging to a properties interface.  <br /></td></tr>
<tr class="separator:a9359c554df96f2b58bf30aeff2fff62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32e3ccef3c659411635664998c5bc621" id="r_a32e3ccef3c659411635664998c5bc621"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#a32e3ccef3c659411635664998c5bc621">astarte_device_is_connected</a> (astarte_device_handle_t device)</td></tr>
<tr class="memdesc:a32e3ccef3c659411635664998c5bc621"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if the device is connected.  <br /></td></tr>
<tr class="separator:a32e3ccef3c659411635664998c5bc621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a3e07c1c7d6f7f1fab3bef6b47c73c" id="r_aa0a3e07c1c7d6f7f1fab3bef6b47c73c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="astarte__device_8h.html#aa0a3e07c1c7d6f7f1fab3bef6b47c73c">astarte_device_get_encoded_id</a> (astarte_device_handle_t device)</td></tr>
<tr class="memdesc:aa0a3e07c1c7d6f7f1fab3bef6b47c73c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the encoded hardware ID of the device.  <br /></td></tr>
<tr class="separator:aa0a3e07c1c7d6f7f1fab3bef6b47c73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Astarte device SDK high level API. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a2b3a8773ceb649857fa67eed1e8ac30b" name="a2b3a8773ceb649857fa67eed1e8ac30b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3a8773ceb649857fa67eed1e8ac30b">&#9670;&#160;</a></span>astarte_device_add_interface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_add_interface </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structastarte__interface__t.html">astarte_interface_t</a> *&#160;</td>
          <td class="paramname"><em>interface</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add an interface to the device. </p>
<p>This function has to be called before astarte_device_start to add all the needed Astarte interfaces, that will be sent in the device introspection when it connects. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A valid Astarte device handle. </td></tr>
    <tr><td class="paramname">interface</td><td>A pointer to an <a class="el" href="structastarte__interface__t.html" title="Astarte interface definition.">astarte_interface_t</a> struct describing the interface. The caller is responsible for making sure the pointed interface remains valid for the lifetime of the astarte_device. It is recommended to declare interface structs as static const. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the interface was succesfully added, another astarte_err_t otherwise. </dd></dl>

</div>
</div>
<a id="a7101d473c2b008d9fe4efdfe24fcd3f1" name="a7101d473c2b008d9fe4efdfe24fcd3f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7101d473c2b008d9fe4efdfe24fcd3f1">&#9670;&#160;</a></span>astarte_device_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void astarte_device_destroy </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>destroy Astarte device. </p>
<p>This function destroys the device, freeing all its resources. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A valid Astarte device handle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa0a3e07c1c7d6f7f1fab3bef6b47c73c" name="aa0a3e07c1c7d6f7f1fab3bef6b47c73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a3e07c1c7d6f7f1fab3bef6b47c73c">&#9670;&#160;</a></span>astarte_device_get_encoded_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char * astarte_device_get_encoded_id </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the encoded hardware ID of the device. </p>
<p>Get the encoded hardware ID of the device. The string is owned by astarte_device_handle_t and it is freed when the device is closed/freed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>An Astarte device handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The string containing the encoded device ID. </dd></dl>

</div>
</div>
<a id="a6cb5a5d56bc877a8faf20ecfd2888329" name="a6cb5a5d56bc877a8faf20ecfd2888329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb5a5d56bc877a8faf20ecfd2888329">&#9670;&#160;</a></span>astarte_device_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">astarte_device_handle_t astarte_device_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structastarte__device__config__t.html">astarte_device_config_t</a> *&#160;</td>
          <td class="paramname"><em>cfg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>initialize Astarte device. </p>
<p>This function has to be called to initialize the device SDK before doing anything else.</p>
<p>If hwid is not defined explicitly in cfg, the device will use an hwid derived from unique device features (e.g. MAC address, CPU features...). An explicit hwid can be passed in the <a class="el" href="structastarte__device__config__t.html">astarte_device_config_t</a> struct. For example, it is possible to use a UUIDv5 as hwid, using a personal UUID namespace and some custom device data to derive it.</p>
<p>Example:</p>
<p>uuid_t uuid_ns; if (uuid_from_string("de40ff58-5696-4b35-a6d6-0cc7280bcd56", uuid_ns) != 0) { ESP_LOGE(TAG, "Error while parsing namespace UUID"); }</p>
<p>uuid_t device_uuid; const char *unique_data = "my_unique_data" uuid_generate_v5(uuid_ns, unique_data, strlen(unique_data), device_uuid);</p>
<p>char hwid[32] = { 0 }; astarte_hwid_encode(hwid, sizeof(hwid), device_uuid);</p>
<p><a class="el" href="structastarte__device__config__t.html">astarte_device_config_t</a> cfg = { .data_event_callback = astarte_data_events_handler, .hwid = hwid, };</p>
<dl class="section return"><dt>Returns</dt><dd>The handle to the device, NULL if an error occurred. </dd></dl>

</div>
</div>
<a id="a32e3ccef3c659411635664998c5bc621" name="a32e3ccef3c659411635664998c5bc621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32e3ccef3c659411635664998c5bc621">&#9670;&#160;</a></span>astarte_device_is_connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool astarte_device_is_connected </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if the device is connected. </p>
<p>check if the Astarte device is currently connected to the MQTT broker. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>An Astarte device handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the device is currently connected to the broker, false if it's not. </dd></dl>

</div>
</div>
<a id="a7b6afacc008f801d4835e8099ba6112d" name="a7b6afacc008f801d4835e8099ba6112d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6afacc008f801d4835e8099ba6112d">&#9670;&#160;</a></span>astarte_device_set_binaryblob_property()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_set_binaryblob_property </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a binary value on a properties endpoint. </p>
<p>This function sends a binary value on a path of a given properties interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to the binary data to be sent. </td></tr>
    <tr><td class="paramname">size</td><td>The length in bytes of the binary data to be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="a1ec925e23e0b774072d1f8f2d21b796a" name="a1ec925e23e0b774072d1f8f2d21b796a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec925e23e0b774072d1f8f2d21b796a">&#9670;&#160;</a></span>astarte_device_set_boolean_property()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_set_boolean_property </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a boolean value on a properties endpoint. </p>
<p>This function sends a boolean value on a path of a given properties interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">value</td><td>The value to be sent (0 or 1). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="a0ed67cf81f0cbb8ab149d80777b871d0" name="a0ed67cf81f0cbb8ab149d80777b871d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed67cf81f0cbb8ab149d80777b871d0">&#9670;&#160;</a></span>astarte_device_set_datetime_property()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_set_datetime_property </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a datetime value on a properties endpoint. </p>
<p>This function sends a datetime value on a path of a given properties interface. The datetime represents the number of milliseconds since Unix epoch (1970-01-01). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">value</td><td>The value to be sent, representing the number of milliseconds since Unix epoch (1970-01-01). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="a79d9d8843385b9581a75c5657106ad38" name="a79d9d8843385b9581a75c5657106ad38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d9d8843385b9581a75c5657106ad38">&#9670;&#160;</a></span>astarte_device_set_double_property()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_set_double_property </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a double value on a properties endpoint. </p>
<p>This function sends a double value on a path of a given properties interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">value</td><td>The value to be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="aea8b2d533f552356d3dee678d9131599" name="aea8b2d533f552356d3dee678d9131599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea8b2d533f552356d3dee678d9131599">&#9670;&#160;</a></span>astarte_device_set_integer_property()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_set_integer_property </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a 32 bit integer value on a properties endpoint. </p>
<p>This function sends a 32 bit int value on a path of a given properties interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">value</td><td>The value to be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="a50a138454cdcb8f4306143504871b26e" name="a50a138454cdcb8f4306143504871b26e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a138454cdcb8f4306143504871b26e">&#9670;&#160;</a></span>astarte_device_set_longinteger_property()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_set_longinteger_property </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a 64 bit integer value on a properties endpoint. </p>
<p>This function sends a 64 bit int value on a path of a given properties interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">value</td><td>The value to be sent. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="ac7a5b41823cb0ffa6f0738d1ea0c15e6" name="ac7a5b41823cb0ffa6f0738d1ea0c15e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a5b41823cb0ffa6f0738d1ea0c15e6">&#9670;&#160;</a></span>astarte_device_set_string_property()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_set_string_property </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a UTF8 encoded string on a properties endpoint. </p>
<p>This function sends a UTF8 encoded string on a path of a given properties interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">value</td><td>The value to be sent (a NULL terminated string). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="a41931e977d0752bf48e18445fa87ad41" name="a41931e977d0752bf48e18445fa87ad41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41931e977d0752bf48e18445fa87ad41">&#9670;&#160;</a></span>astarte_device_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_start </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>start Astarte device. </p>
<p>This function starts the device, making it connect to the broker and perform its work. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A valid Astarte device handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the device was succesfully started, another astarte_err_t otherwise. </dd></dl>

</div>
</div>
<a id="a20aaaa94be7b173c521676ddf6c14c05" name="a20aaaa94be7b173c521676ddf6c14c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20aaaa94be7b173c521676ddf6c14c05">&#9670;&#160;</a></span>astarte_device_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stop </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>stop Astarte device. </p>
<p>This function stops the device, making it disconnect from the broker. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A valid Astarte device handle. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the device was succesfully stopped, another astarte_err_t otherwise. </dd></dl>

</div>
</div>
<a id="ac6bded8afb6018dfcaf46147470a1762" name="ac6bded8afb6018dfcaf46147470a1762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bded8afb6018dfcaf46147470a1762">&#9670;&#160;</a></span>astarte_device_stream_aggregate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_aggregate </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bson_document</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send an aggregate value on a datastream endpoint of an interface with object aggregation. </p>
<p>This function sends an aggregate value on a path of a given datastream interface. The value is represented with a BSON document that can be built with astarte_bson_serializer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path_prefix</td><td>A string containing the path prefix of the aggregate (beginning with /). The path prefix is the common prefix of the endpoints in the aggregate interface. </td></tr>
    <tr><td class="paramname">bson_document</td><td>A pointer to the document buffer containing the aggregate. Here's an example of how you can obtain the bson_document for an AirSensor interface containing 3 endpoints:</td></tr>
  </table>
  </dd>
</dl>
<p>astarte_bson_serializer_handle_t bs = <a class="el" href="astarte__bson__serializer_8h.html#ab3e816c58415635205fe6480e8c78f73" title="create a new instance of the BSON serializer.">astarte_bson_serializer_new()</a>; astarte_bson_serializer_append_double(bs, "co2", 4.0); astarte_bson_serializer_append_double(bs, "temperature", 20.0); astarte_bson_serializer_append_double(bs, "humidity", 77.2); astarte_bson_serializer_append_end_of_document(bs); int size; const void *document = astarte_bson_serializer_get_document(bs, &amp;size); // Use the returned buffer before destroy call astarte_bson_serializer_destroy(bs);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="aeccea655d531f66140e19efcdaf8acc4" name="aeccea655d531f66140e19efcdaf8acc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccea655d531f66140e19efcdaf8acc4">&#9670;&#160;</a></span>astarte_device_stream_aggregate_with_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_aggregate_with_timestamp </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bson_document</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ts_epoch_millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send an aggregate value on a datastream endpoint of an interface with object aggregation with an explicit timestamp. </p>
<p>This function sends an aggregate value on a path of a given datastream interface. The value is represented with a BSON document that can be built with astarte_bson_serializer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path_prefix</td><td>A string containing the path prefix of the aggregate (beginning with /). The path prefix is the common prefix of the endpoints in the aggregate interface. </td></tr>
    <tr><td class="paramname">bson_document</td><td>A pointer to the document buffer containing the aggregate. Here's an example of how you can obtain the bson_document for an AirSensor interface containing 3 endpoints:</td></tr>
  </table>
  </dd>
</dl>
<p>astarte_bson_serializer_handle_t bs = <a class="el" href="astarte__bson__serializer_8h.html#ab3e816c58415635205fe6480e8c78f73" title="create a new instance of the BSON serializer.">astarte_bson_serializer_new()</a>; astarte_bson_serializer_append_double(bs, "co2", 4.0); astarte_bson_serializer_append_double(bs, "temperature", 20.0); astarte_bson_serializer_append_double(bs, "humidity", 77.2); astarte_bson_serializer_append_end_of_document(bs); int size; const void *document = astarte_bson_serializer_get_document(bs, &amp;size); // Use the returned buffer before destroy call astarte_bson_serializer_destroy(bs);</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ts_epoch_millis</td><td>The timestamp of the datastream. This is useful only on mappings with explicit_timestamp set to true and it's represented as milliseconds since epoch. A value of ASTARTE_INVALID_TIMESTAMP is ignored. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="ae7ad8eb57f86dd44690a280e1106d74c" name="ae7ad8eb57f86dd44690a280e1106d74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ad8eb57f86dd44690a280e1106d74c">&#9670;&#160;</a></span>astarte_device_stream_binaryblob()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_binaryblob </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a binary value on a datastream endpoint. </p>
<p>This function sends a binary value on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to the binary data to be sent. </td></tr>
    <tr><td class="paramname">size</td><td>The length in bytes of the binary data to be sent. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="a695421ff48ff8cee68b03c034590a43d" name="a695421ff48ff8cee68b03c034590a43d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a695421ff48ff8cee68b03c034590a43d">&#9670;&#160;</a></span>astarte_device_stream_binaryblob_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_binaryblob_array </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *const *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>send a binary blob array value on a datastream endpoint with an explicit timestamp. </p>
<p>This function sends a binary blob array value on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">values</td><td>The array of binary blobs to be sent (having each one const void * type). </td></tr>
    <tr><td class="paramname">sizes</td><td>The size of each binary blob that is in the given values array. </td></tr>
    <tr><td class="paramname">count</td><td>The number of values stored in values array. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="a8ccbefb05b904c956a3f9edca3343343" name="a8ccbefb05b904c956a3f9edca3343343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ccbefb05b904c956a3f9edca3343343">&#9670;&#160;</a></span>astarte_device_stream_binaryblob_array_with_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_binaryblob_array_with_timestamp </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *const *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ts_epoch_millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a binary blob array value on a datastream endpoint with an explicit timestamp. </p>
<p>This function sends a binary blob array value on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">values</td><td>The array of binary blobs to be sent (having each one const void * type). </td></tr>
    <tr><td class="paramname">sizes</td><td>The size of each binary blob that is in the given values array. </td></tr>
    <tr><td class="paramname">count</td><td>The number of values stored in values array. </td></tr>
    <tr><td class="paramname">ts_epoch_millis</td><td>The timestamp of the datastream. This is useful only on mappings with explicit_timestamp set to true and it's represented as milliseconds since epoch. A value of ASTARTE_INVALID_TIMESTAMP is ignored. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="aa695e05ad1b7d4327f7f822654277111" name="aa695e05ad1b7d4327f7f822654277111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa695e05ad1b7d4327f7f822654277111">&#9670;&#160;</a></span>astarte_device_stream_binaryblob_with_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_binaryblob_with_timestamp </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ts_epoch_millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a binary value on a datastream endpoint with an explicit timestamp. </p>
<p>This function sends a binary value on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">value</td><td>A pointer to the binary data to be sent. </td></tr>
    <tr><td class="paramname">size</td><td>The length in bytes of the binary data to be sent. </td></tr>
    <tr><td class="paramname">ts_epoch_millis</td><td>The timestamp of the datastream. This is useful only on mappings with explicit_timestamp set to true and it's represented as milliseconds since epoch. A value of ASTARTE_INVALID_TIMESTAMP is ignored. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="af7f34d4d90726598ecbb501c94ef1331" name="af7f34d4d90726598ecbb501c94ef1331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7f34d4d90726598ecbb501c94ef1331">&#9670;&#160;</a></span>astarte_device_stream_boolean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_boolean </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a boolean value on a datastream endpoint. </p>
<p>This function sends a boolean value on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">value</td><td>The value to be sent (0 or 1). </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="abe8e977bc525835ece5900dcd957fa87" name="abe8e977bc525835ece5900dcd957fa87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe8e977bc525835ece5900dcd957fa87">&#9670;&#160;</a></span>astarte_device_stream_boolean_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_boolean_array </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>send a boolean array value on a datastream endpoint. </p>
<p>This function sends a boolean array value on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">values</td><td>The array of booleans to be sent (false or true). </td></tr>
    <tr><td class="paramname">count</td><td>The number of values stored in values array. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="aa1c218701364538cd2991b74d69cc57f" name="aa1c218701364538cd2991b74d69cc57f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c218701364538cd2991b74d69cc57f">&#9670;&#160;</a></span>astarte_device_stream_boolean_array_with_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_boolean_array_with_timestamp </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ts_epoch_millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a boolean array value on a datastream endpoint with an explicit timestamp. </p>
<p>This function sends a boolean array value on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">values</td><td>The array of booleans to be sent (false or true). </td></tr>
    <tr><td class="paramname">count</td><td>The number of values stored in values array. </td></tr>
    <tr><td class="paramname">ts_epoch_millis</td><td>The timestamp of the datastream. This is useful only on mappings with explicit_timestamp set to true and it's represented as milliseconds since epoch. A value of ASTARTE_INVALID_TIMESTAMP is ignored. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="abf5f082577f4b8eebdac638fc73f0272" name="abf5f082577f4b8eebdac638fc73f0272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5f082577f4b8eebdac638fc73f0272">&#9670;&#160;</a></span>astarte_device_stream_boolean_with_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_boolean_with_timestamp </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ts_epoch_millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a boolean value on a datastream endpoint with an explicit timestamp. </p>
<p>This function sends a boolean value on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">value</td><td>The value to be sent (0 or 1). </td></tr>
    <tr><td class="paramname">ts_epoch_millis</td><td>The timestamp of the datastream. This is useful only on mappings with explicit_timestamp set to true and it's represented as milliseconds since epoch. A value of ASTARTE_INVALID_TIMESTAMP is ignored. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="a3e67e896a0c2da03fef0ba551f40f308" name="a3e67e896a0c2da03fef0ba551f40f308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e67e896a0c2da03fef0ba551f40f308">&#9670;&#160;</a></span>astarte_device_stream_datetime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_datetime </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a datetime value on a datastream endpoint. </p>
<p>This function sends a datetime value on a path of a given datastream interface. The datetime represents the number of milliseconds since Unix epoch (1970-01-01). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">value</td><td>The value to be sent, representing the number of milliseconds since Unix epoch (1970-01-01). </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="a1fa579ae0b74464e8eeafb567ce1fe05" name="a1fa579ae0b74464e8eeafb567ce1fe05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa579ae0b74464e8eeafb567ce1fe05">&#9670;&#160;</a></span>astarte_device_stream_datetime_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_datetime_array </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>send a datetime value on a datastream endpoint. </p>
<p>This function sends a datetime value on a path of a given datastream interface. The datetime represents the number of milliseconds since Unix epoch (1970-01-01). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">values</td><td>The array of datetimes, each one representing the number of milliseconds since Unix epoch (1970-01-01). </td></tr>
    <tr><td class="paramname">count</td><td>The number of values stored in values array. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="a4233119a61127bbe20969541910fd44e" name="a4233119a61127bbe20969541910fd44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4233119a61127bbe20969541910fd44e">&#9670;&#160;</a></span>astarte_device_stream_datetime_array_with_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_datetime_array_with_timestamp </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ts_epoch_millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a datetime value on a datastream endpoint with an explicit timestamp. </p>
<p>This function sends a datetime value on a path of a given datastream interface. The datetime represents the number of milliseconds since Unix epoch (1970-01-01). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">values</td><td>The array of datetimes, each one representing the number of milliseconds since Unix epoch (1970-01-01). </td></tr>
    <tr><td class="paramname">count</td><td>The number of values stored in values array. </td></tr>
    <tr><td class="paramname">ts_epoch_millis</td><td>The timestamp of the datastream. This is useful only on mappings with explicit_timestamp set to true and it's represented as milliseconds since epoch. A value of ASTARTE_INVALID_TIMESTAMP is ignored. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="a865812ad0918d678f08e70e3022ef7c8" name="a865812ad0918d678f08e70e3022ef7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a865812ad0918d678f08e70e3022ef7c8">&#9670;&#160;</a></span>astarte_device_stream_datetime_with_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_datetime_with_timestamp </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ts_epoch_millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a datetime value on a datastream endpoint with an explicit timestamp. </p>
<p>This function sends a datetime value on a path of a given datastream interface. The datetime represents the number of milliseconds since Unix epoch (1970-01-01). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">value</td><td>The value to be sent, representing the number of milliseconds since Unix epoch (1970-01-01). </td></tr>
    <tr><td class="paramname">ts_epoch_millis</td><td>The timestamp of the datastream. This is useful only on mappings with explicit_timestamp set to true and it's represented as milliseconds since epoch. A value of ASTARTE_INVALID_TIMESTAMP is ignored. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="a19ed2145151ef2e181b9f635bed5a4d8" name="a19ed2145151ef2e181b9f635bed5a4d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19ed2145151ef2e181b9f635bed5a4d8">&#9670;&#160;</a></span>astarte_device_stream_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_double </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a double value on a datastream endpoint. </p>
<p>This function sends a double value on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">value</td><td>The value to be sent. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="af3715b669b6a31c0a8ab0e9d71dd61f6" name="af3715b669b6a31c0a8ab0e9d71dd61f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3715b669b6a31c0a8ab0e9d71dd61f6">&#9670;&#160;</a></span>astarte_device_stream_double_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_double_array </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ts_epoch_millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>send a double array value on a datastream endpoint. </p>
<p>This function sends a double array value on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">values</td><td>The array of double to be sent. </td></tr>
    <tr><td class="paramname">count</td><td>The number of values stored in values array. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="a0fe888862861e457f710bea636fda763" name="a0fe888862861e457f710bea636fda763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fe888862861e457f710bea636fda763">&#9670;&#160;</a></span>astarte_device_stream_double_array_with_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_double_array_with_timestamp </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ts_epoch_millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a double array value on a datastream endpoint with an explicit timestamp. </p>
<p>This function sends a double array value on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">values</td><td>The array of double to be sent. </td></tr>
    <tr><td class="paramname">count</td><td>The number of values stored in values array. </td></tr>
    <tr><td class="paramname">ts_epoch_millis</td><td>The timestamp of the datastream. This is useful only on mappings with explicit_timestamp set to true and it's represented as milliseconds since epoch. A value of ASTARTE_INVALID_TIMESTAMP is ignored. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="a025aee78f65bdce713354fc6193494a6" name="a025aee78f65bdce713354fc6193494a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a025aee78f65bdce713354fc6193494a6">&#9670;&#160;</a></span>astarte_device_stream_double_with_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_double_with_timestamp </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ts_epoch_millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a double value on a datastream endpoint with an explicit timestamp. </p>
<p>This function sends a double value on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">value</td><td>The value to be sent. </td></tr>
    <tr><td class="paramname">ts_epoch_millis</td><td>The timestamp of the datastream. This is useful only on mappings with explicit_timestamp set to true and it's represented as milliseconds since epoch. A value of ASTARTE_INVALID_TIMESTAMP is ignored. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="a9f1fa790fd368e9855638399fc5cd970" name="a9f1fa790fd368e9855638399fc5cd970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1fa790fd368e9855638399fc5cd970">&#9670;&#160;</a></span>astarte_device_stream_integer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_integer </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a 32 bit integer value on a datastream endpoint. </p>
<p>This function sends a 32 bit int value on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">value</td><td>The value to be sent. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="ad5564a109ed290cb43d1e6aa47a96f1f" name="ad5564a109ed290cb43d1e6aa47a96f1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5564a109ed290cb43d1e6aa47a96f1f">&#9670;&#160;</a></span>astarte_device_stream_integer_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_integer_array </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>send a 32 bit integer array value on a datastream endpoint. </p>
<p>This function sends a signed 32 bit int array value on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">values</td><td>The array of int32_t to be sent. </td></tr>
    <tr><td class="paramname">count</td><td>The number of values stored in values array. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="aac0ac9e1a724fd898277264da0895f67" name="aac0ac9e1a724fd898277264da0895f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac0ac9e1a724fd898277264da0895f67">&#9670;&#160;</a></span>astarte_device_stream_integer_array_with_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_integer_array_with_timestamp </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ts_epoch_millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a 32 bit integer array value on a datastream endpoint with an explicit timestamp. </p>
<p>This function sends a signed 32 bit int array value on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">values</td><td>The array of int32_t to be sent. </td></tr>
    <tr><td class="paramname">count</td><td>The number of values stored in values array. </td></tr>
    <tr><td class="paramname">ts_epoch_millis</td><td>The timestamp of the datastream. This is useful only on mappings with explicit_timestamp set to true and it's represented as milliseconds since epoch. A value of ASTARTE_INVALID_TIMESTAMP is ignored. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="a392cd2086d86897770a0ec09f7a92039" name="a392cd2086d86897770a0ec09f7a92039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392cd2086d86897770a0ec09f7a92039">&#9670;&#160;</a></span>astarte_device_stream_integer_with_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_integer_with_timestamp </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ts_epoch_millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a 32 bit integer value on a datastream endpoint with an explicit timestamp. </p>
<p>This function sends a 32 bit int value on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">value</td><td>The value to be sent. </td></tr>
    <tr><td class="paramname">ts_epoch_millis</td><td>The timestamp of the datastream. This is useful only on mappings with explicit_timestamp set to true and it's represented as milliseconds since epoch. A value of ASTARTE_INVALID_TIMESTAMP is ignored. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="ac36b8d0d64a9f7db8f378d97d2ccace6" name="ac36b8d0d64a9f7db8f378d97d2ccace6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac36b8d0d64a9f7db8f378d97d2ccace6">&#9670;&#160;</a></span>astarte_device_stream_longinteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_longinteger </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a 64 bit integer value on a datastream endpoint. </p>
<p>This function sends a 64 bit int value on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">value</td><td>The value to be sent. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="aeb4c1b6a7569c28141be471694288716" name="aeb4c1b6a7569c28141be471694288716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb4c1b6a7569c28141be471694288716">&#9670;&#160;</a></span>astarte_device_stream_longinteger_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_longinteger_array </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>send a 64 bit integer array value on a datastream endpoint. </p>
<p>This function sends a signed 64 bit int array value on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">values</td><td>The array of int64_t to be sent. </td></tr>
    <tr><td class="paramname">count</td><td>The number of values stored in values array. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="ab5b51b0c8c3167b2464127b6d4f24a6f" name="ab5b51b0c8c3167b2464127b6d4f24a6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b51b0c8c3167b2464127b6d4f24a6f">&#9670;&#160;</a></span>astarte_device_stream_longinteger_array_with_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_longinteger_array_with_timestamp </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ts_epoch_millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a 64 bit integer array value on a datastream endpoint with an explicit timestamp. </p>
<p>This function sends a signed 64 bit int array value on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">values</td><td>The array of int64_t to be sent. </td></tr>
    <tr><td class="paramname">count</td><td>The number of values stored in values array. </td></tr>
    <tr><td class="paramname">ts_epoch_millis</td><td>The timestamp of the datastream. This is useful only on mappings with explicit_timestamp set to true and it's represented as milliseconds since epoch. A value of ASTARTE_INVALID_TIMESTAMP is ignored. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="a0f310b9353c14dbdf3f1d90d09955166" name="a0f310b9353c14dbdf3f1d90d09955166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f310b9353c14dbdf3f1d90d09955166">&#9670;&#160;</a></span>astarte_device_stream_longinteger_with_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_longinteger_with_timestamp </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ts_epoch_millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a 64 bit integer value on a datastream endpoint with an explicit timestamp. </p>
<p>This function sends a 64 bit int value on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">value</td><td>The value to be sent. </td></tr>
    <tr><td class="paramname">ts_epoch_millis</td><td>The timestamp of the datastream. This is useful only on mappings with explicit_timestamp set to true and it's represented as milliseconds since epoch. A value of ASTARTE_INVALID_TIMESTAMP is ignored. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="aa580c422aaf7ad4878be07cd8fd6559d" name="aa580c422aaf7ad4878be07cd8fd6559d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa580c422aaf7ad4878be07cd8fd6559d">&#9670;&#160;</a></span>astarte_device_stream_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_string </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a UTF8 encoded string on a datastream endpoint. </p>
<p>This function sends a UTF8 encoded string on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">value</td><td>The value to be sent (a NULL terminated string). </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="a679c016f4b0727e2ccf86d237ae7a092" name="a679c016f4b0727e2ccf86d237ae7a092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679c016f4b0727e2ccf86d237ae7a092">&#9670;&#160;</a></span>astarte_device_stream_string_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_string_array </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>send a string array value on a datastream endpoint. </p>
<p>This function sends a string array value on a path of a given datastream interface. The datetime represents the number of milliseconds since Unix epoch (1970-01-01). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">values</td><td>The array of C strings to be sent (having each one const char * type and encoded as 0 terminated UTF-8 string). </td></tr>
    <tr><td class="paramname">count</td><td>The number of values stored in values array. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="aa69b59c1982fa9c4d67275daec06f5f8" name="aa69b59c1982fa9c4d67275daec06f5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69b59c1982fa9c4d67275daec06f5f8">&#9670;&#160;</a></span>astarte_device_stream_string_array_with_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_string_array_with_timestamp </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ts_epoch_millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a string array value on a datastream endpoint with an explicit timestamp. </p>
<p>This function sends a string array value on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">values</td><td>The array of C strings to be sent (having each one const char * type and encoded as 0 terminated UTF-8 string). </td></tr>
    <tr><td class="paramname">count</td><td>The number of values stored in values array. </td></tr>
    <tr><td class="paramname">ts_epoch_millis</td><td>The timestamp of the datastream. This is useful only on mappings with explicit_timestamp set to true and it's represented as milliseconds since epoch. A value of ASTARTE_INVALID_TIMESTAMP is ignored. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="a22b3023852a97db477f7810c3652dd66" name="a22b3023852a97db477f7810c3652dd66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b3023852a97db477f7810c3652dd66">&#9670;&#160;</a></span>astarte_device_stream_string_with_timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_stream_string_with_timestamp </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>ts_epoch_millis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>qos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>send a UTF8 encoded string on a datastream endpoint with an explicit timestamp. </p>
<p>This function sends a UTF8 encoded string on a path of a given datastream interface. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
    <tr><td class="paramname">value</td><td>The value to be sent (a NULL terminated string). </td></tr>
    <tr><td class="paramname">ts_epoch_millis</td><td>The timestamp of the datastream. This is useful only on mappings with explicit_timestamp set to true and it's represented as milliseconds since epoch. A value of ASTARTE_INVALID_TIMESTAMP is ignored. </td></tr>
    <tr><td class="paramname">qos</td><td>The MQTT QoS to be used for the publish (0, 1 or 2). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
<a id="a9359c554df96f2b58bf30aeff2fff62e" name="a9359c554df96f2b58bf30aeff2fff62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9359c554df96f2b58bf30aeff2fff62e">&#9670;&#160;</a></span>astarte_device_unset_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="astarte_8h.html#a8c619a744449aa507f5e6dedebffea23">astarte_err_t</a> astarte_device_unset_path </td>
          <td>(</td>
          <td class="paramtype">astarte_device_handle_t&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>interface_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>unset a path belonging to a properties interface. </p>
<p>This function is used to unset a path. It is possible to use it only with an interface of type properties and on a path belonging to an endpoint with allow_unset set to true. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A started Astarte device handle. </td></tr>
    <tr><td class="paramname">interface_name</td><td>A string containing the name of the interface. </td></tr>
    <tr><td class="paramname">path</td><td>A string containing the path (beginning with /). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ASTARTE_OK if the value was correctly published, another astarte_err_t otherwise. Note that this just checks that the publish sequence correctly started, i.e. it doesn't wait for PUBACK for QoS 1 messages or for PUBCOMP for QoS 2 messages </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="astarte__device_8h.html">astarte_device.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
