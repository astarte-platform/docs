searchNodes=[{"ref":"001-intro_architecture.html","title":"Introduction","module":"001-intro_architecture","type":"extras","doc":"Introduction Astarte is a collection of components written in Elixir meant to orchestrate and pilot a number of 3rd party components. These components include: One or more ingresses (the most popular implementation being an MQTT broker) An AMQP broker for handling messages and queues between Astarte&#39;s services A Cassandra-like Database for ingesting and retrieving data (currently Cassandra and ScyllaDB are both supported) These components are never directly exposed to Astarte&#39;s end user, who requires no knowledge whatsoever of the mentioned frameworks - they are rather orchestrated and managed directly by Astarte&#39;s services. It is, however, responsability of Astarte&#39;s administrators to make sure these services are made available the way they are meant to. For more details on this topic and, in general, on how to deal with Astarte&#39;s installation and maintenance, please refer to the Administrator Guide."},{"ref":"010-design_principles.html","title":"Design Principles","module":"010-design_principles","type":"extras","doc":"Design Principles Astarte has a strongly opinionated design aimed at the generic IoT / data-driven use case. As such, and unlike other platforms, it strives to streamline a very simple user workflow for ingesting, distributing and retrieving data, built on a set of concepts and principles."},{"ref":"010-design_principles.html#declarative-vs-explicit-data-management","title":"Design Principles - Declarative vs. Explicit Data Management","module":"010-design_principles","type":"extras","doc":"Astarte does not allow exchanging raw data - it rather forces the user to describe data before it is sent into the platform. Data is described with a mechanism named Interfaces, explained in detail in the user guide. Through Interfaces, Astarte creates and maintains a data model autonomously, sparing the user from the complexity of dealing with Databases and Data Management in general."},{"ref":"010-design_principles.html#amqp-as-internal-api-mechanism","title":"Design Principles - AMQP as internal API mechanism","module":"010-design_principles","type":"extras","doc":"Astarte services use a Protobuf-based API to exchange data over AMQP in a gRPC like fashion. As such, as long as a service conforms with the policies defined by the queues, it is possible to extend Astarte in virtually any language that can deliver a compliant AMQP client."},{"ref":"010-design_principles.html#device-id","title":"Design Principles - Device ID","module":"010-design_principles","type":"extras","doc":"Astarte identifies each device with a 128 bit Device ID which has to be unique within its Realm. As a best practice, it is advised to generate such an ID from hardware unique IDs or using dedicated hardware modules, to make it consistent across device reflashes. It is advised to use a cryptographic hash function (such as sha256) when generating it using a software module. Astarte will use URL encoded base64 (without padding) strings like V_zv6ThCCtXWveQ8mPjsKg in its representation. This detail is relevant not only for identifying and querying the device, but also for the Pairing mechanism, as a device&#39;s credentials are associated to its Device ID. Note: currently, Astarte accepts Device IDs longer than 128 bit, which are then truncated to 128 bit internally. This behaviour exists for compatibility reasons but it&#39;s not supported and will likely change in future releases - hence, refrain from using anything which is not a 128-bit Device ID. Note: As much as Device IDs should effectively be unique per-realm and this configuration will always be supported, some future optional optimizations might be available on top of the assumption that Device IDs are globally unique to an Astarte installation. Given the Device ID format has a 2-128 chance of collision, it is safe to assume that as long as best practices for Device ID generation are followed, Device IDs will always be globally unique."},{"ref":"010-design_principles.html#device-interaction","title":"Design Principles - Device interaction","module":"010-design_principles","type":"extras","doc":"Astarte assumes devices are capable of exchanging data over a transport/protocol supporting SSL/TLS (e.g.: MQTT). This is a strong requirement, as Astarte identifies devices through client SSL certificates when it comes to data exchange. Each transport implementation must be capable of mapping interfaces and out-of-band messages on top of it. Astarte itself does not care about the implementation detail of the transport itself, as the transport is in charge of converting its input to an AMQP message following Astarte&#39;s internal API specification. Astarte&#39;s official reference and recommended design is MQTT using VerneMQ and its Astarte plugin. Device SDK and code generation Device SDKs can take advantage of the interface design to dynamically generate code for exchanging data with Astarte. This way, developers using Device SDKs are spared from knowing details about the underlying transports and protocols, and can use a data-driven API. However, there are some limitations and requirements: The SDK requires SSL support - Astarte does not allow exchanging data over unencrypted channels and its design builds on the assumption that everything runs on top of SSL. If your device isn&#39;t capable of SSL, you are probably looking for Gateway support in Astarte. As much as the SDK can implement virtually any transport protocol, it is required that the SDK supports at least HTTP(s) for Pairing."},{"ref":"010-design_principles.html#realms-and-multitenancy","title":"Design Principles - Realms and multitenancy","module":"010-design_principles","type":"extras","doc":"Astarte is natively multitenant through the concept of Realms. Each Realm is a logical portion of Astarte, and usually represents an organization or, in general, a set of devices physically/logically isolated. Realms build upon the concept of keyspaces in Cassandra. Each Realm has its very own keyspace and has no shared data with other Realms. In fact, it is even possible to have a dedicated Cassandra cluster for a single realm in complex installations."},{"ref":"010-design_principles.html#message-ordering","title":"Design Principles - Message Ordering","module":"010-design_principles","type":"extras","doc":"In Astarte, transports are given the task to deliver messages in a well-known AMQP structure. The ordering of such messages is then preserved on a set of criterias: There is no such thing as &quot;in-order&quot; among devices. A message X sent to device A can be processed after a message Y sent to device B even if Y was ingested in the AMQP queue before X. This is intentional and by design. All messages to a specific device A are always guaranteed to be processed in the very same order of the transport ingestion. Ordering is not dependent on the message timestamp, which can be set by different sources (depending on the interface&#39;s definition of timestamp). For example, interface A has explicit timestamping while interface B doesn&#39;t. Message X from A has an earlier timestamp than message Y from B, but if message Y has been ingested before X, Y will be processed before X regardless. Responsibility of message ordering before entering AMQP is entirely up to the transport, and different transports might have different behaviors when it comes to message ordering. Astarte provides this guarantee right after the transport itself. Message ordering concerns only pipelines in the DUP, including but not limited to data ingestion in the Database and Simple Triggers."},{"ref":"010-design_principles.html#triggers","title":"Design Principles - Triggers","module":"010-design_principles","type":"extras","doc":"Triggers are rules which are &quot;triggered&quot; whenever one or more conditions are satisfied. Every satisfied condition generates an ordered event for the Trigger Engine to be processed. They are one of the core concepts in Astarte and are the preferred way to handle push interactions between Astarte and connected applications. More details about triggers can be found in the dedicated section."},{"ref":"020-components.html","title":"Components","module":"020-components","type":"extras","doc":"Components Astarte is a distributed system interacting over AMQP, as explained in Design Principles. This is an overview of its main internal services."},{"ref":"020-components.html#pairing","title":"Components - Pairing","module":"020-components","type":"extras","doc":"Pairing takes care of Device Authentication and Authorization. It interacts with Astarte&#39;s CA and orchestrates the way devices connect and interact with Transports. It also handles Device Registration. Agent, Device and Pairing interaction is described in detail here."},{"ref":"020-components.html#data-updater-plant-dup","title":"Components - Data Updater Plant (DUP)","module":"020-components","type":"extras","doc":"Data Updater Plant is a replicable, scalable component which takes care of the ingestion pipeline. It gathers data from devices and orchestrates data flow amongst other components. It is, arguably, the most critical component of the system and the most resource hungry - the way DUP is deployed, replicated and configured has a tremendous impact on Astarte&#39;s performances, especially when dealing with massive data flows."},{"ref":"020-components.html#trigger-engine","title":"Components - Trigger Engine","module":"020-components","type":"extras","doc":"Trigger Engine takes care of processing Triggers. It is a purely computational component which handles every Trigger&#39;s pipeline and triggers actions accordingly."},{"ref":"020-components.html#appengine","title":"Components - AppEngine","module":"020-components","type":"extras","doc":"AppEngine is Astarte&#39;s main API endpoint for end users. AppEngine exposes a RESTful API to retrieve and send data from/to devices, according to their interfaces. Every direct device interaction can be done from here. It also exposes Channels, a WebSocket-based solution for listening to device events in real-time with Triggers&#39; same mechanism and semantics."},{"ref":"020-components.html#realm-management","title":"Components - Realm Management","module":"020-components","type":"extras","doc":"Realm Management is an administrator-like API for configuring a Realm. It is used for managing Interfaces, Triggers, Devices and more."},{"ref":"020-components.html#housekeeping","title":"Components - Housekeeping","module":"020-components","type":"extras","doc":"Housekeeping is the equivalent of a superadmin API. It is usually not accessible to the end user but rather to Astarte&#39;s administrator who, in most cases, might deny overall outside access. It allows to manage and create Realms, and perform cluster-wide maintenance actions."},{"ref":"030-interface.html","title":"Interfaces","module":"030-interface","type":"extras","doc":"Interfaces Interfaces are a core concept of Astarte which defines how data is exchanged between Astarte and its peers. They are not to be intended as OOP interfaces, but rather as the following definition: In computing, an interface is a shared boundary across which two or more separate components of a computer system exchange information. In Astarte each interface has an owner, can represent either a continuous data stream or a snapshot of a set of properties, and can be either aggregated into an object or be an independent set of individual members. If you are already familiar with interface&#39;s basic concepts, you might want to jump directly to the Interface Schema."},{"ref":"030-interface.html#versioning","title":"Interfaces - Versioning","module":"030-interface","type":"extras","doc":"Interfaces are versioned, each interface having both a major version and a minor version number. The concept behind these two version numbers mimics Semantic Versioning: arbitrary changes can happen exclusively between different major versions (e.g. removing members, changing types, etc...), whereas minor versions allow incremental additive changes only (e.g. adding members). Several different major versions of the same interface can coexist at the same time in Astarte, although a Device can hold only a single version of an interface at a time (even though interfaces can be updated over time). Interfaces, internally, are univocally identified by their name and their major version."},{"ref":"030-interface.html#format","title":"Interfaces - Format","module":"030-interface","type":"extras","doc":"Interfaces are described using a JSON document. Each interface is identified by an unique interface name of maximum 128 characters, which must be a Reverse Domain Name. As a convention, the interface name usually contains its author&#39;s URI Reverse Internet Domain Name. An example skeleton looks like this: { &quot;interface_name&quot;: &quot;com.test.MyInterfaceName&quot;, &quot;version_major&quot;: 1, &quot;version_minor&quot;: 0, [...] } Valid values and variables are listed in the Interface Schema."},{"ref":"030-interface.html#interface-type","title":"Interfaces - Interface Type","module":"030-interface","type":"extras","doc":"Interfaces have a well-known, predefined type, which can be either property or datastream. Every Device in Astarte can have any number of interfaces of any different types. Datastream datastream represents a mutable, ordered stream of data, with no concept of persistent state or synchronization. As a rule of thumb, datastream interfaces should be used when dealing with values such as sensor samples, commands and events. datastream are stored as time series in the database, making them suitable for time span filtering and any other common time series operation, and they are not idempotent in the REST API semantics. Due to their nature, datastream interfaces have a number of additional properties which fine tune their behavior. Properties properties represent a persistent, stateful, synchronized state with no concept of history or timestamping. properties are useful, for example, when dealing with settings, states or policies/rules. properties are stored in a key-value fashion, and grouped according to their interface, and they are idempotent in the REST API semantics. Rather than being able to act on a stream like in the datastream case, properties can be retrieved, or can be used as a trigger whenever they change. Values in a properties interface can be unset (or deleted according to the http jargon): to allow such a thing, the interface must have its allow_unset property set to true. Please refer to the JSON Schema for further details."},{"ref":"030-interface.html#ownership","title":"Interfaces - Ownership","module":"030-interface","type":"extras","doc":"Astarte&#39;s design mandates that each interface has an owner. The owner of an interface has a write-only access to it, whereas other actors have read-only access. Interface ownership can be either device or server: the owner is the actor producing the data, whereas the other actor consumes data."},{"ref":"030-interface.html#mappings","title":"Interfaces - Mappings","module":"030-interface","type":"extras","doc":"Every interface must have an array of mappings. Mappings are designed around REST controller semantics: each mapping describes an endpoint which is resolved to a path, it is strongly typed, and can have additional options. Just like in REST controllers, Endpoints can be parametrized to build REST-like collection and trees. Parameters are identified by %{parameterName}, with each endpoint supporting any number of parameters (see Limitations). This is how a parametrized mapping looks like: [...] &quot;mappings&quot;: [ { &quot;endpoint&quot;: &quot;/%{itemIndex}/value&quot;, &quot;type&quot;: &quot;integer&quot;, &quot;reliability&quot;: &quot;unique&quot;, &quot;retention&quot;: &quot;discard&quot; }, [...] In this example, /0/value, /1/value or /test/value all map to a valid endpoint, while /te/st/value can&#39;t be resolved by any endpoint. Supported data types The following types are supported: double: A double-precision floating-point format as specified by binary64, by the IEEE 754 standard integer: A signed 32 bit integer. boolean: Either true or false, adhering to JSON boolean type. longinteger: A signed 64 bit integer (please note that longinteger is represented as a string by default in JSON-based APIs.). string: An UTF-8 string. binaryblob: An arbitrary sequence of any byte that should be shorter than 1 MiB. (binaryblob is represented as a base64 string by default in JSON-based APIs.). datetime: A UTC timestamp, internally represented as milliseconds since 1st Jan 1970 using a signed 64 bits integer. (datetime is represented as an ISO 8601 string by default in JSON based APIs.) doublearray, integerarray, booleanarray, longintegerarray, stringarray, binaryblobarray, datetimearray: A list of values, represented as a JSON Array. Arrays can have up to 32768 items, must be shorter than 1MiB, and each item must be shorter than 64KiB. In particular, text fields must be shorter than 32000 characters. Limitations A valid interface must resolve a path univocally to a single endpoint. Take the following example: [...] &quot;mappings&quot;: [ { &quot;endpoint&quot;: &quot;/%{itemIndex}/value&quot;, &quot;type&quot;: &quot;integer&quot; }, { &quot;endpoint&quot;: &quot;/myPath/value&quot;, &quot;type&quot;: &quot;integer&quot; }, [...] In such a case, the interface isn&#39;t valid and is rejected, due to the fact that path /myPath/value is ambiguous and could be resolved to two different endpoints. Any endpoint configuration must not generate paths that are prefix of other paths, for this reason the following example is also invalid: [...] &quot;mappings&quot;: [ { &quot;endpoint&quot;: &quot;/some/thing&quot;, &quot;type&quot;: &quot;integer&quot; }, { &quot;endpoint&quot;: &quot;/some/%{param}/value&quot;, &quot;type&quot;: &quot;integer&quot; }, [...] In case the interface&#39;s aggregation is object, additional restrictions apply. Endpoints in the same interface must all have the same depth, and the same number of parameters. If the interface is parametrized, every endpoint must have the same parameter name at the same level. This is an example of a valid aggregated interface mapping: [...] &quot;mappings&quot;: [ { &quot;endpoint&quot;: &quot;/%{itemIndex}/value&quot;, &quot;type&quot;: &quot;integer&quot; }, { &quot;endpoint&quot;: &quot;/%{itemIndex}/otherValue&quot;, &quot;type&quot;: &quot;string&quot; }, [...]"},{"ref":"030-interface.html#aggregation","title":"Interfaces - Aggregation","module":"030-interface","type":"extras","doc":"In a real world scenario, such as an array of sensors, there are usually two main cases. A sensor might have one or more independent values which are sampled individually and sent whenever they become available independently. Or a sensor might sample at the same time a number of values, which might as well have some form of correlation. In Astarte, this concept is mapped to interface aggregation. In case aggregation is individual, each mapping is treated as an independent value and is managed individually. In case aggregation is object, Astarte expects the owner to send all of the interface&#39;s mappings at the same time, packed in a single message. In this case, all of the mappings share some core properties such as the timestamp. Aggregation is a powerful mechanism that can be used to map interfaces to real world &quot;objects&quot;. Moreover, aggregated interfaces can also be parametrized, although with some limitations."},{"ref":"030-interface.html#metadata","title":"Interfaces - Metadata","module":"030-interface","type":"extras","doc":"In case aggregation is individual, it might be desirable to attach some additional information to each value when it gets produced. In this case, Astarte allows to attach metadata: a map of key:value pairs which can contain arbitrary, schema-less data. Metadata is not indexed, but can be optionally retrieved or used in triggers. Metadata is disabled by default: you can enable metadata on an interface by setting has_metadata to true."},{"ref":"030-interface.html#datastream-specific-features","title":"Interfaces - Datastream-specific features","module":"030-interface","type":"extras","doc":"datastream interfaces are highly tunable, depending on the kind of data they are representing: it is possible to fine tune several aspects of how data is stored, transferred and indexed. The following properties can be set either at interface level, making them the default for each mapping, or at mapping level, overriding any interface-wide setting. NOTE: In case the interface is aggregated, overriding any additional properties at mapping level does not have any effect, and might cause a validation error. explicit_timestamp: By default, Astarte associates a timestamp to data whenever it is collected (or - when the message hits the data collection stage). However, when setting this property to true, Astarte expects the owner to attach a valid timestamp each time it produces data. In that case, the provided timestamp is used for indexing. reliability: Each mapping can be unreliable (default), guaranteed, unique. This defines whether data should be considered delivered when the transport successfully sends the data regardless of the outcome (unreliable), when data has been received at least once by the recipient (guaranteed) or when data has been received exactly once by the recipient (unique). When using reliable data, consider you might incur in additional resource usage on both the transport and the device&#39;s end. retention: Each mapping can have a discard (default), volatile, stored retention. This defines whether data should be discarded if the transport is temporarily uncapable of delivering it (discard), should be kept in a cache in memory (volatile) or on disk (stored), and guaranteed to be delivered in the timeframe defined by the expiry. expiry: Meaningful only when retention is stored. Defines how many seconds a specific data entry should be kept before giving up and erasing it from the persistent cache. A value &lt;= 0 means the persistent cache never expires, and is the default."},{"ref":"030-interface.html#best-practices","title":"Interfaces - Best practices","module":"030-interface","type":"extras","doc":"When creating interface drafts, or for testing purposes in general, it is recommended to use 0 as the major version, to make maintenance and testing easier. Currently, Astarte allows only interfaces with major_version == 0 to be deleted, and this limitation will probably be never lifted to prevent data loss. When sending real time commands in datastream interfaces, discard is usually the best option. Even though it does not guarantee delivery, it prevents users from unwillingly sending the same command over and over if the recipient isn&#39;t available, causing a queue of commands to be sent to the recipient when it gets back online. In general, retention should be used to keep track of low traffic/important events"},{"ref":"040-interface_schema.html","title":"Interface Schema","module":"040-interface_schema","type":"extras","doc":"Interface Schema The schema contains the following objects: Interface (root object) Mapping"},{"ref":"040-interface_schema.html#interface","title":"Interface Schema - Interface","module":"040-interface_schema","type":"extras","doc":"This schema describes how an Astarte interface should be declared Properties TypeDescriptionRequired interface_namestringThe name of the interface. This has to be an unique, alphanumeric reverse internet domain name, shorther than 128 characters.:white_check_mark: Yes version_majorintegerA Major version qualifier for this interface. Interfaces with the same id and different version_major number are deemed incompatible. It is then acceptable to redefine any property of the interface when changing the major version number.:white_check_mark: Yes version_minorintegerA Minor version qualifier for this interface. Interfaces with the same id and major version number and different version_minor number are deemed compatible between each other. When changing the minor number, it is then only possible to insert further mappings. Any other modification might lead to incompatibilities and undefined behavior.:white_check_mark: Yes typestringIdentifies the type of this Interface. Currently two types are supported: datastream and properties. datastream should be used when dealing with streams of non-persistent data, where a single path receives updates and there&#39;s no concept of state. properties, instead, are meant to be an actual state and as such they have only a change history, and are retained.:white_check_mark: Yes ownershipstringIdentifies the quality of the interface. Interfaces are meant to be unidirectional, and this property defines who&#39;s sending or receiving data. device means the device/gateway is sending data to Astarte, consumer means the device/gateway is receiving data from Astarte. Bidirectional mode is not supported, you should instantiate another interface for that.:white_check_mark: Yes aggregationstringIdentifies the aggregation of the mappings of the interface. Individual means every mapping changes state or streams data independently, whereas an object aggregation treats the interface as an object, making all the mappings changes interdependent. Choosing the right aggregation might drastically improve performances.No, default: &quot;individual&quot; explicit_timestampbooleanAllow to set a custom timestamp, otherwise a timestamp is added when the message is received. If true explicit timestamp will also be used for sorting. This feature is only supported on datastreams.No, default: false has_metadatabooleanIf true it will be possible to decorate the value with additional metadata. This feature is only supported on non aggregate interfaces.No, default: false descriptionstringAn optional description of the interface.No docstringA string containing documentation that will be injected in the generated client code.No mappingsAstarte Mapping Schema [1-1024]Mappings define the endpoint of the interface, where actual data is stored/streamed. They are defined as relative URLs (e.g. /my/path) and can be parametrized (e.g.: /%{myparam}/path). A valid interface must have no mappings clash, which means that every mapping must resolve to a unique path or collection of paths (including parametrization). Every mapping acquires type, quality and aggregation of the interface.:white_check_mark: Yes Additional properties are allowed. astarte.interface.schema.interface_name :white_check_mark: The name of the interface. This has to be an unique, alphanumeric reverse internet domain name, shorther than 128 characters. Type: string Required: Yes Minimum Length: &gt;= 1 astarte.interface.schema.version_major :white_check_mark: A Major version qualifier for this interface. Interfaces with the same id and different version_major number are deemed incompatible. It is then acceptable to redefine any property of the interface when changing the major version number. Type: integer Required: Yes astarte.interface.schema.version_minor :white_check_mark: A Minor version qualifier for this interface. Interfaces with the same id and major version number and different version_minor number are deemed compatible between each other. When changing the minor number, it is then only possible to insert further mappings. Any other modification might lead to incompatibilities and undefined behavior. Type: integer Required: Yes astarte.interface.schema.type :white_check_mark: Identifies the type of this Interface. Currently two types are supported: datastream and properties. datastream should be used when dealing with streams of non-persistent data, where a single path receives updates and there&#39;s no concept of state. properties, instead, are meant to be an actual state and as such they have only a change history, and are retained. Type: string Required: Yes Allowed values: &quot;datastream&quot; &quot;properties&quot; astarte.interface.schema.ownership :white_check_mark: Identifies the quality of the interface. Interfaces are meant to be unidirectional, and this property defines who&#39;s sending or receiving data. device means the device/gateway is sending data to Astarte, consumer means the device/gateway is receiving data from Astarte. Bidirectional mode is not supported, you should instantiate another interface for that. Type: string Required: Yes Allowed values: &quot;device&quot; &quot;server&quot; astarte.interface.schema.aggregation Identifies the aggregation of the mappings of the interface. Individual means every mapping changes state or streams data independently, whereas an object aggregation treats the interface as an object, making all the mappings changes interdependent. Choosing the right aggregation might drastically improve performances. Type: string Required: No, default: &quot;individual&quot; Allowed values: &quot;individual&quot; &quot;object&quot; astarte.interface.schema.explicit_timestamp Allow to set a custom timestamp, otherwise a timestamp is added when the message is received. If true explicit timestamp will also be used for sorting. This feature is only supported on datastreams. Type: boolean Required: No, default: false astarte.interface.schema.has_metadata If true it will be possible to decorate the value with additional metadata. This feature is only supported on non aggregate interfaces. Type: boolean Required: No, default: false astarte.interface.schema.description An optional description of the interface. Type: string Required: No astarte.interface.schema.doc A string containing documentation that will be injected in the generated client code. Type: string Required: No astarte.interface.schema.mappings :white_check_mark: Mappings define the endpoint of the interface, where actual data is stored/streamed. They are defined as relative URLs (e.g. /my/path) and can be parametrized (e.g.: /%{myparam}/path). A valid interface must have no mappings clash, which means that every mapping must resolve to a unique path or collection of paths (including parametrization). Every mapping acquires type, quality and aggregation of the interface. Type: Astarte Mapping Schema [1-1024] Each element in the array must be unique. Required: Yes"},{"ref":"040-interface_schema.html#mapping","title":"Interface Schema - Mapping","module":"040-interface_schema","type":"extras","doc":"Identifies a mapping for an interface. A mapping must consist at least of an endpoint and a type. Properties TypeDescriptionRequired endpointstringThe template of the path. This is a UNIX-like path (e.g. /my/path) and can be parametrized. Parameters are in the %{name} form, and can be used to create interfaces which represent dictionaries of mappings. When the interface aggregation is object, an object is composed by all the mappings for one specific parameter combination.:white_check_mark: Yes typestringDefines the type of the mapping.:white_check_mark: Yes reliabilitystringUseful only with datastream. Defines whether the sent data should be considered delivered when the transport successfully sends the data (unreliable), when we know that the data has been received at least once (guaranteed) or when we know that the data has been received exactly once (unique). unreliable by default. When using reliable data, consider you might incur in additional resource usage on both the transport and the device&#39;s end.No, default: &quot;unreliable&quot; retentionstringUseful only with datastream. Defines whether the sent data should be discarded if the transport is temporarily uncapable of delivering it (discard) or should be kept in a cache in memory (volatile) or on disk (stored), and guaranteed to be delivered in the timeframe defined by the expiry. discard by default.No, default: &quot;discard&quot; expiryintegerUseful when retention is stored. Defines after how many seconds a specific data entry should be kept before giving up and erasing it from the persistent cache. A value &lt;= 0 means the persistent cache never expires, and is the default.No, default: 0 allow_unsetbooleanUsed only with properties. Used with producers, it generates a method to unset the property. Used with consumers, it generates code to call an unset method when an empty payload is received.No, default: false descriptionstringAn optional description of the mapping.No docstringA string containing documentation that will be injected in the generated client code.No Additional properties are allowed. astarte.mapping.schema.endpoint :white_check_mark: The template of the path. This is a UNIX-like path (e.g. /my/path) and can be parametrized. Parameters are in the %{name} form, and can be used to create interfaces which represent dictionaries of mappings. When the interface aggregation is object, an object is composed by all the mappings for one specific parameter combination. Type: string Required: Yes Minimum Length: &gt;= 2 astarte.mapping.schema.type :white_check_mark: Defines the type of the mapping. Type: string Required: Yes Allowed values: &quot;double&quot; &quot;integer&quot; &quot;boolean&quot; &quot;longinteger&quot; &quot;string&quot; &quot;binaryblob&quot; &quot;datetime&quot; &quot;doublearray&quot; &quot;integerarray&quot; &quot;booleanarray&quot; &quot;longintegerarray&quot; &quot;stringarray&quot; &quot;binaryblobarray&quot; &quot;datetimearray&quot; astarte.mapping.schema.reliability Useful only with datastream. Defines whether the sent data should be considered delivered when the transport successfully sends the data (unreliable), when we know that the data has been received at least once (guaranteed) or when we know that the data has been received exactly once (unique). unreliable by default. When using reliable data, consider you might incur in additional resource usage on both the transport and the device&#39;s end. Type: string Required: No, default: &quot;unreliable&quot; Allowed values: &quot;unreliable&quot; &quot;guaranteed&quot; &quot;unique&quot; astarte.mapping.schema.retention Useful only with datastream. Defines whether the sent data should be discarded if the transport is temporarily uncapable of delivering it (discard) or should be kept in a cache in memory (volatile) or on disk (stored), and guaranteed to be delivered in the timeframe defined by the expiry. discard by default. Type: string Required: No, default: &quot;discard&quot; Allowed values: &quot;discard&quot; &quot;volatile&quot; &quot;stored&quot; astarte.mapping.schema.expiry Useful when retention is stored. Defines after how many seconds a specific data entry should be kept before giving up and erasing it from the persistent cache. A value &lt;= 0 means the persistent cache never expires, and is the default. Type: integer Required: No, default: 0 astarte.mapping.schema.allow_unset Used only with properties. Used with producers, it generates a method to unset the property. Used with consumers, it generates code to call an unset method when an empty payload is received. Type: boolean Required: No, default: false astarte.mapping.schema.description An optional description of the mapping. Type: string Required: No astarte.mapping.schema.doc A string containing documentation that will be injected in the generated client code. Type: string Required: No"},{"ref":"050-pairing_mechanism.html","title":"Pairing Mechanism","module":"050-pairing_mechanism","type":"extras","doc":"Pairing Mechanism Astarte&#39;s Pairing is a unified mechanism for Registering Devices and obtaining Transport Credentials. Even though in Astarte each Transport is free to choose its own Authentication mechanisms and Credentials autonomously, Pairing defines a well-known mechanism for Registering Devices and for orchestrating the exchange of Transport Credentials. Pairing is the main endpoint which orchestrates Device Authentication in Astarte, abstracting all details."},{"ref":"050-pairing_mechanism.html#authentication-flow","title":"Pairing Mechanism - Authentication flow","module":"050-pairing_mechanism","type":"extras","doc":""},{"ref":"050-pairing_mechanism.html#credentials-secret-vs-transport-credentials","title":"Pairing Mechanism - Credentials Secret vs. Transport Credentials","module":"050-pairing_mechanism","type":"extras","doc":"Each device is identified by a Device ID and, on top of that, it has two different credentials directly associated to its ID: Credentials Secret and Transport Credentials. Credentials Secret is a shared secret between Astarte and a Device, which are used only to authenticate against Pairing API. Each device has a single Credentials Secret which remains valid throughout its whole lifecycle, and cannot be changed (unless operating manually). Transport Credentials are Transport-specific credentials usually orchestrated by Pairing. Pairing emits these Credentials through a policy which is usually imposed by the Authority emitting the Credentials or by Pairing itself. They are designed to be transient, revokable and reasonably short-lived - however, the actual behavior and their lifecycle is entirely orchestrated by the Authority emitting them. Transports, by design, have no knowledge nor access to Credentials Secret, but have full authority over the authentication mechanism for devices. In fact, each Transport is free to choose the authentication mechanism which fits it best. Credentials Secret storage recommendations As losing or disclosing a Credentials Secret might mean a device is compromised or requires manual intervention to be fixed and secured, storing it appropriately is critical. Usually, when it comes to embedded devices, it is advised to store the Credentials Secret into an OTP, if available. Otherwise, storing it into the bootloader&#39;s variables is a viable and safe alternative. Other options might be having a separate, isolated storage containing Credentials Secret. In general, Astarte SDK does not provide a streamlined mechanism for retrieving Credentials Secret as the storage detail is strongly dependent on the target hardware - device developers should implement the safest strategy which better complies with their policies. Tuning devices for security is out of the scope of this guide, however it is advised to make sure only Astarte SDK has access to Credentials Secret."},{"ref":"050-pairing_mechanism.html#using-ssl-certificates-as-transport-credentials","title":"Pairing Mechanism - Using SSL Certificates as Transport Credentials","module":"050-pairing_mechanism","type":"extras","doc":"Whenever possible, Transports are advised to implement their Authentication through the use of SSL certificates and a certificate authority by using Mutual Authentication, to ensure identities of the endpoint and the client are well-known to each other - this is especially the case with Astarte&#39;s MQTT Protocol on top of VerneMQ Transport. In this case, Transport Credentials are a SSL Certificate, and Pairing will interact with a Certificate Authority. The certificate rotates depending on the emission policy of the CA and can be renewed and invalidated countless times over the device lifecycle. The Certificate is a transient, asymmetric, device-specific, non-critical Transport Credential which can be in turn used to authenticate against the chosen Transport. In this case, Transports should have no knowledge nor access to secrets or Authorization details: they rather have to comply with the configured CA and the certificate parsing, as the Certificate contains all needed information for Authorization as well. Mutual SSL Authentication Flow Side note: the Transport usually bears the public certificate of the CA, and actually interacts with the CA itself only if it exposes an OCSP endpoint and the Transport is capable of understanding it. In case the CA exposes a CRL, the Transport just makes sure to update its CRL from the CA every once in a while. In both cases, Transport&#39;s only interaction with the CA is the configuration of its SSL endpoint. Certificate Authority Pairing is designed to interact with an abstract certificate authority, given this authority is capable of: Emitting SSL Certificates with a custom CN (this is important in the Transport authentication flow) Revoking emitted certificates and exposing CRL/OCSP revocation information and is accessible from a 3rd party (e.g. from a REST API). By default, Astarte supports Cloudflare&#39;s CFSSL, and also provides a minimal installation in its default deploy scripts. For bigger installations, especially in terms of number of connected devices, it is strongly advised to use a dedicated CFSSL installation. Also, Astarte Enterprise provides a number of additional features including support for other external CAs. Certificate flow During the Pairing flow, the device must generate autonomously a Certificate Signing Request (CSR) which will be in turn relayed by Pairing to the configured Certificate Authority. Pairing will also provide the Certificate Authority with a custom CN, which maps to &lt;realm&gt;/&lt;device id&gt;. The CA must ensure the signed certificate carries this information, as it will be used by the Transport to authenticate the caller inside Astarte. Pairing, in fact, will also perform sanity checks over the signed certificate and reject it in case the CA fails to comply."},{"ref":"050-pairing_mechanism.html#agents","title":"Pairing Mechanism - Agents","module":"050-pairing_mechanism","type":"extras","doc":"Agents are realm-level entities capable of registering a device into Astarte. Agents are a core concept in the Pairing mechanism, as no Device can request its Transport Credentials nor be authenticated against any Transport unless an Agent previously gave its consent and delivered its Credentials Secret. The recommended configuration includes an authenticated Agent in a trusted physical environment (e.g.: the distribution facility of the device) which guarantees an isolated and safe routine for generating Credentials Secret. However, such a setup might not always be possible, and Astarte&#39;s SDK has an On Board Agent concept to allow a simpler registration procedure. On Board Agent In the On Board Agent use case, the device is preloaded with an Agent Key, a shared secret which is not tied to a specific Device in the realm. In fact, this secret is usually the same for all Devices in the same realm. This secret will be used only once, upon the device&#39;s first interaction with Astarte (Registration), and can be safely discarded afterwards. This approach largely simplifies the deploy procedure, but leaves every device with a secret which, if retrieved, can allow an entity to register an arbitrary Device in the realm. If following the On Board Agent approach, it is advised to store the Agent Key in a safe area inside the device and delete it after retrieving a Credentials Secret (some OTPs allow this configuration)."},{"ref":"050-pairing_mechanism.html#transport-responsibility","title":"Pairing Mechanism - Transport responsibility","module":"050-pairing_mechanism","type":"extras","doc":"Once a device obtains its Transport Credentials, it is then capable of connecting to the Transport the credentials were forged for. Transports have full responsibility in terms of authenticating the client, reporting and relaying its connection state to Astarte via its internal AMQP API. As such, it is fundamental that 3rd parties implementing new Transports not only adhere to protocol specifications, but also make sure to implement the authentication procedure meticolously, as a vulnerable Transport acts as a single point of failure of the whole system, and is capable of bypassing the Pairing workflow entirely. For this very reason, we encourage users to be extremely cautious when using 3rd party Transports which have not been verified and hardly tested, especially when it comes to the Client Authentication stage. Even though there are valid use cases where Mutual Authentication is not usable, Transports are advised to stick to Mutual SSL Authentication where possible. This, among other benefits, allows to use Pairing&#39;s core features for handling SSL Certificates."},{"ref":"050-pairing_mechanism.html#pairing-facilities","title":"Pairing Mechanism - Pairing facilities","module":"050-pairing_mechanism","type":"extras","doc":"Pairing&#39;s Device API exposes two additional facilities: first and foremost an endpoint which bears a set of information about both Pairing itself and Transports the device should use or choose from. This endpoint is Device and Realm specific and can be found at /{realm_name}/devices/{hw_id}. This allows granting each Device a specific Transport configuration, which can be useful in installations with more than a single Transport, and automates the configuration on the Device&#39;s end, which knows in advance what is supported and how to access its Transport(s). Moreover, each Transport implementation has a /verify endpoint where a client, authenticating with its Credentials Secret, can verify whether its Transport Credentials are valid or not. This, in case SSL is used, is especially useful for checking against revocation lists."},{"ref":"060-triggers.html","title":"Triggers","module":"060-triggers","type":"extras","doc":"Triggers Triggers in Astarte are the go-to mechanism for generating push events. In contrast with AppEngine&#39;s REST APIs, Triggers allow users to specify conditions upon which a custom payload is delivered to a recipient, using a specific action, which usually maps to a specific transport/protocol, such as HTTP. Each trigger is defined by two main components: condition and action."},{"ref":"060-triggers.html#condition","title":"Triggers - Condition","module":"060-triggers","type":"extras","doc":"A condition defines the event (or chain of events) upon which an action is triggered. Astarte monitors incoming events and triggers a corresponding action whenever there is a match."},{"ref":"060-triggers.html#action","title":"Triggers - Action","module":"060-triggers","type":"extras","doc":"Actions are triggered by a matching condition. An Action defines how the event should be sent to the outer world (e.g. an http POST on a certain URL). In addition, most actions have a Payload, which carries the body of the event. Payloads are most of the time plain-text, and Astarte provides several ways to generate them. By default Astarte generates a JSON payload with all the relevant information of the event. This is also the format used when delivering payloads in Astarte Channels. The format for each payload can be found in the simple events encoder. In the foreseeable future, more user friendly documentation about json payloads will be provided. Astarte also provides a powerful templating mechanism for plain-text payloads based on top of Mustache. This is especially useful for integrating with third-party actors which require custom payload formats. Given this kind of flexibility, triggers are the most powerful way to push data to an external service, potentially without any additional customization."},{"ref":"060-triggers.html#relationship-with-channels","title":"Triggers - Relationship with Channels","module":"060-triggers","type":"extras","doc":"Channels are part of AppEngine, and allow users to monitor device events through WebSockets, on top of Phoenix Channels. Under the hood, Channels use transient triggers to define which kind of events will flow through a specific room."},{"ref":"070-auth.html","title":"Authentication and Authorization","module":"070-auth","type":"extras","doc":"Authentication and Authorization Authentication and authorization are crucial, as Astarte likely holds sensitive resources and is capable to send mass commands to a device fleet. First of all: when talking about auth in Astarte, we are talking about anything which isn&#39;t a Device - those are Authenticated through Pairing and Authorized by their Transport (which uses Pairing for the Authentication policies). Astarte&#39;s authentication/authorization stage identifies the principal through a token (with JWT as the first class citizen), which is the only currency the platform supports."},{"ref":"070-auth.html#authentication-realms","title":"Authentication and Authorization - Authentication Realms","module":"070-auth","type":"extras","doc":"In Astarte, realms are logically separated and have completely different data partitions. This is also true in terms of authentication, as caller is always authenticated on a per-realm basis. As such, an authentication realm matches 1:1 an Astarte realm. Superadmin APIs, such as housekeeping, are part of a different authentication realm which is defined upon cluster setup."},{"ref":"070-auth.html#authentication-in-astarte","title":"Authentication and Authorization - Authentication in Astarte","module":"070-auth","type":"extras","doc":"Astarte, by design, does not have a concept of per-user authentication built in. The definition of an authentication realm is a mean to verify a token&#39;s validity, that is most likely a public key. This makes integrating Astarte with 3rd party authentication/authorization frameworks and SSOs extremely easy, as the whole logic for addressing user management is managed out of the cluster by a dedicated party. Depending on one&#39;s use case, it is possible to use either a very simple, dedicated OAuth server for each realm, or a full fledged SSO such as Keycloak which matches its authentication realms to Astarte&#39;s realms. Especially if you are aiming at the latter, make sure to read the advised best practices for authentication afterwards."},{"ref":"070-auth.html#authorization","title":"Authentication and Authorization - Authorization","module":"070-auth","type":"extras","doc":"Currently, Astarte supports a URL-based authorization for the API. Given that Astarte&#39;s data access APIs match the devices&#39; topology like a tree, declaring the authorization in terms of path whitelisting gives enough flexibility to give each user the correct permissions without limitations. As said, Astarte does not have the concept of user, and neither has a durable storage which tracks permissions. As such, it expects the authorization information to be inside the token, which is the only entity Astarte can trust - given it has been verified and authenticated through its signature. Paths are given in form of a set of Perl-like Regular Expressions, and on a per-API basis. This means that each API endpoint (app, realm, etc...) has its own regular expression which defines what the user can do. Moreover, each HTTP verb in an API endpoint (e.g.: GET, POST, PUT, DELETE) can have its own regular expression, to fine-grain permissions on each path. Note: given Astarte&#39;s interface are either read only or write only, HTTP verb fine-graining in AppEngine API is mostly useful for preventing a user from deleting a consumer Datastream even though it has write access to it. Most of the time, using only a single regular expression with no verb fine-graining works. Examples of valid regular expressions on AppEngine API are: POST::devices/.*/interfaces/com\\\\.my\\\\.interface/.*: Allows to set individual values on the com.my.interface interface on any individual device in the realm. .*::.*/interfaces/com\\\\.my\\\\.monitoring\\\\.interface.*: Allows to get/set/delete either the aggregate or the individual values of the com.my.monitoring.interface interface on any device or device aggregation in the realm. .*::devices/j0zbvbQp9ZNnanwvh4uOCw.*: Allows every operation on device j0zbvbQp9ZNnanwvh4uOCw GET::devices/[a-zA-Z0-9-_]*: Allows to get every individual device&#39;s status, but denies access to any additional information/operation on them. Examples of valid regular expressions on Realm Management API are: POST::interfaces\\/.*: Allows installing new interfaces in the realm. GET::interfaces\\/.*: Allows inspecting every interface in the realm. PUT::interfaces\\/.*\\/0: Allows updating all draft interfaces in the realm. Other valid examples are: .*::.*: Allows any operation on the given API. Both verb and path regular expressions are implicitly delimited by adding ^ before and $ after the regular expression string. For example, if you use GET::interfaces as regular expression in Realm Management API, the path will be matched against ^GET$ and the path will be matched against ^interfaces$. This way the only operation allowed will be listing all the interfaces, while all operation on interfaces/ subpaths will be denied. Token claims and formats Authorization regular expressions have to be contained in the token&#39;s claims. Only the JWT case will be considered given it is the primary currency Astarte supports. Every claim is an array of regular expressions, which act as a logical OR. A similar behavior could be of course achieved (and might be more efficient) with a singular regular expression, but for the sake of readability and simplicity it is allowed nonetheless. Of course, keeping the authorization claims simple and pragmatic helps in terms of performance. Supported token claims are: a_aea: Defines the regular expressions for AppEngine API a_rma: Defines the regular expressions for Realm Management API a_hka: Defines the regular expressions for Housekeeping API a_pa: Defines the regular expressions for Pairing API a_ch: Defines the regular expressions for Channels Of course, claims are considered only after a successful token verification. This means that the claim will be processed only if the caller is authenticated against the correct authentication realm - this is especially the case for what concerns Housekeeping, which has a dedicated Authentication realm not tied to any Astarte realms. An example of a valid token claim is: { &quot;a_aea&quot;: [&quot;GET::devices/[a-zA-Z0-9-_]*&quot;, &quot;.*::.*/interfaces/com\\\\.my\\\\.monitoring\\\\.interface.*&quot;, &quot;.*::devices/j0zbvbQp9ZNnanwvh4uOCw.*&quot;], &quot;a_rma&quot;: [&quot;GET::.*&quot;] } Which allows very specific permissions on AppEngine API, and a &quot;read all&quot; on Realm Management API. The client by default has no permission to do anything: as such, if a token is missing a claim it is simply assumed that the client isn&#39;t authorized to access that specific API. However, keeping in mind that Astarte has no concept of User, it is also true that your authentication backend might choose to emit a different token with only a subset of its real permissions to keep claims and regular expressions as pragmatic as possible. See Granular Claims in Best Practices for more details on this. Natively supported tokens Astarte supports only JWT natively, which has to be signed using one of the following algorithms: ES256 ES384 ES512 PS256 PS384 PS512 RS256 RS384 RS512"},{"ref":"070-auth.html#authorization-for-rest-apis","title":"Authentication and Authorization - Authorization for REST APIs","module":"070-auth","type":"extras","doc":"Valid tokens can be used for calling into Astarte&#39;s public APIs. Depending on which token mechanism is used, the HTTP call must adhere to some requirements. JWT Every API call must have an Authorization: Bearer &lt;token&gt; header. Not providing the token or providing a token which can&#39;t be validated for the authentication realm of the context results in a 401 reply."},{"ref":"070-auth.html#authorization-for-channels","title":"Authentication and Authorization - Authorization for Channels","module":"070-auth","type":"extras","doc":"A valid token should be supplied when opening the WebSocket, in the very same fashion to what happens with REST APIs. However, the claims in this token will support different verbs compared to the REST APIs, namely JOIN and WATCH. These have very specific meanings and are well explained in Channels&#39; User Guide. The behavior and supported tokens are equivalent to REST APIs."},{"ref":"070-auth.html#supported-integrations","title":"Authentication and Authorization - Supported integrations","module":"070-auth","type":"extras","doc":"Astarte, by default, is extremely easy to configure assuming your chosen SSO is capable of issuing JWT, as it is currently the only natively supported authentication currency. However, virtually any token-based system can be used as an auth framework for Astarte. The main purpose of Astarte&#39;s design, however, is to keep things simple for everyone. Putting up a full-fledged SSO dedicated to Astarte is beyond the scope of this documentation, and we favor the use case where an existing SSO infrastructure is integrated with Astarte, rather than built ad-hoc. For simple use cases and instant satisfaction, it is strongly advised to use a simpler solution, such as a dedicated OAuth server. Almost all popular languages and frameworks provide great projects which can spin up an OAuth2 server + user management in a matter of hours, from Elixir/Phoenix to Java/Spring to Go. Astarte&#39;s Enterprise Distribution includes other add-ons, such as automation and configuration for popular SSOs."},{"ref":"070-auth.html#best-practices","title":"Authentication and Authorization - Best practices","module":"070-auth","type":"extras","doc":"Due to the nature of tokens, applications and SSOs must take care of emission and storage of the token themselves. In most production cases, Astarte will be part of a larger SSO infrastructure being one of the clients (this is especially true for OAuth). Among best practices, emitting short-lived tokens should always be considered, but depending on the use case, the authentication pipeline can be further tuned to address a number of potential issues. Token exchange OAuth, like other protocols supports the concept of a Token Exchange. Consider a web dashboard with a logged in user. The user will, most likely, have a token which is used by its frontend to call upon the backend/APIs of the web dashboard. For the sake of simplicity, one might include in this token the adequate claims to give the user access to Astarte, but this might not be desirable for a number of reasons outlined above. Token exchange, if supported by your SSO, provides a great way to work around this: whenever the backend or the frontend requires access to Astarte, it can invoke the token exchange mechanism of the SSO to generate a short lived token for the API call from the original authentication, which can then be used even as a single shot access mechanism. Granular claims The token exchange approach can be efficiently paired with a mechanism of granular claims. Consider the use case above, and let&#39;s assume the frontend needs direct, frequent access to Astarte&#39;s APIs. Exchanging tokens too many times might put a burden on the SSO and might become impractical. However, Astarte decouples entirely authentication and authorization - that means, if two subsequent (valid) tokens which represent the same identity have substantially different claims, it doesn&#39;t care. This is intentional, as it allows for a much more efficient pattern: the token used by an hypotetical frontend can have a subset of the user&#39;s claims - for example, allowing him to read data from its devices, whereas token exchange can be used whenever more specific operations should be performed - for example, sending some commands or data to devices. This also addresses the objection that regular expressions can grow big or quite complicated in case users need a large number of very granular permissions. In such complex cases, the SSO can be tuned to give out only a subset of claims depending on the user&#39;s operation. Token revocation Token revocation isn&#39;t natively supported in Astarte for two reason: the first one is performance, as keeping a revocation list is expensive in many regards. The second is the fact that the revocation list is, most of the time, SSO specific, and a dedicated SSO integration would be required. Rather than token revocation, a better practice is to make sure every emitted token has a short enough lifetime. However, it is possible to extend Astarte&#39;s authorization stage to support revocation, even though there are no plans to provide upstream support for that. Changing a Realm&#39;s validation mean Over the lifetime of a cluster, it might be necessary to change a realm&#39;s validation mean for the most diverse reasons. By design, validation means are meant to be long lived, and changing them is supposed to be an extraordinary operation. Astarte supports only one validation mean at a time. When the validation mean is changed, all tokens emitted which could be validated with the previous mean become invalid. It is also possible that there might be a delay between the request of a validation mean change and its actuation. This means during this grace period tokens will be validated against the previously configured mean. As such, it is advised to treat a validation mean change as a maintenance operation for the realm. More details can be found in the Administrator Guide."},{"ref":"080-mqtt-v1-protocol.html","title":"Astarte MQTT v1 Protocol","module":"080-mqtt-v1-protocol","type":"extras","doc":"Astarte MQTT v1 Protocol Astarte MQTT v1 Protocol allows communication between Astarte and devices. It is the first protocol that has been implemented in Astarte, and it exploits every feature provided by Astarte itself. Astarte MQTT v1 doesn&#39;t mandate a specific Transport Credentials format: the broker must handle Authentication, Authorization and Pairing integration the way it sees fit. Astarte MQTT v1 is implemented by Astarte&#39;s Reference Transport, Astarte/VerneMQ - a client wishing to interact with it must implement MQTT v3.1.1 and all needed features for Pairing to work. MQTT doesn&#39;t mandate the data serialization format, so any application might implement its own format. Data serialization might be a tricky task and protocols might be hard to design, Astarte MQTT takes care of this and provides a higher level protocol which abstracts this detail from the end user. Astarte MQTT v1 Protocol builds upon MQTT v3.1.1 itself, BSON (Binary JSON, version 1.1) serialized payloads and on optional zlib deflate. All communications are ordered and asynchronous. A protocol reference implementation is provided with an Astarte SDK, however developers might implement it from scratch using 3rd party libraries with their favourite languages: all formats and protocols described here are open and well documented. Last but not least Astarte doesn&#39;t mandate this protocol, and a different one can be used with a different transport."},{"ref":"080-mqtt-v1-protocol.html#mqtt-topics-overview","title":"Astarte MQTT v1 Protocol - MQTT Topics Overview","module":"080-mqtt-v1-protocol","type":"extras","doc":"Astarte MQTT v1 Protocol relies on few well known reserved topics. TopicPurposePublished ByQoSPayload Format &lt;realm name&gt;/&lt;device id&gt;IntrospectionDevice2ASCII plain text, &#39;:&#39; and &#39;;&#39; delimited &lt;realm name&gt;/&lt;device id&gt;/control/emptyCacheEmpty CacheDevice2ASCII plain text (always &quot;1&quot;) &lt;realm name&gt;/&lt;device id&gt;/control/consumer/propertiesPurge PropertiesAstarte2deflated plain text &lt;realm name&gt;/&lt;device id&gt;/control/producer/propertiesPurge PropertiesDevice2deflated plain text &lt;realm name&gt;/&lt;device id&gt;/&lt;interface name&gt;/&lt;path&gt;Publish DataBoth0, 1, 2BSON (or empty) For clarity reasons all &lt;realm name&gt;/&lt;device id&gt; prefixes will be omitted on the following paragraphs, those topics will be called device topics. Topics are not bidirectional, devices must not publish data for server owned topics and viceversa, onwership is explicitly stated in interfaces files."},{"ref":"080-mqtt-v1-protocol.html#bson","title":"Astarte MQTT v1 Protocol - BSON","module":"080-mqtt-v1-protocol","type":"extras","doc":"BSON allows saving precious bytes compared to JSON, while offering the advantages of a schema-less protocol. Consider, for example, a simple value and timestamp payload. The encoded JSON version, {&quot;v&quot;:25.367812,&quot;t&quot;:1537346756844} counts 33 bytes. The hexdump of the same message encoded with BSON is: 0000000 1b 00 00 00 12 74 00 ec e0 01 f1 65 01 00 00 01 0000020 76 00 8c 13 5f ed 28 5e 39 40 00 that fits just in 27 bytes. BSON format BSON is a really simple binary format, breaking down the previous example is very easy thanks to BSON simplicity: the first 4 bytes (1b 00 00 00) are the document size header, follows the timestamp marker (09), the timestamp key name (74 00, that is &quot;t&quot;), the timestamp value (5f 48 06 f1 65 01 00 00 as int64), the double value marker (01), the value key name (76 00, that is &quot;v&quot;), the actual value (cd cc cc cc cc 4c 39 40 as 64-bit IEEE 754-2008 floating point) and the end of document marker (00). Astarte payload standard fields KeyTypeMandatoryDescription vAny Astarte typeYesThe value being sent (both properties and datastream) tUTC datetimeNoExplicit timestamp, if present (optional, datastream only) Astarte data types to BSON types Astarte Data TypeBSON TypeSize in Bytes doubledouble (0x01)8 integerint32 (0x10)4 booleanboolean (0x08)1 longintegerint64 (0x12)8 stringUTF-8 string (0x02)&gt;= length (encoding dependent) binaryblobbinary (0x05)length datetimeUTC datetime (0x09)8 doublearrayArray (0x04)(8 + keysize) * count integerarrayArray (0x04)(4 + keysize) * count booleanarrayArray (0x04)(1 + keysize) * count longintegerarrayArray (0x04)(1 + keysize) * count stringarrayArray (0x04)depends on count, length, keys length and encoding binaryblobarrayArray (0x4)depends on count, keys length and length integer and long integer are signed integer values, double must be a valid number (+inf, NaN, etc... are not supported), variable data types might be subject to size limitations and object aggregations are encoded as embedded documents."},{"ref":"080-mqtt-v1-protocol.html#connection-and-disconnection","title":"Astarte MQTT v1 Protocol - Connection and Disconnection","module":"080-mqtt-v1-protocol","type":"extras","doc":"A device is not required to publish any additional connection or disconnection messages, the MQTT broker will automatically keep track of these events and relay them to Astarte. When connecting, before publishing any data message, a device should check MQTT session present flag. When the MQTT session present flag is true no further actions are required, when false the device should take following actions: Publish its introspection Publish an empty cache message Publish all of its existing and set properties on all its property interfaces If a device is unable to inspect session present all previous actions must be taken at every reconnection."},{"ref":"080-mqtt-v1-protocol.html#introspection","title":"Astarte MQTT v1 Protocol - Introspection","module":"080-mqtt-v1-protocol","type":"extras","doc":"Each device must declare the set of supported interfaces and their version. Astarte needs to know which interfaces the device advertises before processing any further data publish. This message in Astarte jargon is called introspection and it&#39;s performed by publishing on the device root topic the list of interfaces that are installed on the device. Introspection payload is a simple plain text string, and it has the following format (in BNF like syntax): introspection ::= introspection_list introspection_list ::= introspection_entry &quot;;&quot; introspection_list | introspection_entry introspection_entry ::= interface_name &quot;:&quot; interface_major_version &quot;:&quot; interface_minor_version The following example is a valid introspection payload: com.example.MyInterface:1:0;org.example.DraftInterface:0:3"},{"ref":"080-mqtt-v1-protocol.html#empty-cache","title":"Astarte MQTT v1 Protocol - Empty Cache","module":"080-mqtt-v1-protocol","type":"extras","doc":"Astarte MQTT v1 strives to save bandwidth upon reconnections, to make sure even frequent reconnections don&#39;t affect bandwidth consumption. As such, upon connecting and if MQTT advertises a session present, both sides assume that data flow is ordered and consistent. However, there might be cases where this guarantee isn&#39;t respected by the device for a number of reasons (e.g.: new device, factory reset, cache lost...). In this case, a device might declare that it has no confidence about its status and its known properties, and can request to resynchronise entirely with Astarte. In Astarte jargon this message is called empty cache and it is performed by publising &quot;1&quot; on the device /control/emptyCache topic. After an empty cache message properties might be purged and Astarte might publish all the server owned properties again."},{"ref":"080-mqtt-v1-protocol.html#session-present","title":"Astarte MQTT v1 Protocol - Session Present","module":"080-mqtt-v1-protocol","type":"extras","doc":"In the very same fashion as the device, Astarte (or the broker) might be inconsistent with a Device&#39;s known status and its known properties. Although unlikely, as Astarte should always keep knowledge about remote device status, this might happen, for example, after an internal error. Astarte performs this task by telling the broker to disconnect the device and clear its session. After this, when the device will attempt reconnection, session present will be false. After a clean session properties might be purged."},{"ref":"080-mqtt-v1-protocol.html#purge-properties","title":"Astarte MQTT v1 Protocol - Purge Properties","module":"080-mqtt-v1-protocol","type":"extras","doc":"Either a Device or Astarte may tell the remote host the set properties list. Any property that is not part of the list will be deleted from any cache or database. This task is called purge properties in Astarte jargon, and it is performed by publishing a the list of known set properties to /control/consumer/properties or /control/producer/properties. Purge Properties payload is a zlib deflated plain text, with an additional 4 bytes header. The additional 4 bytes header is the size of the uncompressed payload, encoded as big endian uint32. The following example is a payload compressed using zlib default compression, with the additional 4 bytes header: 0000000 00 00 00 46 78 9c 4b ce cf d5 4b ad 48 cc 2d c8 0000020 49 d5 f3 ad f4 cc 2b 49 2d 4a 4b 4c 4e d5 2f ce 0000040 cf 4d d5 2f 48 2c c9 b0 ce 2f 4a 87 ab 70 29 4a 0000060 4c 2b 41 28 ca 2f c9 48 2d 0a 00 2a 02 00 b2 0c 0000100 1a c9 The uncompressed plain text payload has the following format (in BNF like syntax): properties ::= properties_list properties_list ::= properties_entry &quot;;&quot; properties_list | properties_entry properties_entry ::= interface_name path The following example is the inflated previous payload: com.example.MyInterface/some/path;org.example.DraftInterface/otherPath This protocol feature is fundamental when a device has any interface with an allow_unset mapping, purge properties allows to correct any error due to unhandled unset messages."},{"ref":"080-mqtt-v1-protocol.html#publishing-data","title":"Astarte MQTT v1 Protocol - Publishing Data","module":"080-mqtt-v1-protocol","type":"extras","doc":"Either Astarte or a device might publish new data on a interface/endpoint specific topic. The topic is built using /&lt;interface name&gt;/&lt;path&gt; schema, and it is used regardless of the type of interface or mapping being used. Also / path is a valid path for object aggregated interfaces. The following device topics are valid: /com.example.MyInterface/some/path /org.example.DraftInterface/otherPath /com.example.astarte.ObjectAggregatedInterface/ Data messages QoS is chosen according to mapping settings, such as reliability. Properties are always published using QoS 2. Interface TypeReliabilityQoS propertiesalways unique2 datastreamunreliable0 datastreamguaranteed1 datastreamunique2 Payload Format Payload format might change according to the message type. Payloads are always BSON encoded, except for unset messages that are empty. Property Message Property messages have a &quot;v&quot; key (which means value). Valid examples are: {&quot;v&quot;: &quot;string property value&quot;} {&quot;v&quot;: 10} {&quot;v&quot;: true} Previous payloads are BSON encoded as the following hex dumps: 0000000 22 00 00 00 02 76 00 16 00 00 00 73 74 72 69 6e 0000020 67 20 70 72 6f 70 65 72 74 79 20 76 61 6c 75 65 0000040 00 00 0000000 0c 00 00 00 10 76 00 0a 00 00 00 00 0000000 09 00 00 00 08 76 00 01 00 Property messages order must be preserved and they must be consumed in order. The same property with the same value can be sent several times, this behavior is allowed but discouraged: it&#39;s up to the device to avoid useless messages. A device must also make sure to publish all the properties that have been changed while the device was offline. Unset Property Message Properties can be unset with an unset message. An unset message is just an empty 0 bytes payload. Datastream Message (individual aggregation) Datastream messages for interfaces with individual aggregation have a &quot;v&quot; key and an optional &quot;t&quot; key (which means timestamp). Valid examples are: {&quot;v&quot;: false} {&quot;v&quot;: 16.73} {&quot;v&quot;: 16.73, &quot;t&quot;: 1537449422890} Timestamps are UTC timestamps (BSON 0x09 type), when not provided reception timestamp is used. Previous payloads are BSON encoded as the following hex dumps: 0000000 09 00 00 00 08 76 00 00 00 0000000 10 00 00 00 01 76 00 7b 14 ae 47 e1 ba 30 40 00 0000000 1b 00 00 00 09 74 00 2a 70 20 f7 65 01 00 00 01 0000020 76 00 7b 14 ae 47 e1 ba 30 40 00 Datastream Message (object aggregation) Datastream messages for interfaces with object aggregation support every Astarte payload standard field (such as &quot;t&quot;), but in this case value is a BSON subdocument, in which each key represent a mapping of the aggregation. Valid examples are: {&quot;v&quot;: {&quot;temp&quot;: 25.3123, &quot;hum&quot;: 67.112}} {&quot;v&quot;: {&quot;temp&quot;: 25.3123, &quot;hum&quot;: 67.112}, &quot;t&quot;: 1537452514811} Timestamps are UTC timestamps (BSON 0x09 type), when not provided reception timestamp is used. Previous payloads are BSON encoded as following hex dumps: 0000000 28 00 00 00 03 76 00 20 00 00 00 01 68 75 6d 00 0000020 ba 49 0c 02 2b c7 50 40 01 74 65 6d 70 00 72 8a 0000040 8e e4 f2 4f 39 40 00 00 0000000 33 00 00 00 09 74 00 fb 9d 4f f7 65 01 00 00 03 0000020 76 00 20 00 00 00 01 68 75 6d 00 ba 49 0c 02 2b 0000040 c7 50 40 01 74 65 6d 70 00 72 8a 8e e4 f2 4f 39 0000060 40 00 00"},{"ref":"080-mqtt-v1-protocol.html#minimal-protocol","title":"Astarte MQTT v1 Protocol - Minimal Protocol","module":"080-mqtt-v1-protocol","type":"extras","doc":"A device might implement a subset of this protocol if needed. /control/consumer/properties, /control/producer/properties and /emptyCache might be ignored or not implemented if a device has no property interfaces. A further simplification might remove any requirement for any introspection message when previously provisioned, but this feature is not supported out of the box."},{"ref":"080-mqtt-v1-protocol.html#error-handling","title":"Astarte MQTT v1 Protocol - Error Handling","module":"080-mqtt-v1-protocol","type":"extras","doc":"A device might be forcefully disconnected due to any kind of error. Devices should wait a random amount of time before trying to connect again to the broker. session present might be also set to false to ensure a clean and consistent state (in that case messages such as introspection and empty cache should published as previously described). Malformed or unexpected messages are discarded and further actions might be taken."},{"ref":"080-mqtt-v1-protocol.html#authentication","title":"Astarte MQTT v1 Protocol - Authentication","module":"080-mqtt-v1-protocol","type":"extras","doc":"In Astarte, every Transport orchestrates its credentials through Pairing. Astarte/VerneMQ authenticates devices using Mutual SSL Autentication - as such, devices use SSL certificates emitted through Pairing API to authenticate against the broker. To achieve this, the device must ensure it is capable of performing http(s) calls to Pairing API to obtain its certificates, performing SSL/X509 operations and connecting to the MQTT Broker through the use of SSL certificates."},{"ref":"080-mqtt-v1-protocol.html#authorization","title":"Astarte MQTT v1 Protocol - Authorization","module":"080-mqtt-v1-protocol","type":"extras","doc":"Device can only publish and subscribe to its device topic (&lt;realm name&gt;/&lt;device id&gt;) and its subtopics. The broker will deny any publish or subscribe outside that hierarchy."},{"ref":"080-mqtt-v1-protocol.html#connecting-to-the-broker","title":"Astarte MQTT v1 Protocol - Connecting to the Broker","module":"080-mqtt-v1-protocol","type":"extras","doc":"In the same fashion as Authentication, Pairing provides the client with information about how to connect to the MQTT broker. When invoking relevant Pairing API&#39;s method to gather information about available transports for a device, if Astarte advertises Astarte MQTT v1, a similar reply will be returned: { &quot;data&quot;: { &quot;version&quot;: &quot;&lt;version string&gt;&quot;, &quot;status&quot;: &quot;&lt;status string&gt;&quot;, &quot;protocols&quot;: { &quot;astarte_mqtt_v1&quot;: { &quot;broker_url&quot;: &quot;mqtts://broker.astarte.example.com:8883&quot; } } } }"},{"ref":"001-intro_user.html","title":"Introduction","module":"001-intro_user","type":"extras","doc":"Introduction Astarte is an Open Source IoT platform focused on Data management. It takes care of everything from collecting data from devices to delivering data to end-user applications. To achieve such a thing, it uses a mixture of mechanisms and paradigm to store organized data, perform live queries. This guide focuses on daily operations for Astarte users and integrators. It goes through fundamental operations such as setting up triggers, querying APIs, integrating 3rd party applications and more. The user guide starts from the assumption that the reader is interacting with one or more well-known realms, and throughout the manual the assumption is that we&#39;re always operating inside a test realm, unless otherwise specified. Setting up realms is out of the scope of this guide, also because it&#39;s not a task the average user has to deal with. Please refer to the dedicated chapter of the Administrator manual to learn more about this specific topic. Before you begin, make sure you are familiar with Astarte&#39;s architecture, design and concepts."},{"ref":"010-interacting_with_astarte.html","title":"Interacting with Astarte","module":"010-interacting_with_astarte","type":"extras","doc":"Interacting with Astarte Astarte&#39;s interaction is logically divided amongst two main entities. Devices are the bottom end, and represent your IoT fleet. They can access Astarte only through a Transport, they are defined by a set of Interfaces which, in turn, also define on a very granular level which kind of data they can exchange. By design, they can&#39;t access any resource which isn&#39;t their own: such a behavior can be configured using Astarte as a middleman to act as a secure Gateway. Users are actual users, applications or anything else which needs to interact directly with Astarte. They are bound to a realm, and can virtually access any resource in that realm given they&#39;re authorized to do so. Users can also manage triggers and perform maintenance activity on the Realm."},{"ref":"010-interacting_with_astarte.html#interacting-with-a-device","title":"Interacting with Astarte - Interacting with a Device","module":"010-interacting_with_astarte","type":"extras","doc":"Devices interact with Astarte through their associated Transport. In this guide, we&#39;ll assume the Transport is MQTT/VerneMQ as per Astarte&#39;s defaults. However, rather than implementing the whole Astarte protocol over MQTT, it is usually a better idea to rely on one of Astarte&#39;s SDKs. Authentication/Pairing Depending on how you plan on implementing Astarte&#39;s pairing mechanism, your devices might need an Agent for their first authentication or not. However, once they retrieve their Credentials Secret, they can implement Astarte&#39;s standard pairing routine to rotate their SSL certificate for accessing the transport. In the most likely scenario in which you are using one of Astarte&#39;s SDKs, the SDK takes care of the whole pairing routine under the hood and, depending on your agent implementation, you just need to feed the SDK with either the Credentials Secret or the Agent Key. Exchanging data As per Astarte&#39;s protocol specification, data is exchanged based on the device&#39;s introspection. The device will be able to publish data on the transport on device interfaces, and receive data on server interfaces. In the MQTT case, the device will subscribe to its server interfaces&#39; topics, and publish on its device interfaces topics. Isolation and RBAC are guaranteed by the transport&#39;s ACL, which are usually orchestrated though a dedicated Astarte extension (as in the VerneMQ/MQTT case). Again, Astarte&#39;s SDK allows you to interact with your device interfaces directly without caring about the underlying protocol and exchange details."},{"ref":"010-interacting_with_astarte.html#interacting-as-a-user","title":"Interacting with Astarte - Interacting as a User","module":"010-interacting_with_astarte","type":"extras","doc":"Astarte is mainly accessed through its APIs. Astarte&#39;s APIs are exposed through dedicated microservices (see Components) and are meant both for configuration and for accessing data. There are two main sets of APIs we&#39;ll be using frequently: AppEngine API: This API is meant for querying/pushing data from/to devices. Realm Management API: This API is meant for configuring a target realm, and most notably for managing triggers. Authentication Authenticating against Astarte is out of the scope of this guide, especially due to the fact that Astarte does not manage authentication directly. We&#39;ll assume either the authentication isn&#39;t enabled, or that the user is always interacting with the APIs with a token with the following claims { &quot;a_aea&quot;: &quot;.*:.*&quot;, &quot;a_rma&quot;: &quot;.*:.*&quot; } Which represents a realm administrator. In real life use cases, you should always make sure to give out more granular permissions and to obtain the token in the right way from your authentication server. Accessing the APIs In a standard Astarte installation, AppEngine API and Realm Management API are usually accessible at app.api.&lt;your astarte domain&gt; and realm.api.&lt;your astarte domain&gt; respectively, or at api.&lt;your astarte domain&gt;/app and api.&lt;your astarte domain&gt;/realm. If your Astarte installation has Swagger UI enabled, you can use the /swagger endpoint to access it, and to issue API calls straight from your browser to follow this guide."},{"ref":"020-accessing_and_exploring_a_realm.html","title":"Accessing and Exploring a Realm","module":"020-accessing_and_exploring_a_realm","type":"extras","doc":"Accessing and Exploring a Realm In Astarte, a Realm is a logical partition which holds a number of devices and an Authentication Realm"},{"ref":"029-interface_design_guide.html","title":"Interface Design Guide","module":"029-interface_design_guide","type":"extras","doc":"Interface Design Guide Before we begin, let&#39;s get this straight: The way you design your interfaces will determine the overall performance and efficiency of your cluster This is because interfaces define not only the way data is exchanged between Astarte and Devices/Applications, but also how it will be stored, managed and queried. As such, it is fundamental to spend enough time on finding the most correct Interface design for your use case, keeping in mind how your users will consume your data, what might change in the future, what is fundamental and what is optional, and more."},{"ref":"029-interface_design_guide.html#rationale","title":"Interface Design Guide - Rationale","module":"029-interface_design_guide","type":"extras","doc":"Without going into deeper details on what concerns Astarte&#39;s DB internals, there are some considerations one should always keep in mind when designing interfaces. Querying an Interface is fast, querying across Interfaces is painful Astarte&#39;s data modeling is designed to optimize queries within a single interface. Querying across interfaces is supported, but might affect performances significantly, especially if done frequently and with complex queries. This is especially true for triggers, as they could be evaluated very frequently. In general, if you plan on having different mappings which are frequently queried altogether, or dependent on each other for several triggers, you might be better off in having them all in the same Interface. Aggregation makes a difference Aggregation is a powerful feature, which comes with price and benefits. Even though each series has only one timestamp for all values, it is also true that losing granularity for endpoints might cause storage of redundant data if only one of the aggregated mappings change value. Moreover, in terms of data modeling, Aggregated interfaces imply the creation of a dedicated Cassandra table. Having a lot of aggregated interfaces might end up putting additional pressure on the Cassandra Cluster in terms of memory and overall performance. Your Cluster administrator might (rightfully) choose to limit the amount of installed aggregate interfaces in a Realm, or in the overall Cluster."},{"ref":"029-interface_design_guide.html#interface-atomicity","title":"Interface Design Guide - Interface Atomicity","module":"029-interface_design_guide","type":"extras","doc":"Rule of thumb: Favor extreme atomicity in case you expect your interfaces to change often, be as atomic as reasonably possible in case you want to favor performance and flexibility in querying data."},{"ref":"030-manage_interfaces.html","title":"Managing Interfaces","module":"030-manage_interfaces","type":"extras","doc":"Managing Interfaces Interfaces define how data is exchanged over Astarte. For a Device to be capable of exchanging data into its Realm, its interfaces have to be registered into the Realm first. Let&#39;s walk over the whole process. It is assumed that you have read the Interface design guide before, to avoid bad surprises once your fleet starts rolling."},{"ref":"030-manage_interfaces.html#querying-interfaces","title":"Managing Interfaces - Querying Interfaces","module":"030-manage_interfaces","type":"extras","doc":"To find out which interfaces are installed in a Realm, call /interfaces on your chosen realm in Realm Management API: Sample Request GET realm.api.&lt;your astarte domain&gt;/v1/test/interfaces Sample Response [&quot;com.my.Interface1&quot;,&quot;com.my.Interface2&quot;,&quot;com.my.Interface3&quot;] This returns a list of installed interfaces inside the Realm. To retrieve a list of available major versions of a specific interface, go further in the REST tree: Sample Request GET realm.api.&lt;your astarte domain&gt;/v1/test/interfaces/com.my.Interface1 Sample Response [0,1,2] In a realm, only the latest minor version of each major version of an interface is returned as a reference. This can be done due to the fact that Semantic Versioning implies a new minor doesn&#39;t introduce any breaking change (e.g.: deleting or renaming a mapping), and as such querying an older version of an interface using a newer one as a model is compatible - some mappings might be empty, as expected, and will be disregarded. To inspect the installed interface, you can query one of its major versions: Sample Request GET realm.api.&lt;your astarte domain&gt;/v1/test/interfaces/com.my.Interface1/0 Sample Response { &quot;version_minor&quot;: 2, &quot;version_major&quot;: 0, &quot;type&quot;: &quot;properties&quot;, &quot;ownership&quot;: &quot;device&quot;, &quot;mappings&quot;: [ { &quot;type&quot;: &quot;integer&quot;, &quot;path&quot;: &quot;/myValue&quot;, &quot;description&quot;: &quot;This is quite an important value.&quot; }, { &quot;type&quot;: &quot;integer&quot;, &quot;path&quot;: &quot;/myBetterValue&quot;, &quot;description&quot;: &quot;A better revision, introduced in minor 2, supported only by some devices&quot; }, { &quot;type&quot;: &quot;boolean&quot;, &quot;path&quot;: &quot;/awesome&quot;, &quot;allow_unset&quot;: true, &quot;description&quot;: &quot;Introduced in minor 1, tells you if the device is awesome. Optional.&quot; } ], &quot;interface_name&quot;: &quot;com.my.Interface1&quot; }"},{"ref":"030-manage_interfaces.html#installing-updating-an-interface","title":"Managing Interfaces - Installing/Updating an interface","module":"030-manage_interfaces","type":"extras","doc":"Interfaces are supposed to change over time, and are dynamic. As such, they can be installed and updated. Interface installation means adding either a whole new interface (as in: an interface with a new name), or a new major version of an already known interface. Interface update means updating a specific, existing interface name/major version with a new minor version. Installation To install a new interface, POST its JSON body to the /interfaces endpoint of the Realm encapsulated in a data object, like in the following example: { &quot;data&quot;: { &quot;version_minor&quot;: 2, &quot;version_major&quot;: 0, &quot;type&quot;: &quot;properties&quot;, &quot;ownership&quot;: &quot;device&quot;, &quot;mappings&quot;: [ { &quot;type&quot;: &quot;integer&quot;, &quot;path&quot;: &quot;/myValue&quot;, &quot;description&quot;: &quot;This is quite an important value.&quot; }, { &quot;type&quot;: &quot;integer&quot;, &quot;path&quot;: &quot;/myBetterValue&quot;, &quot;description&quot;: &quot;A better revision, introduced in minor 2, supported only by some devices&quot; }, { &quot;type&quot;: &quot;boolean&quot;, &quot;path&quot;: &quot;/awesome&quot;, &quot;allow_unset&quot;: true, &quot;description&quot;: &quot;Introduced in minor 1, tells you if the device is awesome. Optional.&quot; } ], &quot;interface_name&quot;: &quot;com.my.Interface1&quot; } } The call will return either 201 Created or an error. Most common failure cases are: The interface/major combination already exists in the Realm The interface schema fails validation In any case, the API returns details on what caused the error and how to solve it through Astarte&#39;s standard error reply schema. It is also worth noting that interface creation is asynchronous: as such, it might be possible that 201 Created will be returned before the interface is generally available in the Realm. Update To update an existing interface, issue a PUT /interfaces/&lt;name&gt;/&lt;major&gt; endpoint of the realm with the very same semantics as the Installation procedure. The call will return either 201 Created or an error. Apart from the very same errors that could be triggered upon installation, Update will also fail if the interface doesn&#39;t provide a compatible upgrade path from the previously installed minor."},{"ref":"030-manage_interfaces.html#interfaces-lifecycle","title":"Managing Interfaces - Interfaces lifecycle","module":"030-manage_interfaces","type":"extras","doc":"Interfaces are versioned through a semantic versioning-like mechanism. A Realm can hold any number of interfaces and any number of major versions of a single interface. It holds, however, only the latest installed minor version of each major version, due to the inherent compatibility of Semantic Versioning. There is no significant cost in adding a non-aggregated interface to a Realm or updating a non-aggregated interface frequently - keep in mind, however, that you might incur in dangling data in your devices if you don&#39;t plan your interface update strategy accurately. For what concerns Aggregated interfaces, instead, there is an inherent cost which might end up in putting pressure on your Cluster. Once an interface has been installed in a Realm, it can&#39;t be uninstalled without performing manual operations on Astarte&#39;s DB, unless its major version number is 0. This is a safety measure to prevent dangling data from appearing in the cluster. For this reason, when developing an Astarte-based interface, it is strongly advised to keep its major number to 0 to allow quick changes at the expense of data loss. Please note, however, that deleting a major 0 interface is possible if the Realm has no devices left declaring that specific interface in their introspection. This is done to avoid forever dangling data and potential consistency errors. This limitation might be lifted in the future through a mass-deletion mechanism, but there is no guarantee this will ever be done. It is advised to test new interfaces on a limited number of devices to ease operations."},{"ref":"030-manage_interfaces.html#realm-vs-device-interface-relationship","title":"Managing Interfaces - Realm vs. Device Interface relationship","module":"030-manage_interfaces","type":"extras","doc":"There is a clear difference between how Interfaces are managed in a Realm and its Devices (e.g.: the device Introspection). Whereas a Realm can have any number of versions of a single interface, a Device is allowed to expose in its introspection only a single, specific version of an Interface. In general, Realm interfaces are kept as a shared agreement between its entities, but when it comes to interacting with a Device, the Realm honors its introspection (as long as the Device declares interfaces the Realm is knowledgeable about). As such, installing an interface in a Realm is a completely safe and non-disruptive operation: by design, Devices aren&#39;t aware of which interfaces a Realm supports, and Realms don&#39;t impose any interface versioning on a Device."},{"ref":"030-manage_interfaces.html#caveats","title":"Managing Interfaces - Caveats","module":"030-manage_interfaces","type":"extras","doc":"Due to how minor versions work, it is responsibility of the end user to prevent accidental data loss due to missing data. Every mapping declared in a new minor release must be assumed as optional, as there is no guarantee that a Device will be able to publish (or receive) data on that specific mapping. Minor version bumps work great in case they represents additional, optional features which might be available on an arbitrarly large subset of Devices implementing that interface&#39;s major version, and are not necessary or fundamental for normal operations. If that is not the case, consider a major version update or a whole new interface instead. Also, please keep in mind that designing interfaces in the right way, especially being as atomic as reasonably possible, helps a lot in preventing situations where a minor interface update can&#39;t be done without disrupting operations. Again, the Interface design guide covers this topic extensively."},{"ref":"030-manage_interfaces.html#dangling-data","title":"Managing Interfaces - Dangling data","module":"030-manage_interfaces","type":"extras","doc":"In several situations, it is possible to have dangling data inside Astarte. This happens by design, as the liquid nature of a Device makes it possible for data to be stored in interfaces no longer present in its introspection. Astarte does not delete data unless requested explicitly: as such, data remains available inside its database, but potentially inaccessible through the cluster&#39;s APIs and standard mechanism. As of the current version, Astarte has no mechanism for retrieving and acting upon a device&#39;s dangling data - this is a limitation that will be lifted in future releases with additions to the current API. Interface major version change If a device upgrades one of its interfaces to a new major version, the previous interface is parked and its data remains dangling. Every API call, trigger, or reference to the interface will always target the major version declared in the introspection, regardless of the fact that a more recent version might have been installed in the realm. Interface deletion from device A device might arbitrarly decide to remove an interface from its introspection. In such a case, Astarte won&#39;t return any data and will consider all data previously pushed to said interface inaccessible. In case the interface comes back again in the introspection, previously pushed data will be available as if nothing happened."},{"ref":"035-register_device.html","title":"Registering a Device","module":"035-register_device","type":"extras","doc":"Registering a Device Devices are Astarte&#39;s main entities for exchanging data. Even though a Device usually represents the physical Device communicating with Astarte, they might as well be mapped to other entities, such as individual sensors or aggregated gateways. A Device always belongs to a Realm and is identified by a Device ID, which has to be unique at least within its Realm. Devices communicate with Astarte through Transports - in most installations, this means through an MQTT Broker (VerneMQ with Astarte&#39;s plugin). Before this happens, though, Devices must obtain credentials for accessing their Transport and, most of all, make themselves known to Astarte. This happens through the Registration process. In Astarte, Registering a device means obtaining an unique Credentials Secret (Registration Credentials), univocally associated to a Device ID, through a well-known workflow and pipeline. If you are not familiar with these concepts, please refer to Pairing Architecture to learn more about Pairing&#39;s workflow basics. The Credentials Secret can then be used by the Device for accessing Pairing API and getting information and Credentials for its Transport. As such, registration happens only once during a Device&#39;s lifecycle, and is a security-sensitive process. As such, this process is usually carried over (in production scenarios) through an Agent."},{"ref":"035-register_device.html#registration-agent","title":"Registering a Device - Registration Agent","module":"035-register_device","type":"extras","doc":"An Agent&#39;s purpose is to perform Registration on behalf of a Device. Agents should be the only components in your infrastructure with enough credentials to access Pairing&#39;s Agent APIs (as a rule of thumb, it is a bad idea to give access to Pairing API to anything which isn&#39;t an Agent). When setting up an Astarte project, it is fundamental to define beforehand how your Devices will be registered and hence where your Agent(s) will belong. There&#39;s two main ways for implementing an Agent, even though in production scenarios On Board Agents are strongly discouraged as they expose a single point of failure in terms of a Realm&#39;s whole fleet security. On Board Agent Please keep in mind that On Board Agents are not advised in production, as a single compromised device/token might compromise the Registration routine for your entire fleet. They should be used only in non-critical use cases or during testing and development. On Board Agents are provided as a feature by Astarte&#39;s SDK, and hide the detail of Device registration by integrating an Agent into the SDK itself. This allows to deliver the same credentials to each device belonging to a Realm. Of course, this also opens up a single point of failure in the whole fleet&#39;s security, as Credentials aren&#39;t tied to a specific device - as such, if compromised, they might allow an attacker to register an arbitrary device into a Realm, unless other policies prevent him from doing so. To create a On Board Agent, you simply need to emit a long-enough lived token from your Realm&#39;s private key with access to Pairing&#39;s Agent APIs. This token should then be delivered to your devices and provided to the SDK in order to carry over the Registration. The SDK will do this automatically and without any need for additional code, as long as you set the agentKey configuration key to a meaningful value, and no Credentials Secret has been set. 3rd Party Agent A more secure approach to the Registration process is having a 3rd Party agent. In such a case, an external component is in charge of requesting a Credentials Secret to Pairing and delivering it to the target Device. This approach has a number of benefits: in terms of Security, the Agent uses a short-lived token and can follow the Realm&#39;s authentication workflow just like any other application. For what concerns daily operations, the Agent can implement any arbitrary logic to make a decision on whether a Device should be registered or not. In such cases, Devices have an out-of-band communication mechanism with the Agent in which the Credentials are exchanged. Usually, these cases fall under two main categories: &quot;Local&quot; or &quot;Plant&quot; Agents In this scenario, devices are imprinted with their Credentials Secret in the production plant. The Device might not even be connected to the Internet, whereas the machine running the Agent has access to the target Astarte Cluster and adequate Credentials for Registration. Once the Agent acquires the Device ID of the Device which should be registered, it issues the request to Astarte&#39;s Pairing API and obtains the Device&#39;s Credentials Secret. At this stage, the Agent is in charge of delivering the Credentials Secret to the Device the way it sees fit. As a best practice, the Credentials Secret should then be saved to an OTP area or a dedicated secure storage in the device to prevent tampering or accidental loss. Even though this is arguably the most secure mechanism available for Registering a Device, it might not fit every use case as the Device will be irrevocabily assigned to a specific Astarte Cluster and a specific Realm in that Cluster before it even connects. &quot;Remote&quot; Agents If your use case demands more flexibility, Registering a Device in a plant might not fit your Device&#39;s lifecycle. This could be likely if, for example, Realm or Cluster assignment should be done dynamically once the Device reaches its final user. In this case, this role is usually delegated to an external web application acting as an Agent. In this case, it&#39;s up to the user setting up all mechanisms for delivering the Credentials Secret to the Device, which includes securing the communication channel. On the other hand, this allows an extremely flexible approach to Registration, which can be implemented through an entirely custom logic."},{"ref":"035-register_device.html#credentials-secret-lifecycle","title":"Registering a Device - Credentials Secret Lifecycle","module":"035-register_device","type":"extras","doc":"Credentials Secrets are meant to be immutable - as such, they should be handled with extreme care. Credentials Secrets are used only for interacting with Pairing, hence to obtain Credentials for a Transport which, on the other hand, are meant to be volatile. A Device can be Registered an arbitrary number of times before its Credentials Secret is used for the first time for interacting with Pairing. This is done to ensure the entire Registration process, including any kind of external custom logic of the Agents, has been carried over successfully, allowing a de-facto &quot;retry&quot; until there&#39;s certainty the Device has access to its Credentials Secret. Please note that when Registering a Device, a new Credentials Secret is generated every time. Once the Credentials Secret is used for retrieving Credentials for a Transport for the first time, Astarte prevents further registration of the same Device again. There&#39;s no defined procedure for substituting a Credentials Secret - it can be done by performing manual operation, but it should be considered an unusual/emergency procedure (e.g.: a Device has been tampered and got back to its plant with its previous Credentials Secret compromised)."},{"ref":"040-connect_device.html","title":"Connecting a Device","module":"040-connect_device","type":"extras","doc":"Connecting a Device Once a Device has been Registered in Astarte, it is capable of connecting to it. Devices connect to Astarte through the use of Transports. A Transport is an arbitrary protocol implementation which maps Astarte&#39;s concepts (mainly Interfaces) to a communication channel. Astarte&#39;s main supported Transport is Astarte/MQTT, implemented on top of VerneMQ through an additional plugin, and it is used by Astarte&#39;s SDKs for communication. However, virtually any protocol can be integrated in Astarte by creating a corresponding Transport. Transports also define the authentication/authorization mechanism of their Devices. For instance, Astarte/MQTT uses mutual SSL Authentication with Certificate Rotation for securing its Ingress and identifying its clients. To manage their Transport(s) and Credentials, Devices have to interact with Pairing."},{"ref":"040-connect_device.html#credentials-secret-pairing-and-transports","title":"Connecting a Device - Credentials Secret, Pairing and Transports","module":"040-connect_device","type":"extras","doc":"Once a Device has performed its first registration through an Agent, it holds its Credentials Secret. This Credentials Secret is the token the device uses for performing the actual Pairing routine, which results in the device obtaining its Credentials for accessing its designated Transport. A Device&#39;s Credentials Secret allows access to Pairing API&#39;s Device REST API, which is then used for obtaining information about which Transports the Device can use for communicating, and for obtaining Credentials for its assigned Transports. As, from a user&#39;s standpoint, the way a Device communicates with Astarte is entirely Transport-specific, this guide will cover using Astarte/MQTT through one of Astarte&#39;s SDKs. If you are using a different Transport, please refer to its User Guide, or if you wish to implement your own, head over to Transport Developer Documentation."},{"ref":"040-connect_device.html#using-astarte-mqtt-through-astarte-sdk","title":"Connecting a Device - Using Astarte/MQTT through Astarte SDK","module":"040-connect_device","type":"extras","doc":"If you are using one of Astarte&#39;s SDK, the Pairing routine is entirely managed, and you won&#39;t need to do any of the aforementioned steps. Just make sure your Credentials Secret is passed as the apiKey configuration key, to allow the SDK to perform automatically the Pairing routine when needed. The SDK does a number of automated things under the hood. Its flow is: The SDK verifies if a SSL certificate for connecting to the broker is present. If it is, it attempts connecting to the Transport. If the Transport doesn&#39;t accept the connection due to an SSL error, it queries Pairing API about its certificate status. If Pairing API returns a problem with the certificate or, in general, the certificate isn&#39;t valid, the certificate is erased and the Pairing procedure begins. The SDK invokes Pairing API until it manages to obtain a valid Certificate for the Transport. The SDK considers a Device successfully paired when it has a valid certificate and manages to connect to the Transport. Once in this state, the Device can start exchanging data. Note: the Pairing procedure is secure as long as Pairing API is queried using HTTPS. Plain HTTP installations are vulnerable to a number of different attacks and should NEVER be used in production. Interfaces and Introspection A Device must have some installed interfaces to be capable of exchanging data. These interfaces must be made known to the SDK and installed in the Device&#39;s Realm, as previously explained. The SDK expects the user to provide a directory containing a set of valid interfaces. It then takes care of making Astarte aware of its registered interfaces through a process called Introspection. Introspection is a special control message in Astarte&#39;s protocol which makes Astarte aware of a list of Interfaces and relative versions which are installed on the Device. Again, Astarte&#39;s SDK, given a directory, is capable of performing the correct procedures for keeping Introspecting in sync correctly without any kind of user intervention. Astarte&#39;s SDK also takes care of updating a Device&#39;s Introspection if its interfaces change. Exchanging data When a Device connects successfully, it must then subscribe to its server Interfaces. The SDK takes care of this detail and exposes a higher level interface. For example, using the Qt5 SDK: { m_sdk = new AstarteDeviceSDK(QStringLiteral(&quot;/path/to/transport-astarte.conf&quot;), QStringLiteral(&quot;/path/to/interfaces&quot;), deviceId); connect(m_sdk-&gt;init(), &amp;Hemera::Operation::finished, this, &amp;AstarteStreamQt5Test::checkInitResult); connect(m_sdk, &amp;AstarteDeviceSDK::dataReceived, this, &amp;AstarteStreamQt5Test::handleIncomingData); } void AstarteStreamQt5Test::handleIncomingData(const QByteArray &amp;interface, const QByteArray &amp;path, const QVariant &amp;value) { qDebug() &lt;&lt; &quot;Received data, interface: &quot; &lt;&lt; interface &lt;&lt; &quot;path: &quot; &lt;&lt; path &lt;&lt; &quot;, value: &quot; &lt;&lt; value &lt;&lt; &quot;, Qt type name: &quot; &lt;&lt; value.typeName(); } Applications can simply connect to the handleIncomingData signal and have data correctly formatted and delivered as it runs through the transport. On the other hand, for sending data: m_sdk-&gt;sendData(interface, path, value); The SDK will check if data is coherent with its introspection, and send data onto the transport in the correct way. Reliability, retention and persistency in the SDK Astarte&#39;s SDK has an internal concept of persistency, depending on the behaviour defined in its installed Interfaces. The retention parameter, specifically, tells Astarte&#39;s SDK how hard it should try to send a specific message. In case the Transport is unreachable, the SDK might try to persist, either in memory or on disk, and send the message when the connection is available again. Please note that these parameters declared in Interfaces are to be considered on a best effort basis. In case your SDK does not support persistency or has persistency disabled, a number of warranties requested by an Interface might not be satisfied. Make sure your SDK is configured correctly before moving to production."},{"ref":"050-query_device.html","title":"Querying a Device","module":"050-query_device","type":"extras","doc":"Querying a Device Once you have your devices connected, up and running in Astarte, you can start interacting with them."},{"ref":"050-query_device.html#using-appengine-api","title":"Querying a Device - Using AppEngine API","module":"050-query_device","type":"extras","doc":"First things first, you can check if your device is correctly registered in Astarte, and its current status. Let&#39;s assume our Device has f0VMRgIBAQAAAAAAAAAAAA as its id. Sample Request GET appengine.api.&lt;your astarte domain&gt;/v1/test/devices/f0VMRgIBAQAAAAAAAAAAAA Sample Response { &quot;data&quot;: { &quot;total_received_msgs&quot;: 221, &quot;total_received_bytes&quot;: 11660, &quot;last_seen_ip&quot;: &quot;203.0.113.89&quot;, &quot;last_credentials_request_ip&quot;: &quot;203.0.113.201&quot;, &quot;last_disconnection&quot;: &quot;2018-02-07T18:38:57.266Z&quot;, &quot;last_connection&quot;: &quot;2018-02-08T09:49:26.556Z&quot;, &quot;id&quot;: &quot;f0VMRgIBAQAAAAAAAAAAAA&quot;, &quot;first_registration&quot;: &quot;2018-01-31T17:10:59.270Z&quot;, &quot;connected&quot;: true, &quot;introspection&quot; : { &quot;com.example.ExampleInterface&quot; : { &quot;major&quot; : 1, &quot;minor&quot; : 0 }, &quot;org.example.TestInterface&quot; : { &quot;major&quot; : 0, &quot;minor&quot; : 2 } } } } A Device&#39;s status includes a number of useful information, among which whether it is connected or not to its Transport. From there on, we can check on its Introspection. Sample Request GET appengine.api.&lt;your astarte domain&gt;/v1/test/devices/f0VMRgIBAQAAAAAAAAAAAA/interfaces Sample Response { &quot;data&quot;: [ &quot;com.example.ExampleInterface&quot;, &quot;com.example.TestInterface&quot; ] } This returns the Interfaces which the device reported in its Introspection and which are known to the Realm. Depending on the aggregation and ownership of the Interface, you can GET/PUT/POST on the interface itself or one of its mappings. Some examples are: Get data from an aggregate device properties interface: GET appengine.api.&lt;your astarte domain&gt;/v1/test/devices/f0VMRgIBAQAAAAAAAAAAAA/interfaces/com.example.ExampleInterface Get last sent value from an individual device datastream interface: GET appengine.api.&lt;your astarte domain&gt;/v1/test/devices/f0VMRgIBAQAAAAAAAAAAAA/interfaces/com.example.TestInterface/myValue?limit=1 Set values in an individual server datastream interface: POST appengine.api.&lt;your astarte domain&gt;/v1/test/devices/f0VMRgIBAQAAAAAAAAAAAA/interfaces/com.example.OtherTestInterface/myOtherValue In general, to query AppEngine, the following things must be kept in mind When sending data, use PUT if dealing with properties, POST if dealing with datastream. When GETting, if you are querying an aggregate interface, make sure to query the interface itself rather than its mappings. When GETting datastream, keep in mind that AppEngine&#39;s default behavior is to return a large as possible timeseries."},{"ref":"050-query_device.html#navigating-and-retrieving-datastream-results","title":"Querying a Device - Navigating and retrieving Datastream results","module":"050-query_device","type":"extras","doc":"The Datastream case is significant, as it might be common to have a lot of values for each endpoint/interface. As such, returning all of them in a single API call is most of the times not desirable nor recommended. To avoid putting the cluster under excessive pressure, AppEngine API is configured with a hard cap on the maximum number of returned results for each single call, with a sane default of 10000. Although this hard cap is entirely configurable, please be aware that AppEngine API is designed to process a lot of reasonably small requests in the shortest possible time, and hence is not optimised nor strongly tested against big requests. Make sure that AppEngine API has enough resources available to cope with the maximum dataset size. AppEngine API provides you with a variety of mechanisms to make retrieval and navigation of large data sets as smooth and efficient as possible. Limit Adding a limit=n to the URL query tells AppEngine to return no more than n results. This acts similarly to a LIMIT SQL statement, but, as it stands, it does not impose a hard limit on the whole retrieved dataset but on the amount of the results displayed by the API call - see Pagination and Time Windows for more details on this topic and the performance implications of different limits in queries. If the specified limit is beyond the hard cap, the query won&#39;t fail, but will return at most the amount set by the hard cap, without further warnings. Since/To/Since After Results can be limited to a specific time window. since and to can be set to a ISO 8601 valid timestamp to limit on an upper and lower bound the result set. This can also be combined with limit to make sure that no more than n results are returned. Also, since and to can as well be set independently to provide only an upper or lower bound. In case you&#39;re dealing with a very large dataset and you want to dump it, it is likely that you need to go beyond what a reasonable default limit looks like. In those cases, you can use the since_after query parameter to retrieve parameters within a time window. since_after slices the time window just like since does, but it does not include values matching the specified timestamp, if any. This is especially useful when paginating, to start right after a returned result. Pagination and time windows AppEngine API provides you automatically with a time window-based pagination. When GETting a datastream, if more results are available beyond the chosen time window/limit, a links map will be provided, in JSON-API style, to allow the user to paginate the results accordingly using since_after. You can use limit to determine each page&#39;s size. When specifying a valid limit, the links will keep the page size consistent over the next calls. However, limit should be used wisely to lower the pressure on the cluster. Each API call maps to a query that, no matter how efficient, has a computational cost. A few mid-sized queries should always be preferred over a large amount of smaller queries. Given your cluster is configured correctly, limit should be omitted in most cases when paginating, and you should rather trust your cluster&#39;s hard cap to be the sweet spot in efficiency and cluster pressure. Downsampling Especially when plotting graphs, retrieving all points in a time series isn&#39;t desirable. Astarte provides you with an implementation of the LTTB Downsampling Algorithm, which is used to return only a fixed number of samples from a time series. When setting downsample_to=n, AppEngine will return a maximum of n results, which are the most significant over the considered time series according to the algorithm. Due to how LTTB works, downsample_to must be &gt;2, as the algorithm will return the two ends of the considered value bucket, and n-2 values which are the picked samples. Please refer to the LTTB implementation used by Astarte to learn more about how this algorithm affects samples and its limitations. downsample_to=x can be used in conjunction with other query parameters, including limit=y. When doing so, Astarte will downsample to x samples the dataset composed of the last y values. Every feature previously outlined is in fact available with downsampling, including pagination - bear in mind, though, that for how the algorithm works, some options have drastically different semantic effects. Also, the hard cap has a very different meaning in downsampling. In this case, the hard cap applies to downsample_to instead of limit. limit can be an arbitrarly large amount of samples taken out of the DB, and can be used mainly to alleviate pressure in case of extremely large datasets which would require a lot of time for being processed by LTTB - even though, most of the time, you might want to define a time window to downsample instead. Astarte is also capable of downsampling aggregated interfaces, as long as a downsample_key is specified, which has to match the last token of an endpoint of the queried interface (i.e. in case the interface has a /%{id}/myValue mapping which should be used as the downsample_key, you should specify downsample_key=myValue in the query). When doing so, the aggregate will be downsampled using the chosen endpoint value as the y axis value, whereas its other endpoints will be disregarded when applying the algorithm. Please note that, no matter what downsample_key is used, a sample will be composed by the whole aggregation. If there is no way an interface can be downsampled (this is true, for example, if no downsample_key has been specified for aggregations, or for types such as strings), AppEngine API will return a 4xx error. In general, downsampling is a powerful mechanism with a lot of limitations which really shines when plotting. Once again, this is a fundamental factor to consider when designing your interfaces."},{"ref":"052-using_channels.html","title":"Using Astarte Channels","module":"052-using_channels","type":"extras","doc":"Using Astarte Channels Especially when building Frontend applications, it is useful to receive real-time updates about data sent from Devices. Astarte leverages Phoenix Channels to provide such a thing over WebSockets in AppEngine API. WebSockets can be used natively from a Web Browser and follow the same authentication pattern as a standard HTTP call. Astarte Channels define a semantic on top of Phoenix Channels which allows read-only monitoring of device Interfaces. Authentication and Authorization over Channels happens in the very same way as AppEngine, and the a_ch claim in the token is respected when joining rooms and installing triggers. See Authentication and Authorization for more details on Auth semantics in Astarte."},{"ref":"052-using_channels.html#rooms","title":"Using Astarte Channels - Rooms","module":"052-using_channels","type":"extras","doc":"Rooms in Astarte Channels map 1:1 to Topics in Phoenix Channels, and can be joined in the very same way. Once a connection is established, the user can join any number of rooms, given he is authorized to do so. A Room is identified by a topic with the following semantics: rooms:&lt;realm&gt;:&lt;name&gt;. For example, rooms:test:myroom will join the Room myroom in the Realm test. A room can be joined by any number of concurrent users. Rooms serve as containers for Transient Triggers, which can be installed by any authorized user. Transient Triggers are actual Triggers, with the difference that they exist within a Channels Room rather than within a Realm - this mostly affects their timespan - and that the action can&#39;t be configured - every time a Condition is triggered a message is delivered to users in the Room, in a well-known format. Events Everytime a Condition of an installed Trigger is triggered, an event is sent to the Phoenix Channel, with a similar payload: { &quot;device_id&quot;: &quot;f0VMRgIBAQAAAAAAAAAAAA&quot;, &quot;event&quot;: { &quot;type&quot;: &quot;device_connected&quot;, &quot;device_ip_address&quot;: &quot;1.2.3.4&quot; } } device_id is always present (as long as the trigger matches a device) and identifies the device emitting the event. event, instead, depends on the kind of installed trigger. It always carries a type string, which identifies the content of the object. Currently, the documentation of every event&#39;s payload can be found in Astarte&#39;s protobuf files. However, there are some discrepancies in mapping (e.g.). It is advised also to have a look at the encoder. In the foreseeable future, more user friendly documentation will be provided. Lifecycle Once a room is created, it remains valid and active with all of its subscriptions. There&#39;s little overhead in having a large number of rooms, as the only components leeching resources are Transient Triggers. As of today, Transient Triggers never expire - it is responsibility of the user to clean them up once the room becomes empty, if needed. In future versions, Transient Triggers will likely expire after some time, if left in an empty room."},{"ref":"052-using_channels.html#managing-transient-triggers","title":"Using Astarte Channels - Managing Transient Triggers","module":"052-using_channels","type":"extras","doc":"To install a Transient Trigger, one should issue a watch event in the Channel, given he is authorized to do so. The payload of such an event is identical to a Trigger definition, hence it looks like this: { &quot;name&quot;: &quot;datatrigger&quot;, &quot;device_id&quot;: &quot;f0VMRgIBAQAAAAAAAAAAAA&quot;, &quot;simple_trigger&quot;: { &quot;type&quot;: &quot;data_trigger&quot;, &quot;on&quot;: &quot;incoming_data&quot;, &quot;interface_name&quot;: &quot;org.astarteplatform.Values&quot;, &quot;interface_major&quot;: 0, &quot;match_path&quot;: &quot;/realValue&quot;, &quot;value_match_operator&quot;: &quot;&gt;&quot;, &quot;known_value&quot;: 0.6 } } This installs in the Room a Transient Trigger which will trigger an event everytime a value higher than 0.6 is sent on the path /realValue of the datastream interface org.astarteplatform.Values by the device f0VMRgIBAQAAAAAAAAAAAA, and will be received by every user currently in the room. If a user isn&#39;t in the room at the time of the event, he will not get it, and there&#39;s no way he can retrieve it if he joined at a later time. Triggers can be uninstalled by issuing an unwatch event in the Channel. The payload of the event should be the name of the trigger which should be uninstalled."},{"ref":"052-using_channels.html#authorization","title":"Using Astarte Channels - Authorization","module":"052-using_channels","type":"extras","doc":"Just like any other Astarte component, Authorization is encapsulated in a token claim, in particular the a_ch claim. However, the mechanism is rather different compared to a REST API, and uses different verbs. JOIN The JOIN verb implies that a user can join a room. This only allows him to receive events and to interact in a read-only fashion with the room itself. There is no restriction to which events a user sees - if he is authorized to enter in a room, he will be capable of seeing all events flowing in. More granular permissions can be done simply by creating more rooms in which different triggers will be installed. The JOIN verb has the following semantic: JOIN::&lt;regex&gt;, where regex matches a room name (the room name is what follows rooms:&lt;realm&gt;: - the realm is implicit in the context of the authorization token). For example, a user authorized with the JOIN::test.* claim in the test realm will be able to join, for example, rooms:test:testthis, rooms:test:testme, rooms:test:test. The realm is always implicit in the regex, as the token is authenticated in the context of a Realm. WATCH The WATCH verb allows a user to install a Trigger within a room. Its semantics define which kind of trigger, and upon which entities the user is allowed to act. Watch semantics are WATCH::&lt;regex&gt;, where regex is a regular expression which matches a device, path or interface (or a mixture of them) in almost very same fashion as the a_aea claim (which is used in AppEngine). Given different kind of triggers impact different Astarte entities, the Authorization claim implicitly defines which kind of triggers a user will be able to install. For example, f0VMRgIBAQAAAAAAAAAAAA/org.astarteplatform.Values.* will allow installing data triggers such as the one shown in the previous example, but won&#39;t let the user install device-wide triggers (such as connect/disconnect events). A claim such as f0VMRgIBAQAAAAAAAAAAAA or f0VMRgIBAQAAAAAAAAAAAA.*, instead, will allow device-level triggers to be installed."},{"ref":"060-install_trigger.html","title":"Install a Trigger","module":"060-install_trigger","type":"extras","doc":"Install a Trigger"},{"ref":"070-connect_application.html","title":"Connect 3rd party applications","module":"070-connect_application","type":"extras","doc":"Connect 3rd party applications"},{"ref":"080-grafana_datasource.html","title":"Using Astarte&#39;s Grafana Datasource","module":"080-grafana_datasource","type":"extras","doc":"Using Astarte&#39;s Grafana Datasource"},{"ref":"001-intro_administrator.html","title":"Introduction","module":"001-intro_administrator","type":"extras","doc":"Introduction This guide is meant for System Administrators who need to deal with Astarte clusters installation, maintenance and upgrade. The guide will cover prerequisites, installation in different supported environments, and common maintenance operations. Before you begin, it is fundamental you are familiar with Astarte&#39;s architecture, design and concepts, especially for what concerns its components and 3rd party services."},{"ref":"010-system_requirements.html","title":"System Requirements","module":"010-system_requirements","type":"extras","doc":"System Requirements"},{"ref":"020-prerequisites.html","title":"Prerequisites","module":"020-prerequisites","type":"extras","doc":"Prerequisites"},{"ref":"030-installation_kubernetes.html","title":"Installation in a Kubernetes Cluster","module":"030-installation_kubernetes","type":"extras","doc":"Installation in a Kubernetes Cluster"},{"ref":"040-installation_containers.html","title":"Installation with Containers","module":"040-installation_containers","type":"extras","doc":"Installation with Containers"},{"ref":"050-installation_standalone.html","title":"Installation with Standalone components","module":"050-installation_standalone","type":"extras","doc":"Installation with Standalone components"},{"ref":"060-setup_cluster.html","title":"Setting up the Cluster","module":"060-setup_cluster","type":"extras","doc":"Setting up the Cluster"},{"ref":"070-manage_realms.html","title":"Managing Realms","module":"070-manage_realms","type":"extras","doc":"Managing Realms"},{"ref":"080-upgrade_guide.html","title":"Upgrading the Cluster","module":"080-upgrade_guide","type":"extras","doc":"Upgrading the Cluster"},{"ref":"010-astarte_in_5_minutes.html","title":"Astarte in 5 minutes","module":"010-astarte_in_5_minutes","type":"extras","doc":"Astarte in 5 minutes This tutorial will guide you through bringing up your Astarte instance, creating a realm and streaming your first data from a device simulator (or a real device) before your cup of tea is ready."},{"ref":"010-astarte_in_5_minutes.html#before-you-begin","title":"Astarte in 5 minutes - Before you begin","module":"010-astarte_in_5_minutes","type":"extras","doc":"First of all, please keep in mind that this setup is not meant to be used in production: by default, no persistence is involved, the installation does not have any recovery mechanism, and you will have to restart services manually in case something goes awry. This guide is great if you want to take Astarte for a spin, or if you want to use an isolated instance for development. You will need a machine with at least 4GB of RAM (mainly due to Cassandra), with Docker, cfssl, Python 3 and OpenSSL installed. You will need the PyJWT Python module for generating JWT tokens for Astarte, which you can install either via pip3 (pip3 install PyJWT) or using your distribution&#39;s packages (e.g. apt-get install python3-jwt on Debian based distributions). Also, on the machine(s) or device(s) you will use as a client, you will need either Docker, or a Qt5 installation with development components if you wish to build and run components locally."},{"ref":"010-astarte_in_5_minutes.html#install-astarte","title":"Astarte in 5 minutes - Install Astarte","module":"010-astarte_in_5_minutes","type":"extras","doc":"To get our Astarte instance running as fast as possible, we will install Astarte&#39;s standalone distribution. It includes a tunable Docker Compose which brings up Astarte and every companion service needed for it to work. To do so, simply clone Astarte&#39;s main repository and use its scripts to bring it up: $ git clone https://github.com/astarte-platform/astarte.git &amp;&amp; cd astarte $ ./generate-compose-files.sh $ docker-compose up -d generate-compose-files.sh will generate a root CA for devices, a key pair for Housekeeping, and a self-signed certificate for the broker (note: this is a really bad idea in production). You can tune the compose file further to use legitimate certificates and custom keys, but this is out of the scope of this tutorial. Compose might take some time to bring everything up, but usually within a minute from the containers creation Astarte will be ready. Compose will forward the following ports to your machine: 4000: Realm Management API 4001: Housekeeping API 4002: AppEngine API 4003: Pairing API 8883: MQTTS 1885: MQTT with Proxy Protocol for SSL termination (won&#39;t be used) 80: Let&#39;s Encrypt verification (won&#39;t be used) This example won&#39;t use Let&#39;s Encrypt with VerneMQ - in case binding to port 80 is a problem to you, you can comment it out in docker-compose.yml without affecting any functionality. To check everything went fine, use docker ps to verify relevant containers are up: Astarte itself, VerneMQ, PostgreSQL (used by CFSSL), CFSSL, RabbitMQ and Cassandra should be now running on your system. If any of them isn&#39;t up and running, docker ps -a should show it stopped or failed. In those cases, it is advised to issue docker-compose up -d again to fix potential temporary failures."},{"ref":"010-astarte_in_5_minutes.html#create-a-realm","title":"Astarte in 5 minutes - Create a Realm","module":"010-astarte_in_5_minutes","type":"extras","doc":"Now that we have our instance up and running, we can start setting up a Realm for our device. We&#39;ll call our Realm test. Given we have no SSO or Authentication mechanism set up, we&#39;re just going to generate a public key to sign our JWTs with. You can create one with OpenSSL: $ openssl genrsa -out test_realm.key 4096 $ openssl rsa -in test_realm.key -pubout -outform PEM -out test_realm.key.pub $ awk &#39;{printf &quot;%s\\\\n&quot;, $0}&#39; test_realm.key.pub &gt; test_realm.key.pub.api Also, we will need a JWT token to authenticate against Housekeeping. generate-compose-files.sh created a public key automatically, which is in compose/astarte-keys/housekeeping.pub. To generate a JWT token for authorizing our calls, we will use the handy generate-astarte-credentials utility in Astarte&#39;s repository, which can also be easily inlined into cURL. Use cURL to invoke Housekeeping API for creating a new Realm: $ curl -X POST http://localhost:4001/v1/realms -H &quot;Authorization: Bearer $(./generate-astarte-credentials -t housekeeping -p compose/astarte-keys/housekeeping.key)&quot; -H &quot;Content-Type: application/json&quot; -d &quot;{\\&quot;data\\&quot;:{\\&quot;realm_name\\&quot;: \\&quot;test\\&quot;, \\&quot;jwt_public_key_pem\\&quot;: \\&quot;$(cat test_realm.key.pub.api)\\&quot;}}&quot; This creates a test realm, which should be ready to be used almost immediately. To ensure your realm is available and ready, check if it exists in Astarte by issuing: $ curl -X GET http://localhost:4001/v1/realms -H &quot;Authorization: Bearer $(./generate-astarte-credentials -t housekeeping -p compose/astarte-keys/housekeeping.key)&quot;"},{"ref":"010-astarte_in_5_minutes.html#install-an-interface","title":"Astarte in 5 minutes - Install an interface","module":"010-astarte_in_5_minutes","type":"extras","doc":"We will use Astarte&#39;s Qt5 Stream Generator to feed data into Astarte. Clone the repository, as we will have to install its org.astarteplatform.Values interface into our new realm. To do that, we can use cURL again: $ curl -X POST http://localhost:4000/v1/test/interfaces -H &quot;Authorization: Bearer $(./generate-astarte-credentials -t realm -p test_realm.key)&quot; -H &quot;Content-Type: application/json&quot; -d &quot;{\\&quot;data\\&quot;: $(cat ../stream-qt5-test/interfaces/org.astarteplatform.Values.json)}&quot; Now org.astarteplatform.Values should show up among our available interfaces: $ curl -X GET http://localhost:4000/v1/test/interfaces -H &quot;Authorization: Bearer $(./generate-astarte-credentials -t realm -p test_realm.key)&quot; Our Astarte instance is now ready for our devices."},{"ref":"010-astarte_in_5_minutes.html#install-a-trigger","title":"Astarte in 5 minutes - Install a trigger","module":"010-astarte_in_5_minutes","type":"extras","doc":"We will also test Astarte&#39;s push capabilities with a trigger. This will send a POST to a URL of our choice every time the value generated by stream_test is above 0.6. Due to how triggers work, it is fundamental to install the trigger before a device connects. Doing otherwise will cause the trigger to kick in at a later time, and as such no events will be streamed for a while. Replace http://example.com with your target URL in the command below, you can use a Postbin service like Mailgun Postbin to generate a URL and see the POST requests. $ export TRIGGER_TARGET_URL=&quot;http://example.com&quot; $ curl -X POST http://localhost:4000/v1/test/triggers -H &quot;Authorization: Bearer $(./generate-astarte-credentials -t realm -p test_realm.key)&quot; -H &quot;Content-Type: application/json&quot; -d &quot;{\\&quot;data\\&quot;: {\\&quot;name\\&quot;: \\&quot;my_trigger\\&quot;, \\&quot;action\\&quot;: {\\&quot;http_post_url\\&quot;: \\&quot;$TRIGGER_TARGET_URL\\&quot;}, \\&quot;simple_triggers\\&quot;: [{\\&quot;type\\&quot;: \\&quot;data_trigger\\&quot;, \\&quot;on\\&quot;: \\&quot;incoming_data\\&quot;, \\&quot;interface_name\\&quot;: \\&quot;org.astarteplatform.Values\\&quot;, \\&quot;interface_major\\&quot;: 0, \\&quot;match_path\\&quot;: \\&quot;/realValue\\&quot;, \\&quot;value_match_operator\\&quot;: \\&quot;&gt;\\&quot;, \\&quot;known_value\\&quot;: 0.6}]}}&quot; You can now check that your trigger is correctly installed: curl -X GET http://localhost:4000/v1/test/triggers/my_trigger -H &quot;Authorization: Bearer $(./generate-astarte-credentials -t realm -p test_realm.key)&quot;"},{"ref":"010-astarte_in_5_minutes.html#stream-data","title":"Astarte in 5 minutes - Stream data","module":"010-astarte_in_5_minutes","type":"extras","doc":"If you already have an Astarte compliant device, you can configure it and connect it straight away, and it will just work with your new installation - provided you skip SSL checks on the broker&#39;s certificate. If you don&#39;t, you can use Astarte&#39;s stream-qt5-test to emulate an Astarte device and generate a datastream. You can do this either on the same machine where you are running Astarte, or from another machine or device on the same network. Depending on what your client supports, you can either compile stream-qt5-test (this will take some more time), or you can use a ready to use Docker container to launch it. Docker is the easiest and painless way, but this guide will cover both methods. Using a container for stream-qt5-test Astarte&#39;s stream-qt5-test can be pulled from Docker Hub with: $ docker pull astarte/astarte-stream-qt5-test:0.10.0-rc.0 Its most basic invocation (from your astarte repository tree) is: $ docker run --net=&quot;host&quot; -e &quot;DEVICE_ID=$(./generate-astarte-device-id)&quot; -e &quot;PAIRING_HOST=http://localhost:4003&quot; -e &quot;REALM=test&quot; -e &quot;AGENT_KEY=$(./generate-astarte-credentials -t pairing -p test_realm.key)&quot; -e &quot;IGNORE_SSL_ERRORS=true&quot; astarte/astarte-stream-qt5-test:0.10.0-rc.0 This will generate a random datastream from a brand new, random Device ID. You can tweak those parameters to whatever suits you better by having a look at the Dockerfile. You can spawn any number of instances you like, or you can have the same Device ID send longer streams of data by saving the container&#39;s persistency through a Docker Volume. If you wish to do so, simply add -v /persistency:&lt;your persistency path&gt; to your docker run invocation. Refer to stream-qt5-test README for more details on which variables can be passed to the container. Also, please note that the --net=&quot;host&quot; parameter is required to make localhost work. If this is not desirable, you can change PAIRING_HOST to an host reachable from within the container network. Obviously, that parameter isn&#39;t required if you&#39;re running the container on a different machine and PAIRING_HOST is pointing to a different URL."},{"ref":"010-astarte_in_5_minutes.html#building-stream-qt5-test-from-source","title":"Astarte in 5 minutes - Building stream-qt5-test from source","module":"010-astarte_in_5_minutes","type":"extras","doc":"If your target platform does not support running containers, you can build stream-qt5-test from source. To do so, you will have to compile both Astarte Qt5 SDK and Astarte Qt5 Stream Test. Their main dependencies are cmake, qtbase, mosquitto and openssl. If you&#39;re on a Debian derivative, you can install them all with: # apt-get install qt5-default qtbase5-dev libqt5sql5-sqlite libssl-dev libmosquittopp-dev cmake git build-essential Once your dependencies are installed, compile your components: $ git clone https://github.com/astarte-platform/astarte-device-sdk-qt5.git $ cd astarte-device-sdk-qt5 $ mkdir build $ cd build $ cmake -DCMAKE_INSTALL_PREFIX=/usr .. $ make $ make install $ cd - $ git clone https://github.com/astarte-platform/stream-qt5-test.git $ cd stream-qt5-test $ qmake . $ make You can now run stream-qt5-test from your last build directory. Refer to its README (or to its sources) to learn about how to use it and which options are available."},{"ref":"010-astarte_in_5_minutes.html#grab-your-tea","title":"Astarte in 5 minutes - Grab your tea","module":"010-astarte_in_5_minutes","type":"extras","doc":"Congratulations! Your devices or fake devices are now communicating with Astarte, and your tea should be ready by now. You can check if everything is working out by invoking AppEngine APIs to get some values. In case you are using stream-qt5-test, you can get the last sent value via cURL: $ curl -X GET &quot;http://localhost:4002/v1/test/devices/&lt;your device id&gt;/interfaces/org.astarteplatform.Values/realValue?limit=1&quot; -H &quot;Authorization: Bearer $(./generate-astarte-credentials -t appengine -p test_realm.key)&quot; If you get a meaningful value, congratulations - you have a working Astarte installation with your first datastream coming in! Moreover, Astarte&#39;s Docker Compose also installs Astarte Dashboard, from which you can manage your Realms and install Triggers, Interfaces and more from a Web UI. It is accessible by default at http://localhost:4040/ - remember that if you are not exposing Astarte from localhost, you have to change Realm Management API&#39;s URL in Dashboard&#39;s configuration file, to be found in compose/astarte-dashboard/config.json in Astarte&#39;s repository. You can generate a token for Astarte Dashboard, as usual, through ./generate-astarte-credentials -t realm -p test_realm.key. Grant a longer expiration by using the -e parameter to avoid being logged out too quickly. From here on, you can use all of Astarte&#39;s APIs and features from your own installation. You can add devices, experiment with interfaces, or develop your own applications on top of Astarte&#39;s triggers or AppEngine&#39;s APIs. And have a lot of fun!"},{"ref":"010-astarte_in_5_minutes.html#cleaning-up","title":"Astarte in 5 minutes - Cleaning up","module":"010-astarte_in_5_minutes","type":"extras","doc":"When you&#39;re done with your tests and developments, you can use docker-compose again to tear down your Astarte instance simply by issuing: $ docker-compose down Unless you add the -v option, persistencies will be kept and next time you will docker-compose up the cluster will come back in the very same state you left it last time. docker-compose down -v is extremely useful during development, especially if you want a clean slate for testing your applications or your routines every time."},{"ref":"010-astarte_in_5_minutes.html#troubleshooting","title":"Astarte in 5 minutes - Troubleshooting","module":"010-astarte_in_5_minutes","type":"extras","doc":"Could not generate credentials If astarte-generate-credentials fails with this error Traceback (most recent call last): File &quot;./generate-astarte-credentials&quot;, line 37, in &lt;module&gt; encoded = jwt.encode(claims, private_key_pem, algorithm=&quot;RS256&quot;) AttributeError: module &#39;jwt&#39; has no attribute &#39;encode&#39; you have to remove the conflicting jwt pip package by uninstalling it with pip3 uninstall jwt."},{"ref":"010-astarte_in_5_minutes.html#final-notes","title":"Astarte in 5 minutes - Final notes","module":"010-astarte_in_5_minutes","type":"extras","doc":"Running Astarte through docker-compose is the fastest way for going from zero to hero. However, please keep in mind this setup is unlikely to hold for long in production, and is by design broken for large installations. We can&#39;t stop you from running such a thing in production, but do so as long as you know you voided your warranty by doing so. This method is great for development and for trying out the system. If you wish to deploy Astarte in a more robust environment, have a look at Astarte Enterprise or, if you want to go the DIY way, make sure that at least every service which requires persistency has reliable storage and adequate redundancy beneath it."},{"ref":"001-intro_api.html","title":"Introduction","module":"001-intro_api","type":"extras","doc":"Introduction Astarte&#39;s APIs are documented through Swagger. Your Astarte installation probably already has Swagger UI support, which serves as the reference for your installed APIs. To browse API documentation online, follow this link."}]