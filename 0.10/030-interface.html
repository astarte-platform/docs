<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.20.0">
    <meta name="project" content="Astarte v0.10.0-rc.0">
    <title>Interfaces â€” Astarte v0.10.0-rc.0</title>
    <link rel="stylesheet" href="dist/html-11fdd9cd6b7c7c3981df.css" />
    <script src="dist/sidebar_items-4965de0ca6.js"></script>
      <script src="docs_config.js"></script>
    <script async src="dist/html-11fdd9cd6b7c7c3981df.js"></script>
    
  </head>
  <body data-type="extras">
    <script>try { if(localStorage.getItem('night-mode')) document.body.className += ' night-mode'; } catch (e) { }</script>
<div class="main">

<button class="sidebar-button sidebar-toggle">
  <span class="icon-menu" title="Collapse/expand sidebar"></span>
</button>

<section class="sidebar">
  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button">
      <span class="icon-search" aria-hidden="true"></span>
    </button>
    <button type="button" tabindex="-1" class="search-close-button">
      <span class="icon-cross" title="Cancel search"></span>
    </button>
    <label class="search-label">
      <input name="q" type="text" id="search-list" class="search-input" placeholder="Search..." aria-label="Search" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">
    <div class="sidebar-projectDetails">
      <a href="http://astarte-platform.org" class="sidebar-projectName">
Astarte      </a>
      <h2 class="sidebar-projectVersion">
        v0.10.0-rc.0
      </h2>
    </div>
      <a href="http://astarte-platform.org">
        <img src="assets/logo.png" alt="Astarte" class="sidebar-projectImage">
      </a>
  </div>

  <ul class="sidebar-listNav">
    <li><a id="extras-list" href="#full-list">Pages</a></li>



  </ul>
  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <div class="content-outer">
    <div id="content" class="content-inner">


<h1>Interfaces</h1>
<p>Interfaces are a core concept of Astarte which defines how data is exchanged between Astarte and its peers. They are not to be intended as OOP interfaces, but rather as the following definition:</p>
<blockquote><p>In computing, an interface is a shared boundary across which two or more separate components of a computer system exchange information.</p>
</blockquote>
<p>In Astarte each interface has an owner, can represent either a continuous data stream or a snapshot of a set of properties, and can be either aggregated into an object or be an independent set of individual members.</p>
<p>If you are already familiar with interface&#39;s basic concepts, you might want to jump directly to the <a href="040-interface_schema.html">Interface Schema</a>.</p>
<h2 id="versioning" class="section-heading">
  <a href="#versioning" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Versioning
</h2>

<p>Interfaces are versioned, each interface having both a major version and a minor version number. The concept behind these two version numbers mimics <a href="http://semver.org/">Semantic Versioning</a>: arbitrary changes can happen exclusively between different major versions (e.g. removing members, changing types, etc...), whereas minor versions allow incremental additive changes only (e.g. adding members).</p>
<p>Several different major versions of the same interface can coexist at the same time in Astarte, although a Device can hold only a single version of an interface at a time (even though interfaces can be updated over time). Interfaces, internally, are univocally identified by their name and their major version.</p>
<h2 id="format" class="section-heading">
  <a href="#format" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Format
</h2>

<p>Interfaces are described using a JSON document. Each interface is identified by an unique interface name of maximum 128 characters, which must be a <a href="https://en.wikipedia.org/wiki/Reverse_domain_name_notation">Reverse Domain Name</a>. As a convention, the interface name usually contains its author&#39;s URI Reverse Internet Domain Name.</p>
<p>An example skeleton looks like this:</p>
<pre><code class="nohighlight makeup elixir"><span class="p" data-group-id="6359177910-1">{</span><span class="w">
   </span><span class="ss">&quot;interface_name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;com.test.MyInterfaceName&quot;</span><span class="p">,</span><span class="w">
   </span><span class="ss">&quot;version_major&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
   </span><span class="ss">&quot;version_minor&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
   </span><span class="p" data-group-id="6359177910-2">[</span><span class="n">...</span><span class="p" data-group-id="6359177910-2">]</span><span class="w">
</span><span class="p" data-group-id="6359177910-1">}</span></code></pre>
<p>Valid values and variables are listed in the <a href="040-interface_schema.html">Interface Schema</a>.</p>
<h2 id="interface-type" class="section-heading">
  <a href="#interface-type" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Interface Type
</h2>

<p>Interfaces have a well-known, predefined type, which can be either <code class="inline">property</code> or <code class="inline">datastream</code>. Every Device in Astarte can have any number of interfaces of any different types.</p>
<h3 id="datastream" class="section-heading">
  <a href="#datastream" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Datastream
</h3>

<p><code class="inline">datastream</code> represents a mutable, ordered stream of data, with no concept of persistent state or synchronization. As a rule of thumb, <code class="inline">datastream</code> interfaces should be used when dealing with values such as sensor samples, commands and events. <code class="inline">datastream</code> are stored as time series in the database, making them suitable for time span filtering and any other common time series operation, and they are not idempotent in the REST API semantics.</p>
<p>Due to their nature, <code class="inline">datastream</code> interfaces have a number of <a href="#datastream-specific%20features">additional properties</a> which fine tune their behavior.</p>
<h3 id="properties" class="section-heading">
  <a href="#properties" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Properties
</h3>

<p><code class="inline">properties</code> represent a persistent, stateful, synchronized state with no concept of history or timestamping. <code class="inline">properties</code> are useful, for example, when dealing with settings, states or policies/rules. <code class="inline">properties</code> are stored in a key-value fashion, and grouped according to their interface, and they are idempotent in the REST API semantics. Rather than being able to act on a stream like in the <code class="inline">datastream</code> case, <code class="inline">properties</code> can be retrieved, or can be used as a <a href="060-triggers.html">trigger</a> whenever they change.</p>
<p>Values in a <code class="inline">properties</code> interface can be unset (or deleted according to the http jargon): to allow such a thing, the interface must have its <code class="inline">allow_unset</code> property set to <code class="inline">true</code>. Please <a href="040-interface_schema.html">refer to the JSON Schema</a> for further details.</p>
<h2 id="ownership" class="section-heading">
  <a href="#ownership" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Ownership
</h2>

<p>Astarte&#39;s design mandates that each interface has an owner. The owner of an interface has a write-only access to it, whereas other actors have read-only access. Interface <strong>ownership</strong> can be either <code class="inline">device</code> or <code class="inline">server</code>: the owner is the actor producing the data, whereas the other actor consumes data.</p>
<h2 id="mappings" class="section-heading">
  <a href="#mappings" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Mappings
</h2>

<p>Every interface must have an array of mappings. Mappings are designed around REST controller semantics: each mapping describes an endpoint which is resolved to a path, it is strongly typed, and can have additional options. Just like in REST controllers, Endpoints can be parametrized to build REST-like collection and trees. Parameters are identified by <code class="inline">%{parameterName}</code>, with each endpoint supporting any number of parameters (see <a href="#limitations">Limitations</a>).</p>
<p>This is how a parametrized mapping looks like:</p>
<pre><code class="nohighlight makeup elixir"><span class="w">   </span><span class="p" data-group-id="4235299213-1">[</span><span class="n">...</span><span class="p" data-group-id="4235299213-1">]</span><span class="w">
   </span><span class="ss">&quot;mappings&quot;</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="4235299213-2">[</span><span class="w">
       </span><span class="p" data-group-id="4235299213-3">{</span><span class="w">
           </span><span class="ss">&quot;endpoint&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;/%{itemIndex}/value&quot;</span><span class="p">,</span><span class="w">
           </span><span class="ss">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;integer&quot;</span><span class="p">,</span><span class="w">
           </span><span class="ss">&quot;reliability&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;unique&quot;</span><span class="p">,</span><span class="w">
           </span><span class="ss">&quot;retention&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;discard&quot;</span><span class="w">
       </span><span class="p" data-group-id="4235299213-3">}</span><span class="p">,</span><span class="w">
   </span><span class="p" data-group-id="4235299213-4">[</span><span class="n">...</span><span class="p" data-group-id="4235299213-4">]</span></code></pre>
<p>In this example, <code class="inline">/0/value</code>, <code class="inline">/1/value</code> or <code class="inline">/test/value</code> all map to a valid endpoint, while <code class="inline">/te/st/value</code> can&#39;t be resolved by any endpoint.</p>
<h3 id="supported-data-types" class="section-heading">
  <a href="#supported-data-types" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Supported data types
</h3>

<p>The following types are supported:</p>
<ul>
<li><code class="inline">double</code>: A double-precision floating-point format as specified by binary64, by the IEEE 754 standard
</li>
<li><code class="inline">integer</code>: A signed 32 bit integer.
</li>
<li><code class="inline">boolean</code>: Either <code class="inline">true</code> or <code class="inline">false</code>, adhering to JSON boolean type.
</li>
<li><code class="inline">longinteger</code>: A signed 64 bit integer (please note that <code class="inline">longinteger</code> is represented as a string by default in JSON-based APIs.).
</li>
<li><code class="inline">string</code>: An UTF-8 string.
</li>
<li><code class="inline">binaryblob</code>: An arbitrary sequence of any byte that should be shorter than 1 MiB. (<code class="inline">binaryblob</code> is represented as a base64 string by default in JSON-based APIs.).
</li>
<li><code class="inline">datetime</code>: A UTC timestamp, internally represented as milliseconds since 1st Jan 1970 using a signed 64 bits integer. (<code class="inline">datetime</code> is represented as an ISO 8601 string by default in JSON based APIs.)
</li>
<li><code class="inline">doublearray</code>, <code class="inline">integerarray</code>, <code class="inline">booleanarray</code>, <code class="inline">longintegerarray</code>, <code class="inline">stringarray</code>, <code class="inline">binaryblobarray</code>, <code class="inline">datetimearray</code>: A list of values, represented as a JSON Array. Arrays can have up to 32768 items, must be shorter than 1MiB, and each item must be shorter than 64KiB. In particular, text fields must be shorter than 32000 characters.
</li>
</ul>
<h3 id="limitations" class="section-heading">
  <a href="#limitations" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Limitations
</h3>

<p>A valid interface must resolve a path univocally to a single endpoint. Take the following example:</p>
<pre><code class="nohighlight makeup elixir"><span class="w">   </span><span class="p" data-group-id="1406135673-1">[</span><span class="n">...</span><span class="p" data-group-id="1406135673-1">]</span><span class="w">
   </span><span class="ss">&quot;mappings&quot;</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="1406135673-2">[</span><span class="w">
       </span><span class="p" data-group-id="1406135673-3">{</span><span class="w">
           </span><span class="ss">&quot;endpoint&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;/%{itemIndex}/value&quot;</span><span class="p">,</span><span class="w">
           </span><span class="ss">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;integer&quot;</span><span class="w">
       </span><span class="p" data-group-id="1406135673-3">}</span><span class="p">,</span><span class="w">
       </span><span class="p" data-group-id="1406135673-4">{</span><span class="w">
           </span><span class="ss">&quot;endpoint&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;/myPath/value&quot;</span><span class="p">,</span><span class="w">
           </span><span class="ss">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;integer&quot;</span><span class="w">
       </span><span class="p" data-group-id="1406135673-4">}</span><span class="p">,</span><span class="w">
   </span><span class="p" data-group-id="1406135673-5">[</span><span class="n">...</span><span class="p" data-group-id="1406135673-5">]</span></code></pre>
<p>In such a case, the interface isn&#39;t valid and is rejected, due to the fact that path <code class="inline">/myPath/value</code> is ambiguous and could be resolved to two different endpoints.</p>
<p>Any endpoint configuration must not generate paths that are prefix of other paths, for this reason the following example is also invalid:</p>
<pre><code class="nohighlight makeup elixir"><span class="w">   </span><span class="p" data-group-id="2540220018-1">[</span><span class="n">...</span><span class="p" data-group-id="2540220018-1">]</span><span class="w">
   </span><span class="ss">&quot;mappings&quot;</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="2540220018-2">[</span><span class="w">
       </span><span class="p" data-group-id="2540220018-3">{</span><span class="w">
           </span><span class="ss">&quot;endpoint&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;/some/thing&quot;</span><span class="p">,</span><span class="w">
           </span><span class="ss">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;integer&quot;</span><span class="w">
       </span><span class="p" data-group-id="2540220018-3">}</span><span class="p">,</span><span class="w">
       </span><span class="p" data-group-id="2540220018-4">{</span><span class="w">
           </span><span class="ss">&quot;endpoint&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;/some/%{param}/value&quot;</span><span class="p">,</span><span class="w">
           </span><span class="ss">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;integer&quot;</span><span class="w">
       </span><span class="p" data-group-id="2540220018-4">}</span><span class="p">,</span><span class="w">
   </span><span class="p" data-group-id="2540220018-5">[</span><span class="n">...</span><span class="p" data-group-id="2540220018-5">]</span><span class="w">
</span></code></pre>
<p>In case the interface&#39;s aggregation is <code class="inline">object</code>, additional restrictions apply. Endpoints in the same interface must all have the same depth, and the same number of parameters. If the interface is parametrized, every endpoint must have the same parameter name at the same level. This is an example of a valid aggregated interface mapping:</p>
<pre><code class="nohighlight makeup elixir"><span class="w">   </span><span class="p" data-group-id="7408007023-1">[</span><span class="n">...</span><span class="p" data-group-id="7408007023-1">]</span><span class="w">
   </span><span class="ss">&quot;mappings&quot;</span><span class="p">:</span><span class="w"> </span><span class="p" data-group-id="7408007023-2">[</span><span class="w">
       </span><span class="p" data-group-id="7408007023-3">{</span><span class="w">
           </span><span class="ss">&quot;endpoint&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;/%{itemIndex}/value&quot;</span><span class="p">,</span><span class="w">
           </span><span class="ss">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;integer&quot;</span><span class="w">
       </span><span class="p" data-group-id="7408007023-3">}</span><span class="p">,</span><span class="w">
       </span><span class="p" data-group-id="7408007023-4">{</span><span class="w">
           </span><span class="ss">&quot;endpoint&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;/%{itemIndex}/otherValue&quot;</span><span class="p">,</span><span class="w">
           </span><span class="ss">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;string&quot;</span><span class="w">
       </span><span class="p" data-group-id="7408007023-4">}</span><span class="p">,</span><span class="w">
   </span><span class="p" data-group-id="7408007023-5">[</span><span class="n">...</span><span class="p" data-group-id="7408007023-5">]</span></code></pre>
<h2 id="aggregation" class="section-heading">
  <a href="#aggregation" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Aggregation
</h2>

<p>In a real world scenario, such as an array of sensors, there are usually two main cases. A sensor might have one or more independent values which are sampled individually and sent whenever they become available independently. Or a sensor might sample at the same time a number of values, which might as well have some form of correlation.</p>
<p>In Astarte, this concept is mapped to interface <code class="inline">aggregation</code>. In case aggregation is <code class="inline">individual</code>, each mapping is treated as an independent value and is managed individually. In case aggregation is <code class="inline">object</code>, Astarte expects the owner to send all of the interface&#39;s mappings at the same time, packed in a single message. In this case, all of the mappings share some core properties such as the timestamp.</p>
<p>Aggregation is a powerful mechanism that can be used to map interfaces to real world <em>&quot;objects&quot;</em>. Moreover, aggregated interfaces can also be parametrized, although with <a href="#limitations">some limitations</a>.</p>
<h2 id="metadata" class="section-heading">
  <a href="#metadata" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Metadata
</h2>

<p>In case <a href="#aggregation"><code class="inline">aggregation</code></a> is <code class="inline">individual</code>, it might be desirable to attach some additional information to each value when it gets produced. In this case, Astarte allows to attach <em>metadata</em>: a map of key:value pairs which can contain arbitrary, schema-less data. Metadata is not indexed, but can be optionally retrieved or used in triggers.</p>
<p>Metadata is disabled by default: you can enable metadata on an interface by setting <code class="inline">has_metadata</code> to <code class="inline">true</code>.</p>
<h2 id="datastream-specific-features" class="section-heading">
  <a href="#datastream-specific-features" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Datastream-specific features
</h2>

<p><code class="inline">datastream</code> interfaces are highly tunable, depending on the kind of data they are representing: it is possible to fine tune several aspects of how data is stored, transferred and indexed. The following properties can be set either at interface level, making them the default for each mapping, or at mapping level, overriding any interface-wide setting.</p>
<blockquote><p>NOTE: In case the interface is aggregated, overriding any additional properties at mapping level does not have any effect, and might cause a validation error.</p>
</blockquote>
<ul>
<li><code class="inline">explicit_timestamp</code>: By default, Astarte associates a timestamp to data whenever it is collected (or - when the message hits the data collection stage). However, when setting this property to <code class="inline">true</code>, Astarte expects the owner to attach a valid timestamp each time it produces data. In that case, the provided timestamp is used for indexing.
</li>
<li><code class="inline">reliability</code>: Each mapping can be <code class="inline">unreliable</code> (default), <code class="inline">guaranteed</code>, <code class="inline">unique</code>. This defines whether data should be considered delivered when the transport successfully sends the data regardless of the outcome (<code class="inline">unreliable</code>), when data has been received at least once by the recipient (<code class="inline">guaranteed</code>) or when data has been received exactly once by the recipient (<code class="inline">unique</code>). When using <code class="inline">reliable</code> data, consider you might incur in additional resource usage on both the transport and the device&#39;s end.
</li>
<li><code class="inline">retention</code>: Each mapping can have a <code class="inline">discard</code> (default), <code class="inline">volatile</code>, <code class="inline">stored</code> retention. This defines whether data should be discarded if the transport is temporarily uncapable of delivering it (<code class="inline">discard</code>), should be kept in a cache in memory (<code class="inline">volatile</code>) or on disk (<code class="inline">stored</code>), and guaranteed to be delivered in the timeframe defined by the <code class="inline">expiry</code>.
</li>
<li><code class="inline">expiry</code>: Meaningful only when <code class="inline">retention</code> is <code class="inline">stored</code>. Defines how many seconds a specific data entry should be kept before giving up and erasing it from the persistent cache. A value &lt;= 0 means the persistent cache never expires, and is the default.
</li>
</ul>
<h2 id="best-practices" class="section-heading">
  <a href="#best-practices" class="hover-link"><span class="icon-link" aria-hidden="true"></span></a>
  Best practices
</h2>

<ul>
<li>When creating interface drafts, or for testing purposes in general, it is recommended to use 0 as the major version, to make maintenance and testing easier. Currently, Astarte allows only interfaces with <code class="inline">major_version</code> == 0 to be deleted, and this limitation will probably be never lifted to prevent data loss.
</li>
<li>When sending real time commands in <code class="inline">datastream</code> interfaces, <code class="inline">discard</code> is usually the best option. Even though it does not guarantee delivery, it prevents users from unwillingly sending the same command over and over if the recipient isn&#39;t available, causing a queue of commands to be sent to the recipient when it gets back online. In general, <a href="#datastream-specific-features"><code class="inline">retention</code></a> should be used to keep track of low traffic/important events
</li>
</ul>
      <footer class="footer">
        <p>
          <span class="line">
            Built using
            <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener">ExDoc</a> (v0.20.0),
          </span>
          <span class="line">
            designed by
            <a href="https://twitter.com/dignifiedquire" target="_blank" rel="noopener" title="@dignifiedquire">Friedel Ziegelmayer</a>.
          </span>
        </p>
        <p>
          <button class="line footer-button night-mode-toggle">
            Toggle night mode
          </button>
          <button class="line footer-button display-shortcuts-help">
            Display keyboard shortcuts
          </button>
        </p>
      </footer>
    </div>
  </div>
</section>
</div>
  
  </body>
</html>

