searchNodes=[{"doc":"Introduction This documentation page describes a discontinued version, for production systems use a newer version instead. Astarte is a collection of components written in Elixir meant to orchestrate and pilot a number of 3rd party components. These components include: One or more ingresses (the most popular implementation being an MQTT broker) An AMQP broker for handling messages and queues between Astarte's services A Cassandra-like Database for ingesting and retrieving data (currently Cassandra and ScyllaDB are both supported) These components are never directly exposed to Astarte's end user, who requires no knowledge whatsoever of the mentioned frameworks - they are rather orchestrated and managed directly by Astarte's services. It is, however, responsability of Astarte's administrators to make sure these services are made available the way they are meant to. For more details on this topic and, in general, on how to deal with Astarte's installation and maintenance, please refer to the Administrator Guide .","ref":"001-intro_architecture.html","title":"Introduction","type":"extras"},{"doc":"Design Principles Astarte has a strongly opinionated design aimed at the generic IoT / data-driven use case. As such, and unlike other platforms, it strives to streamline a very simple user workflow for ingesting, distributing and retrieving data, built on a set of concepts and principles.","ref":"010-design_principles.html","title":"Design Principles","type":"extras"},{"doc":"Astarte does not allow exchanging raw data - it rather forces the user to describe data before it is sent into the platform. Data is described with a mechanism named Interfaces, explained in detail in the user guide . Through Interfaces, Astarte creates and maintains a data model autonomously, sparing the user from the complexity of dealing with Databases and Data Management in general.","ref":"010-design_principles.html#declarative-vs-explicit-data-management","title":"Design Principles - Declarative vs. Explicit Data Management","type":"extras"},{"doc":"Astarte services use a Protobuf-based API to exchange data over AMQP in a gRPC like fashion. As such, as long as a service conforms with the policies defined by the queues, it is possible to extend Astarte in virtually any language that can deliver a compliant AMQP client.","ref":"010-design_principles.html#amqp-as-internal-api-mechanism","title":"Design Principles - AMQP as internal API mechanism","type":"extras"},{"doc":"Astarte identifies each device with a 128 bit Device ID which has to be unique within its Realm. As a best practice, it is advised to generate such an ID from hardware unique IDs or using dedicated hardware modules, to make it consistent across device reflashes. It is advised to use a cryptographic hash function (such as sha256) when generating it using a software module. Astarte will use URL encoded base64 (without padding) strings like V_zv6ThCCtXWveQ8mPjsKg in its representation. Although not required, it is strongly advised to use UUIDs as Astarte Device IDs. In fact, Astarte Device ID's specification is 100% compatible with UUIDs Base64 encoded adhering to RFC 7515. In the same fashion, UUIDv5 can be used to generate a deterministic Device ID from any kind of input data. Astarte Clients which generate Astarte Device IDs (such as astartectl or Astarte Dashboard) will always generate a Device ID out of UUIDv4 (random ID) or UUIDv5 (deterministic ID). This detail is relevant not only for identifying and querying the device, but also for the Pairing mechanism , as a device's credentials are associated to its Device ID. Note: currently, Astarte accepts Device IDs longer than 128 bit, which are then truncated to 128 bit internally. This behaviour exists for compatibility reasons but it's not supported and will likely change in future releases - hence, refrain from using anything which is not a 128-bit Device ID. Note: As much as Device IDs should effectively be unique per-realm and this configuration will always be supported, some future optional optimizations might be available on top of the assumption that Device IDs are globally unique to an Astarte installation. Given the Device ID format has a 2&lt;sup&gt;-128&lt;/sup&gt; chance of collision, it is safe to assume that as long as best practices for Device ID generation are followed, Device IDs will always be globally unique.","ref":"010-design_principles.html#device-id","title":"Design Principles - Device ID","type":"extras"},{"doc":"Astarte assumes devices are capable of exchanging data over a transport/protocol supporting SSL/TLS (e.g.: MQTT). This is a strong requirement, as Astarte identifies devices through client SSL certificates when it comes to data exchange. Each transport implementation must be capable of mapping interfaces and out-of-band messages on top of it. Astarte itself does not care about the implementation detail of the transport itself, as the transport is in charge of converting its input to an AMQP message following Astarte's internal API specification. Astarte's official reference and recommended design is MQTT using VerneMQ and its Astarte plugin. Device SDK and code generation Device SDKs can take advantage of the interface design to dynamically generate code for exchanging data with Astarte. This way, developers using Device SDKs are spared from knowing details about the underlying transports and protocols, and can use a data-driven API. However, there are some limitations and requirements: The SDK requires SSL support - Astarte does not allow exchanging data over unencrypted channels and its design builds on the assumption that everything runs on top of SSL. If your device isn't capable of SSL, you are probably looking for Gateway support in Astarte. As much as the SDK can implement virtually any transport protocol, it is required that the SDK supports at least HTTP(s) for Pairing.","ref":"010-design_principles.html#device-interaction","title":"Design Principles - Device interaction","type":"extras"},{"doc":"Astarte is natively multitenant through the concept of Realms. Each Realm is a logical portion of Astarte, and usually represents an organization or, in general, a set of devices physically/logically isolated. Realms build upon the concept of keyspaces in Cassandra. Each Realm has its very own keyspace and has no shared data with other Realms. In fact, it is even possible to have a dedicated Cassandra cluster for a single realm in complex installations.","ref":"010-design_principles.html#realms-and-multitenancy","title":"Design Principles - Realms and multitenancy","type":"extras"},{"doc":"In Astarte, transports are given the task to deliver messages in a well-known AMQP structure. The ordering of such messages is then preserved on a set of criterias: There is no such thing as &quot;in-order&quot; among devices. A message X sent to device A can be processed after a message Y sent to device B even if Y was ingested in the AMQP queue before X. This is intentional and by design. All messages to a specific device A are always guaranteed to be processed in the very same order of the transport ingestion. Ordering is not dependent on the message timestamp, which can be set by different sources (depending on the interface's definition of timestamp). For example, interface A has explicit timestamping while interface B doesn't. Message X from A has an earlier timestamp than message Y from B, but if message Y has been ingested before X, Y will be processed before X regardless. Responsibility of message ordering before entering AMQP is entirely up to the transport, and different transports might have different behaviors when it comes to message ordering. Astarte provides this guarantee right after the transport itself. Message ordering concerns only pipelines in the DUP , including but not limited to data ingestion in the Database and Simple Triggers.","ref":"010-design_principles.html#message-ordering","title":"Design Principles - Message Ordering","type":"extras"},{"doc":"Triggers are rules which are &quot;triggered&quot; whenever one or more conditions are satisfied. Every satisfied condition generates an ordered event for the Trigger Engine to be processed. They are one of the core concepts in Astarte and are the preferred way to handle push interactions between Astarte and connected applications. More details about triggers can be found in the dedicated section .","ref":"010-design_principles.html#triggers","title":"Design Principles - Triggers","type":"extras"},{"doc":"Components Astarte is a distributed system interacting over AMQP, as explained in Design Principles . This is an overview of its main internal services.","ref":"020-components.html","title":"Components","type":"extras"},{"doc":"Pairing takes care of Device Authentication and Authorization. It interacts with Astarte's CA and orchestrates the way devices connect and interact with Transports. It also handles Device Registration. Agent, Device and Pairing interaction is described in detail here .","ref":"020-components.html#pairing","title":"Components - Pairing","type":"extras"},{"doc":"Data Updater Plant is a replicable, scalable component which takes care of the ingestion pipeline. It gathers data from devices and orchestrates data flow amongst other components. It is, arguably, the most critical component of the system and the most resource hungry - the way DUP is deployed, replicated and configured has a tremendous impact on Astarte's performances, especially when dealing with massive data flows.","ref":"020-components.html#data-updater-plant-dup","title":"Components - Data Updater Plant (DUP)","type":"extras"},{"doc":"Trigger Engine takes care of processing Triggers. It is a purely computational component which handles every Trigger's pipeline and triggers actions accordingly.","ref":"020-components.html#trigger-engine","title":"Components - Trigger Engine","type":"extras"},{"doc":"AppEngine is Astarte's main API endpoint for end users. AppEngine exposes a RESTful API to retrieve and send data from/to devices, according to their interfaces. Every direct device interaction can be done from here. It also exposes Channels, a WebSocket-based solution for listening to device events in real-time with Triggers' same mechanism and semantics.","ref":"020-components.html#appengine","title":"Components - AppEngine","type":"extras"},{"doc":"Realm Management is an administrator-like API for configuring a Realm. It is used for managing Interfaces, Triggers, Devices and more.","ref":"020-components.html#realm-management","title":"Components - Realm Management","type":"extras"},{"doc":"Housekeeping is the equivalent of a superadmin API. It is usually not accessible to the end user but rather to Astarte's administrator who, in most cases, might deny overall outside access. It allows to manage and create Realms, and perform cluster-wide maintenance actions.","ref":"020-components.html#housekeeping","title":"Components - Housekeeping","type":"extras"},{"doc":"Interfaces Interfaces are a core concept of Astarte which defines how data is exchanged between Astarte and its peers. They are not to be intended as OOP interfaces, but rather as the following definition: In computing, an interface is a shared boundary across which two or more separate components of a computer system exchange information. In Astarte each interface has an owner, can represent either a continuous data stream or a snapshot of a set of properties, and can be either aggregated into an object or be an independent set of individual members. If you are already familiar with interface's basic concepts, you might want to jump directly to the Interface Schema .","ref":"030-interface.html","title":"Interfaces","type":"extras"},{"doc":"Interfaces are versioned, each interface having both a major version and a minor version number. The concept behind these two version numbers mimics Semantic Versioning : arbitrary changes can happen exclusively between different major versions (e.g. removing members, changing types, etc...), whereas minor versions allow incremental additive changes only (e.g. adding members). Several different major versions of the same interface can coexist at the same time in Astarte, although a Device can hold only a single version of an interface at a time (even though interfaces can be updated over time). Interfaces, internally, are univocally identified by their name and their major version.","ref":"030-interface.html#versioning","title":"Interfaces - Versioning","type":"extras"},{"doc":"Interfaces are described using a JSON document. Each interface is identified by an unique interface name of maximum 128 characters, which must be a Reverse Domain Name . As a convention, the interface name usually contains its author's URI Reverse Internet Domain Name. An example skeleton looks like this: { &quot;interface_name&quot;: &quot;com.test.MyInterfaceName&quot;, &quot;version_major&quot;: 1, &quot;version_minor&quot;: 0, [...] } Valid values and variables are listed in the Interface Schema . Name limitations A valid interface name consists of a Reverse Domain Name containing alphanumeric characters, hyphens and dots. By design, both the top level domain and last domain component can not contain hyphens, although hypens are allowed in other parts of the interface name (e.g.: org.astarte-platform.Values is a valid interface name). Interface names have to be fully-defined Reverse Domain Names. Values will not be accepted as an Astarte interface name, whereas org.astarte-platform.Values is a valid one. Interface's uniqueness is case insensitive - this means you cannot install two interfaces with the same name and different casing (e.g.: org.astarte-platform.MyValues and org.astarte-platform.Myvalues ). This also applies to Major versioning: interfaces sharing the same name with a different major version cannot have different casing. Although not enforced, naming conventions for Astarte Interfaces require lowercasing for anything but the last part of the Interface name, which should be CamelCase. Valid examples are: org.astarte-platform.conventions.ValidInterfaceName org.astarte-platform.ValidInterfaceName org.astarte-platform.conventions.satisfied.ValidInterfaceName Non-valid examples are: org.astarte-platform.Conventions.ValidInterfaceName org.astarte-platform.validInterfaceName org.astarte-platform.Conventions.satisfied.ValidInterfaceName","ref":"030-interface.html#format","title":"Interfaces - Format","type":"extras"},{"doc":"Interfaces have a well-known, predefined type, which can be either property or datastream . Every Device in Astarte can have any number of interfaces of any different types. Datastream datastream represents a mutable, ordered stream of data, with no concept of persistent state or synchronization. As a rule of thumb, datastream interfaces should be used when dealing with values such as sensor samples, commands and events. datastream are stored as time series in the database, making them suitable for time span filtering and any other common time series operation, and they are not idempotent in the REST API semantics. Due to their nature, datastream interfaces have a number of additional properties which fine tune their behavior. Properties properties represent a persistent, stateful, synchronized state with no concept of history or timestamping. properties are useful, for example, when dealing with settings, states or policies/rules. properties are stored in a key-value fashion, and grouped according to their interface, and they are idempotent in the REST API semantics. Rather than being able to act on a stream like in the datastream case, properties can be retrieved, or can be used as a trigger whenever they change. Values in a properties interface can be unset (or deleted according to the http jargon): to allow such a thing, the interface must have its allow_unset property set to true . Please refer to the JSON Schema for further details.","ref":"030-interface.html#interface-type","title":"Interfaces - Interface Type","type":"extras"},{"doc":"Astarte's design mandates that each interface has an owner. The owner of an interface has a write-only access to it, whereas other actors have read-only access. Interface ownership can be either device or server : the owner is the actor producing the data, whereas the other actor consumes data.","ref":"030-interface.html#ownership","title":"Interfaces - Ownership","type":"extras"},{"doc":"Every interface must have an array of mappings. Mappings are designed around REST controller semantics: each mapping describes an endpoint which is resolved to a path, it is strongly typed, and can have additional options. Just like in REST controllers, Endpoints can be parametrized to build REST-like collection and trees. Parameters are identified by %{parameterName} , with each endpoint supporting any number of parameters (see Limitations ). This is how a parametrized mapping looks like: [...] &quot;mappings&quot;: [ { &quot;endpoint&quot;: &quot;/%{itemIndex}/value&quot;, &quot;type&quot;: &quot;integer&quot;, &quot;reliability&quot;: &quot;unique&quot;, &quot;retention&quot;: &quot;discard&quot; }, [...] In this example, /0/value , /1/value or /test/value all map to a valid endpoint, while /te/st/value can't be resolved by any endpoint. Supported data types The following types are supported: double : A double-precision floating-point number as specified by binary64, by the IEEE 754 standard (NaNs and other non numerical values are not supported). integer : A signed 32 bit integer. boolean : Either true or false , adhering to JSON boolean type. longinteger : A signed 64 bit integer (please note that longinteger is represented as a string by default in JSON-based APIs.). string : An UTF-8 string, at most 65536 bytes long. binaryblob : An arbitrary sequence of any byte that should be shorter than 64 KiB. ( binaryblob is represented as a base64 string by default in JSON-based APIs.). datetime : A UTC timestamp, internally represented as milliseconds since 1st Jan 1970 using a signed 64 bits integer. ( datetime is represented as an ISO 8601 string by default in JSON based APIs.) doublearray , integerarray , booleanarray , longintegerarray , stringarray , binaryblobarray , datetimearray : A list of values, represented as a JSON Array. Arrays can have up to 1024 items and each item must respect the limits of its scalar type ( i.e. each string in a stringarray must be at most 65535 bytes long, each binary blob in a binaryblobarray must be shorter than 64 KiB. Make sure that the differences between two distinct interface names are not limited to the casing or the presence of hyphens. This situation leads to a collision in the interface names which brings to an error in the interface installation process. A valid interface must resolve a path univocally to a single endpoint. Take the following example: [...] &quot;mappings&quot;: [ { &quot;endpoint&quot;: &quot;/%{itemIndex}/value&quot;, &quot;type&quot;: &quot;integer&quot; }, { &quot;endpoint&quot;: &quot;/myPath/value&quot;, &quot;type&quot;: &quot;integer&quot; }, [...] In such a case, the interface isn't valid and is rejected, due to the fact that path /myPath/value is ambiguous and could be resolved to two different endpoints. Any endpoint configuration must not generate paths that are prefix of other paths, for this reason the following example is also invalid: [...] &quot;mappings&quot;: [ { &quot;endpoint&quot;: &quot;/some/thing&quot;, &quot;type&quot;:&quot;integer&quot; }, { &quot;endpoint&quot;: &quot;/some/%{param}/value&quot;, &quot;type&quot;: &quot;integer&quot; }, [...] In case the interface's aggregation is object , additional restrictions apply. Endpoints in the same interface must all have the same depth, and the same number of parameters. If the interface is parametrized, every endpoint must have the same parameter name at the same level. This is an example of a valid aggregated interface mapping: [...] &quot;mappings&quot;: [ { &quot;endpoint&quot;: &quot;/%{itemIndex}/value&quot;, &quot;type&quot;: &quot;integer&quot; }, { &quot;endpoint&quot;: &quot;/%{itemIndex}/otherValue&quot;, &quot;type&quot;: &quot;string&quot; }, [...]","ref":"030-interface.html#mappings","title":"Interfaces - Mappings","type":"extras"},{"doc":"In a real world scenario, such as an array of sensors, there are usually two main cases. A sensor might have one or more independent values which are sampled individually and sent whenever they become available independently. Or a sensor might sample at the same time a number of values, which might as well have some form of correlation. In Astarte, this concept is mapped to interface aggregation . In case aggregation is individual , each mapping is treated as an independent value and is managed individually. In case aggregation is object , Astarte expects the owner to send all of the interface's mappings at the same time, packed in a single message. In this case, all of the mappings share some core properties such as the timestamp. Aggregation is a powerful mechanism that can be used to map interfaces to real world &quot;objects&quot; . Moreover, aggregated interfaces can also be parametrized, although with some limitations . Endpoints and aggregation Since Astarte 0.11, Aggregations cannot have endpoints with depth 1. This was an erroneously allowed behavior in Astarte 0.10 which is kept for retrocompatibility - however, new interfaces should ensure each endpoint in an aggreate has at least depth 2, as support for depth 1 will be removed in a future release. This change has been done to be consistent with AppEngine API design, and to ensure that path / is not ambiguous. This is the correct way to set up a valid endpoint structure for an aggregate: [...] &quot;mappings&quot;: [ { &quot;endpoint&quot;: &quot;/objects/value&quot;, &quot;type&quot;: &quot;integer&quot; }, { &quot;endpoint&quot;: &quot;/objects/otherValue&quot;, &quot;type&quot;: &quot;string&quot; }, [...] The following structure, instead, is deprecated: [...] &quot;mappings&quot;: [ { &quot;endpoint&quot;: &quot;/value&quot;, &quot;type&quot;: &quot;integer&quot; }, { &quot;endpoint&quot;: &quot;/otherValue&quot;, &quot;type&quot;: &quot;string&quot; }, [...]","ref":"030-interface.html#aggregation","title":"Interfaces - Aggregation","type":"extras"},{"doc":"datastream interfaces are highly tunable, depending on the kind of data they are representing: it is possible to fine tune several aspects of how data is stored, transferred and indexed. The following properties can be set at mapping level. NOTE: In case the interface is aggregated, additional properties must be the same for each mapping. explicit_timestamp : By default, Astarte associates a timestamp to data whenever it is collected (or - when the message hits the data collection stage). However, when setting this property to true , Astarte expects the owner to attach a valid timestamp each time it produces data. In that case, the provided timestamp is used for indexing. reliability : Each mapping can be unreliable (default), guaranteed , unique . This defines whether data should be considered delivered when the transport successfully sends the data regardless of the outcome ( unreliable ), when data has been received at least once by the recipient ( guaranteed ) or when data has been received exactly once by the recipient ( unique ). When using reliable data, consider you might incur in additional resource usage on both the transport and the device's end. retention : Each mapping can have a discard (default), volatile , stored retention. This defines whether data should be discarded if the transport is temporarily uncapable of delivering it ( discard ), should be kept in a cache in memory ( volatile ) or on disk ( stored ), and guaranteed to be delivered in the timeframe defined by the expiry . expiry : Meaningful only when retention is stored . Defines how many seconds a specific data entry should be kept before giving up and erasing it from the persistent cache. A value &lt;= 0 means the persistent cache never expires, and is the default. database_retention_policy : Useful only with datastream. Defines whether data should expire from the database after a given interval. Valid values are: no_ttl and use_ttl. database_retention_ttl : Useful when database_retention_policy is &quot;use_ttl&quot; . Defines how many seconds a specific data entry should be kept before erasing it from the database.","ref":"030-interface.html#datastream-specific-features","title":"Interfaces - Datastream-specific features","type":"extras"},{"doc":"When creating interface drafts, or for testing purposes in general, it is recommended to use 0 as the major version, to make maintenance and testing easier. Currently, Astarte allows only interfaces with major_version == 0 to be deleted, and this limitation will probably be never lifted to prevent data loss. When sending real time commands in datastream interfaces, discard is usually the best option. Even though it does not guarantee delivery, it prevents users from unwillingly sending the same command over and over if the recipient isn't available, causing a queue of commands to be sent to the recipient when it gets back online. In general, retention should be used to keep track of low traffic/important events","ref":"030-interface.html#best-practices","title":"Interfaces - Best practices","type":"extras"},{"doc":"Interface Schema The schema contains the following objects: Interface (root object) Mapping","ref":"040-interface_schema.html","title":"Interface Schema","type":"extras"},{"doc":"This schema describes how an Astarte interface should be declared Properties Type Description Required interface_name string The name of the interface. This has to be an unique, alphanumeric reverse internet domain name, shorther than 128 characters. &amp;#x2714; Yes version_major integer A Major version qualifier for this interface. Interfaces with the same id and different version_major number are deemed incompatible. It is then acceptable to redefine any property of the interface when changing the major version number. &amp;#x2714; Yes version_minor integer A Minor version qualifier for this interface. Interfaces with the same id and major version number and different version_minor number are deemed compatible between each other. When changing the minor number, it is then only possible to insert further mappings. Any other modification might lead to incompatibilities and undefined behavior. &amp;#x2714; Yes type string Identifies the type of this Interface. Currently two types are supported: datastream and properties. datastream should be used when dealing with streams of non-persistent data, where a single path receives updates and there's no concept of state. properties, instead, are meant to be an actual state and as such they have only a change history, and are retained. &amp;#x2714; Yes ownership string Identifies the quality of the interface. Interfaces are meant to be unidirectional, and this property defines who's sending or receiving data. device means the device/gateway is sending data to Astarte, consumer means the device/gateway is receiving data from Astarte. Bidirectional mode is not supported, you should instantiate another interface for that. &amp;#x2714; Yes aggregation string Identifies the aggregation of the mappings of the interface. Individual means every mapping changes state or streams data independently, whereas an object aggregation treats the interface as an object, making all the mappings changes interdependent. Choosing the right aggregation might drastically improve performances. No, default: &quot;individual&quot; explicit_timestamp boolean Allow to set a custom timestamp, otherwise a timestamp is added when the message is received. If true explicit timestamp will also be used for sorting. This feature is only supported on datastreams. No, default: false description string An optional description of the interface. No doc string A string containing documentation that will be injected in the generated client code. No mappings Astarte Mapping Schema [1-1024] Mappings define the endpoint of the interface, where actual data is stored/streamed. They are defined as relative URLs (e.g. /my/path) and can be parametrized (e.g.: /%{myparam}/path). A valid interface must have no mappings clash, which means that every mapping must resolve to a unique path or collection of paths (including parametrization). Every mapping acquires type, quality and aggregation of the interface. &amp;#x2714; Yes Additional properties are allowed. astarte.interface.schema.interface_name &amp;#x2714; The name of the interface. This has to be an unique, alphanumeric reverse internet domain name, shorther than 128 characters. Type : string Required : Yes Minimum Length : &gt;= 1 astarte.interface.schema.version_major &amp;#x2714; A Major version qualifier for this interface. Interfaces with the same id and different version_major number are deemed incompatible. It is then acceptable to redefine any property of the interface when changing the major version number. Type : integer Required : Yes astarte.interface.schema.version_minor &amp;#x2714; A Minor version qualifier for this interface. Interfaces with the same id and major version number and different version_minor number are deemed compatible between each other. When changing the minor number, it is then only possible to insert further mappings. Any other modification might lead to incompatibilities and undefined behavior. Type : integer Required : Yes astarte.interface.schema.type &amp;#x2714; Identifies the type of this Interface. Currently two types are supported: datastream and properties. datastream should be used when dealing with streams of non-persistent data, where a single path receives updates and there's no concept of state. properties, instead, are meant to be an actual state and as such they have only a change history, and are retained. Type : string Required : Yes Allowed values : &quot;datastream&quot; &quot;properties&quot; astarte.interface.schema.ownership &amp;#x2714; Identifies the quality of the interface. Interfaces are meant to be unidirectional, and this property defines who's sending or receiving data. device means the device/gateway is sending data to Astarte, consumer means the device/gateway is receiving data from Astarte. Bidirectional mode is not supported, you should instantiate another interface for that. Type : string Required : Yes Allowed values : &quot;device&quot; &quot;server&quot; astarte.interface.schema.aggregation Identifies the aggregation of the mappings of the interface. Individual means every mapping changes state or streams data independently, whereas an object aggregation treats the interface as an object, making all the mappings changes interdependent. Choosing the right aggregation might drastically improve performances. Type : string Required : No, default: &quot;individual&quot; Allowed values : &quot;individual&quot; &quot;object&quot; astarte.interface.schema.explicit_timestamp Allow to set a custom timestamp, otherwise a timestamp is added when the message is received. If true explicit timestamp will also be used for sorting. This feature is only supported on datastreams. Type : boolean Required : No, default: false astarte.interface.schema.description An optional description of the interface. Type : string Required : No astarte.interface.schema.doc A string containing documentation that will be injected in the generated client code. Type : string Required : No astarte.interface.schema.mappings &amp;#x2714; Mappings define the endpoint of the interface, where actual data is stored/streamed. They are defined as relative URLs (e.g. /my/path) and can be parametrized (e.g.: /%{myparam}/path). A valid interface must have no mappings clash, which means that every mapping must resolve to a unique path or collection of paths (including parametrization). Every mapping acquires type, quality and aggregation of the interface. Type : Astarte Mapping Schema [1-1024] Each element in the array must be unique. Required : Yes","ref":"040-interface_schema.html#interface","title":"Interface Schema - Interface","type":"extras"},{"doc":"Identifies a mapping for an interface. A mapping must consist at least of an endpoint and a type. Properties Type Description Required endpoint string The template of the path. This is a UNIX-like path (e.g. /my/path) and can be parametrized. Parameters are in the %{name} form, and can be used to create interfaces which represent dictionaries of mappings. When the interface aggregation is object, an object is composed by all the mappings for one specific parameter combination. &amp;#x2714; Yes type string Defines the type of the mapping. &amp;#x2714; Yes reliability string Useful only with datastream. Defines whether the sent data should be considered delivered when the transport successfully sends the data (unreliable), when we know that the data has been received at least once (guaranteed) or when we know that the data has been received exactly once (unique). unreliable by default. When using reliable data, consider you might incur in additional resource usage on both the transport and the device's end. No, default: &quot;unreliable&quot; retention string Useful only with datastream. Defines whether the sent data should be discarded if the transport is temporarily uncapable of delivering it (discard) or should be kept in a cache in memory (volatile) or on disk (stored), and guaranteed to be delivered in the timeframe defined by the expiry. discard by default. No, default: &quot;discard&quot; expiry integer Useful when retention is stored. Defines after how many seconds a specific data entry should be kept before giving up and erasing it from the persistent cache. A value &lt;= 0 means the persistent cache never expires, and is the default. No, default: 0 database_retention_policy string Useful only with datastream. Defines whether data should expire from the database after a given interval. Valid values are: no_ttl and use_ttl. No, default: &quot;no_ttl&quot; database_retention_ttl integer Useful when database_retention_policy is &quot;use_ttl&quot; . Defines how many seconds a specific data entry should be kept before erasing it from the database. No allow_unset boolean Used only with properties. Used with producers, it generates a method to unset the property. Used with consumers, it generates code to call an unset method when an empty payload is received. No, default: false description string An optional description of the mapping. No doc string A string containing documentation that will be injected in the generated client code. No Additional properties are allowed. astarte.mapping.schema.endpoint &amp;#x2714; The template of the path. This is a UNIX-like path (e.g. /my/path) and can be parametrized. Parameters are in the %{name} form, and can be used to create interfaces which represent dictionaries of mappings. When the interface aggregation is object, an object is composed by all the mappings for one specific parameter combination. Type : string Required : Yes Minimum Length : &gt;= 2 astarte.mapping.schema.type &amp;#x2714; Defines the type of the mapping. Type : string Required : Yes Allowed values : &quot;double&quot; &quot;integer&quot; &quot;boolean&quot; &quot;longinteger&quot; &quot;string&quot; &quot;binaryblob&quot; &quot;datetime&quot; &quot;doublearray&quot; &quot;integerarray&quot; &quot;booleanarray&quot; &quot;longintegerarray&quot; &quot;stringarray&quot; &quot;binaryblobarray&quot; &quot;datetimearray&quot; astarte.mapping.schema.reliability Useful only with datastream. Defines whether the sent data should be considered delivered when the transport successfully sends the data (unreliable), when we know that the data has been received at least once (guaranteed) or when we know that the data has been received exactly once (unique). unreliable by default. When using reliable data, consider you might incur in additional resource usage on both the transport and the device's end. Type : string Required : No, default: &quot;unreliable&quot; Allowed values : &quot;unreliable&quot; &quot;guaranteed&quot; &quot;unique&quot; astarte.mapping.schema.retention Useful only with datastream. Defines whether the sent data should be discarded if the transport is temporarily uncapable of delivering it (discard) or should be kept in a cache in memory (volatile) or on disk (stored), and guaranteed to be delivered in the timeframe defined by the expiry. discard by default. Type : string Required : No, default: &quot;discard&quot; Allowed values : &quot;discard&quot; &quot;volatile&quot; &quot;stored&quot; astarte.mapping.schema.expiry Useful when retention is stored. Defines after how many seconds a specific data entry should be kept before giving up and erasing it from the persistent cache. A value &lt;= 0 means the persistent cache never expires, and is the default. Type : integer Required : No, default: 0 astarte.mapping.schema.database_retention_policy Useful only with datastream. Defines whether data is expired from the database after a given time to live interval. When &quot;no_ttl&quot; is used data are not expired. Type : string Required : No astarte.mapping.schema.database_retention_ttl Useful when database_retention_policy is &quot;use_ttl&quot; . Defines how many seconds a specific data entry should be kept before erasing it from the database. Type : integer Required : No astarte.mapping.schema.allow_unset Used only with properties. Used with producers, it generates a method to unset the property. Used with consumers, it generates code to call an unset method when an empty payload is received. Type : boolean Required : No, default: false astarte.mapping.schema.description An optional description of the mapping. Type : string Required : No astarte.mapping.schema.doc A string containing documentation that will be injected in the generated client code. Type : string Required : No","ref":"040-interface_schema.html#mapping","title":"Interface Schema - Mapping","type":"extras"},{"doc":"Pairing Mechanism Astarte's Pairing is a unified mechanism for Registering Devices and obtaining Transport Credentials . Even though in Astarte each Transport is free to choose its own Authentication mechanisms and Credentials autonomously, Pairing defines a well-known mechanism for Registering Devices and for orchestrating the exchange of Transport Credentials . Pairing is the main endpoint which orchestrates Device Authentication in Astarte, abstracting all details.","ref":"050-pairing_mechanism.html","title":"Pairing Mechanism","type":"extras"},{"doc":"","ref":"050-pairing_mechanism.html#authentication-flow","title":"Pairing Mechanism - Authentication flow","type":"extras"},{"doc":"Each device is identified by a Device ID and, on top of that, it has two different credentials directly associated to its ID: Credentials Secret and Transport Credentials . Credentials Secret is a shared secret between Astarte and a Device, which are used only to authenticate against Pairing API. Each device has a single Credentials Secret which remains valid throughout its whole lifecycle, and cannot be changed (unless operating manually). Transport Credentials are Transport-specific credentials usually orchestrated by Pairing. Pairing emits these Credentials through a policy which is usually imposed by the Authority emitting the Credentials or by Pairing itself. They are designed to be transient, revokable and reasonably short-lived - however, the actual behavior and their lifecycle is entirely orchestrated by the Authority emitting them. The emission of Transport Credentials can be inhibited for a specific Device, you can read how to do that in the User Guide Transports, by design, have no knowledge nor access to Credentials Secret , but have full authority over the authentication mechanism for devices. In fact, each Transport is free to choose the authentication mechanism which fits it best. Credentials Secret storage recommendations As losing or disclosing a Credentials Secret might mean a device is compromised or requires manual intervention to be fixed and secured, storing it appropriately is critical. Usually, when it comes to embedded devices, it is advised to store the Credentials Secret into an OTP, if available. Otherwise, storing it into the bootloader's variables is a viable and safe alternative. Other options might be having a separate, isolated storage containing Credentials Secret . In general, Astarte SDK does not provide a streamlined mechanism for retrieving Credentials Secret as the storage detail is strongly dependent on the target hardware - device developers should implement the safest strategy which better complies with their policies. Tuning devices for security is out of the scope of this guide, however it is advised to make sure only Astarte SDK has access to Credentials Secret .","ref":"050-pairing_mechanism.html#credentials-secret-vs-transport-credentials","title":"Pairing Mechanism - Credentials Secret vs. Transport Credentials","type":"extras"},{"doc":"Whenever possible, Transports are advised to implement their Authentication through the use of SSL certificates and a certificate authority by using Mutual Authentication , to ensure identities of the endpoint and the client are well-known to each other - this is especially the case with Astarte's MQTT Protocol on top of VerneMQ Transport. In this case, Transport Credentials are a SSL Certificate, and Pairing will interact with a Certificate Authority. The certificate rotates depending on the emission policy of the CA and can be renewed and invalidated countless times over the device lifecycle. The Certificate is a transient, asymmetric, device-specific, non-critical Transport Credential which can be in turn used to authenticate against the chosen Transport. In this case, Transports should have no knowledge nor access to secrets or Authorization details: they rather have to comply with the configured CA and the certificate parsing, as the Certificate contains all needed information for Authorization as well. Mutual SSL Authentication Flow Side note: the Transport usually bears the public certificate of the CA, and actually interacts with the CA itself only if it exposes an OCSP endpoint and the Transport is capable of understanding it. In case the CA exposes a CRL, the Transport just makes sure to update its CRL from the CA every once in a while. In both cases, Transport's only interaction with the CA is the configuration of its SSL endpoint. Certificate Authority Pairing is designed to interact with an abstract certificate authority, given this authority is capable of: Emitting SSL Certificates with a custom CN (this is important in the Transport authentication flow) Revoking emitted certificates and exposing CRL/OCSP revocation information and is accessible from a 3rd party (e.g. from a REST API). By default, Astarte supports Cloudflare's CFSSL , and also provides a minimal installation in its default deploy scripts. For bigger installations, especially in terms of number of connected devices, it is strongly advised to use a dedicated CFSSL installation. Also, Astarte Enterprise provides a number of additional features including support for other external CAs. Certificate flow During the Pairing flow, the device must generate autonomously a Certificate Signing Request (CSR) which will be in turn relayed by Pairing to the configured Certificate Authority. Pairing will also provide the Certificate Authority with a custom CN, which maps to &lt;realm&gt;/&lt;device id&gt; . The CA must ensure the signed certificate carries this information, as it will be used by the Transport to authenticate the caller inside Astarte. Pairing, in fact, will also perform sanity checks over the signed certificate and reject it in case the CA fails to comply.","ref":"050-pairing_mechanism.html#using-ssl-certificates-as-transport-credentials","title":"Pairing Mechanism - Using SSL Certificates as Transport Credentials","type":"extras"},{"doc":"Agents are realm-level entities capable of registering a device into Astarte. Agents are a core concept in the Pairing mechanism, as no Device can request its Transport Credentials nor be authenticated against any Transport unless an Agent previously gave its consent and delivered its Credentials Secret . The recommended configuration includes an authenticated Agent in a trusted physical environment (e.g.: the distribution facility of the device) which guarantees an isolated and safe routine for generating Credentials Secret . However, such a setup might not always be possible, and Astarte's SDK has an On Board Agent concept to allow a simpler registration procedure. On Board Agent In the On Board Agent use case, the device is preloaded with an Agent Key , a shared secret which is not tied to a specific Device in the realm . In fact, this secret is usually the same for all Devices in the same realm. This secret will be used only once, upon the device's first interaction with Astarte (Registration), and can be safely discarded afterwards. This approach largely simplifies the deploy procedure, but leaves every device with a secret which, if retrieved, can allow an entity to register an arbitrary Device in the realm. If following the On Board Agent approach, it is advised to store the Agent Key in a safe area inside the device and delete it after retrieving a Credentials Secret (some OTPs allow this configuration).","ref":"050-pairing_mechanism.html#agents","title":"Pairing Mechanism - Agents","type":"extras"},{"doc":"Once a device obtains its Transport Credentials , it is then capable of connecting to the Transport the credentials were forged for. Transports have full responsibility in terms of authenticating the client, reporting and relaying its connection state to Astarte via its internal AMQP API. As such, it is fundamental that 3rd parties implementing new Transports not only adhere to protocol specifications, but also make sure to implement the authentication procedure meticolously, as a vulnerable Transport acts as a single point of failure of the whole system, and is capable of bypassing the Pairing workflow entirely. For this very reason, we encourage users to be extremely cautious when using 3rd party Transports which have not been verified and hardly tested, especially when it comes to the Client Authentication stage. Even though there are valid use cases where Mutual Authentication is not usable, Transports are advised to stick to Mutual SSL Authentication where possible. This, among other benefits, allows to use Pairing's core features for handling SSL Certificates.","ref":"050-pairing_mechanism.html#transport-responsibility","title":"Pairing Mechanism - Transport responsibility","type":"extras"},{"doc":"Pairing's Device API exposes two additional facilities: first and foremost an endpoint which bears a set of information about both Pairing itself and Transports the device should use or choose from. This endpoint is Device and Realm specific and can be found at /{realm_name}/devices/{hw_id} . This allows granting each Device a specific Transport configuration, which can be useful in installations with more than a single Transport, and automates the configuration on the Device's end, which knows in advance what is supported and how to access its Transport(s). Moreover, each Transport implementation has a /verify endpoint where a client, authenticating with its Credentials Secret , can verify whether its Transport Credentials are valid or not. This, in case SSL is used, is especially useful for checking against revocation lists.","ref":"050-pairing_mechanism.html#pairing-facilities","title":"Pairing Mechanism - Pairing facilities","type":"extras"},{"doc":"Triggers Triggers in Astarte are the go-to mechanism for generating push events. In contrast with AppEngine's REST APIs, Triggers allow users to specify conditions upon which a custom payload is delivered to a recipient, using a specific action , which usually maps to a specific transport/protocol, such as HTTP. Given this kind of flexibility, triggers are the most powerful way to push data to an external service, potentially without any additional customization. Triggers can be managed from Realm Management API , astartectl with the astartectl realm-management triggers subcommand, or Astarte Dashboard in the Triggers page.","ref":"060-triggers.html","title":"Triggers","type":"extras"},{"doc":"Triggers can be either built manually or using Astarte Dashboard's Trigger Editor. Trigger Editor dynamically loads installed Interfaces in the Realm and eases trigger creation by providing not only linting and validation, but also dynamic resolution of Interface names. Trigger Editor works in a very similar fashion to Interfaces Editor, and shares the same User Interface. Format A trigger is described using a JSON document. Each trigger is defined by two main parts: condition and action . This is a JSON representation of an example trigger: { &quot;name&quot;: &quot;example_trigger&quot;, &quot;action&quot;: { &quot;http_post_url&quot;: &quot;https://example.com/my_hook&quot; }, &quot;simple_triggers&quot;: [ { &quot;type&quot;: &quot;data_trigger&quot;, &quot;on&quot;: &quot;incoming_data&quot;, &quot;interface_name&quot;: &quot;org.astarte-platform.genericsensors.Values&quot;, &quot;interface_major&quot;: 0, &quot;match_path&quot;: &quot;/streamTest/value&quot;, &quot;value_match_operator&quot;: &quot;&gt;&quot;, &quot;known_value&quot;: 0.4 } ] } The condition is represented by the simple_triggers array. In this release, Astarte supports only a single entry in the simple_triggers array, but support for multiple simple triggers (and different ways to combine them) is planned for future releases. The condition in the example specifies that when data is received on the org.astarte-platform.genericsensors.Values interface on /streamTest/value path, if the value of said data is &gt; 0.4 , then the trigger is activated. For more information about all the possible conditions, check out the Conditions section The action object describes what the result of the trigger will be. In this specific case, an HTTP POST request will be sent to https://example.com/my_hook , with the payload: { &quot;timestamp&quot;: &quot;&lt;event_timestamp&gt;&quot;, &quot;device_id&quot;: &quot;&lt;device_id&gt;&quot;, &quot;event&quot;: { &quot;type&quot;: &quot;incoming_data&quot;, &quot;interface&quot;: &quot;org.astarte-platform.genericsensors.Values&quot;, &quot;path&quot;: &quot;/streamTest/value&quot;, &quot;value&quot;: &lt;some_value&gt; } } To know more about all possible actions, check the Actions section","ref":"060-triggers.html#building-triggers","title":"Triggers - Building Triggers","type":"extras"},{"doc":"A condition defines the event upon which an action is triggered. Conditions are expressed through simple triggers. Astarte monitors incoming events and triggers a corresponding action whenever there is a match. Simple triggers are divided into two types: Device Triggers and Data Triggers . Device Triggers Device triggers express conditions matching the state of a device. This is the generic representation of a Data Trigger: { &quot;type&quot;: &quot;device_trigger&quot;, &quot;on&quot;: &quot;&lt;device_trigger_type&gt;&quot;, &quot;device_id&quot;: &quot;&lt;device_id&gt;&quot; } Parameters device_trigger_type can be one of the following: device_connected : triggered when a device connects to its transport. device_disconnected : triggered when a device disconnects from its transport. device_id can be a specific Device ID or * , meaning the trigger will be installed for all devices in a Realm. Data Triggers Data triggers express conditions matching data coming from a device. This is the generic representation of a Device Trigger: { &quot;type&quot;: &quot;data_trigger&quot;, &quot;on&quot;: &quot;&lt;data_trigger_type&gt;&quot;, &quot;interface_name&quot;: &quot;&lt;interface_name&gt;&quot;, &quot;interface_major&quot;: &quot;&lt;interface_major&gt;&quot;, &quot;match_path&quot;: &quot;&lt;match_path&gt;&quot;, &quot;value_match_operator&quot;: &quot;&lt;value_match_operator&gt;&quot;, &quot;known_value&quot;: &lt;known_value&gt; } Data triggers are installed for all devices in a Realm. Data Triggers Parameters data_trigger_type can be one of the following: incoming_data : verifies the condition whenever new data arrives. value_stored : verifies the condition whenever new data arrives, after it is saved to the database. value_change : works only with properties interface; verifies the condition whenever the received value is different from the previous one. value_change_applied : works only with properties interface; verifies the condition whenever the last value received is different from the last one previously received, after it is saved to the database. path_created : verifies the condition whenever a new path in a property interface is set or the first value is streamed on a datastream interface. path_removed : works only with properties interface; verifies the condition whenever a property path is unset. interface_name and interface_major represent, respectively, the Interface name and major version that uniquely identify an Astarte Interface. interface_name can be * to match all interfaces; in that case interface_major is ignored and all major numbers are matched. match_path is the path that will be used to match the condition. It can be /* to match all the paths of an interface. value_match_operator is the operator used to match the incoming data against a known value. It can be * to indicate that all values should be matched ( known_value is ignored in that case), otherwise it can be one of these operators: == , != , &gt; , &gt;= , &lt; , &lt;= , contains , not_contains . The match is always performed with &lt;incoming_value&gt; &lt;operator&gt; &lt;known_value&gt; . contains and not_contains can be used only with type string , binaryblob and with array types. known_value is the value used with value_match_operator to perform the comparison on the incoming value. It must have the same type as the incoming value, except in the contains and not_contains case.","ref":"060-triggers.html#conditions","title":"Triggers - Conditions","type":"extras"},{"doc":"Actions are triggered by a matching condition. An Action defines how the event should be sent to the outer world (e.g. an http POST on a certain URL). In addition, most actions have a Payload, which carries the body of the event. Payloads are most of the time represented as text, and Astarte provides several ways to generate them. By default Astarte generates a JSON payload with all the relevant information of the event. This is also the format used when delivering payloads in Astarte Channels. The format of the payload can be found in the Default action section. Astarte also provides a powerful templating mechanism for plain-text payloads based on top of Mustache . This is especially useful for integrating with third-party actors which require custom plain-text payloads. Keep in mind that Mustache templates are only able to produce text/plain payloads, not valid JSON. Default action This is the configuration object representing the default action: { &quot;http_post_url&quot;: &quot;&lt;http_post_url&gt;&quot;, &quot;ignore_ssl_errors&quot;: &lt;true|false&gt; } The default action sends an HTTP POST request to the specified http_post_url . The ignore_ssl_errors key is optional and defaults to false . If set to true , any SSL error encountered while doing the HTTP request will be ignored. This can be useful if the trigger must ignore self-signed or expired certificates. The payload of the request is JSON document with this format: { &quot;timestamp&quot;: &quot;&lt;timestamp&gt;&quot;, &quot;device_id&quot;: &quot;&lt;device_id&gt;&quot;, &quot;event&quot;: &lt;event&gt; } timestamp is an UTC ISO 8601 timestamp (e.g. &quot;2019-10-16T08:56:08.534377Z&quot; ) representing when the event happened. device_id identifies the device that triggered the event. event is a JSON object that has a specific structure depending on the type of the simple_trigger that generated it. Event objects are detailed below. Additionally, the realm that originated the trigger is available in the request in the Astarte-Realm header. Event objects DeviceConnectedEvent { &quot;type&quot;: &quot;device_connected&quot;, &quot;device_ip_address&quot;: &quot;&lt;device_ip_address&gt;&quot; } device_ip_address is the IP address of the device. DeviceDisconnectedEvent { &quot;type&quot;: &quot;device_disconnected&quot; } IncomingDataEvent { &quot;type&quot;: &quot;incoming_data&quot;, &quot;interface&quot;: &quot;&lt;interface&gt;&quot;, &quot;path&quot;: &quot;&lt;path&gt;&quot;, &quot;value&quot;: &lt;value&gt; } interface is the interface on which data was received. path is the path on which data was received. value is the received value. Its type depends on the type of the mapping it's coming from. binaryblob and binaryblobarray type values are encoded with Base64. ValueStoredEvent { &quot;type&quot;: &quot;value_stored&quot;, &quot;interface&quot;: &quot;&lt;interface&gt;&quot;, &quot;path&quot;: &quot;&lt;path&gt;&quot;, &quot;value&quot;: &lt;value&gt; } interface is the interface on which data was received. path is the path on which data was received. value is the received value. Its type depends on the type of the mapping it's coming from. binaryblob and binaryblobarray type values are encoded with Base64. ValueChangeEvent { &quot;type&quot;: &quot;value_change&quot;, &quot;interface&quot;: &quot;&lt;interface&gt;&quot;, &quot;path&quot;: &quot;&lt;path&gt;&quot;, &quot;old_value&quot;: &lt;old_value&gt;, &quot;new_value&quot;: &lt;new_value&gt; } interface is the interface on which data was received. path is the path on which data was received. old_value is the previous value. Its type depends on the type of the mapping it's coming from. binaryblob and binaryblobarray type values are encoded with Base64. new_value is the received value. Its type depends on the type of the mapping it's coming from. binaryblob and binaryblobarray type values are encoded with Base64. ValueChangeAppliedEvent { &quot;type&quot;: &quot;value_change_applied&quot;, &quot;interface&quot;: &quot;&lt;interface&gt;&quot;, &quot;path&quot;: &quot;&lt;path&gt;&quot;, &quot;old_value&quot;: &lt;old_value&gt;, &quot;new_value&quot;: &lt;new_value&gt; } interface is the interface on which data was received. path is the path on which data was received. old_value is the previous value. Its type depends on the type of the mapping it's coming from. binaryblob and binaryblobarray type values are encoded with Base64. new_value is the received value. Its type depends on the type of the mapping it's coming from. binaryblob and binaryblobarray type values are encoded with Base64. PathCreatedEvent { &quot;type&quot;: &quot;path_created&quot;, &quot;interface&quot;: &quot;&lt;interface&gt;&quot;, &quot;path&quot;: &quot;&lt;path&gt;&quot;, &quot;value&quot;: &lt;value&gt; } interface is the interface on which data was received. path is the path that has been created. value is the received value. Its type depends on the type of the mapping it's coming from. binaryblob and binaryblobarray type values are encoded with Base64. PathRemovedEvent { &quot;type&quot;: &quot;path_removed&quot;, &quot;interface&quot;: &quot;&lt;interface&gt;&quot;, &quot;path&quot;: &quot;&lt;path&gt;&quot; } interface is the interface on which data was received. path is the path that has been removed. Mustache action This is the configuration object representing a Mustache action: { &quot;http_post_url&quot;: &quot;&lt;http_post_url&gt;&quot;, &quot;template_type&quot;: &quot;mustache&quot;, &quot;template&quot;: &quot;&lt;template&gt;&quot; &quot;ignore_ssl_errors&quot;: &lt;true|false&gt; } The Mustache action sends an HTTP POST request to the specified http_post_url , with the payload built with the Mustache template specified in template . If the template contains a key inside a double curly bracket (like so: {{ key }} ), it will be substituted with the actual value of that key in the event. The basic keys that can be use to populate the template are: {{ realm }} : the realm the trigger belongs to. {{ device_id }} : the device that originated the trigger. {{ event_type }} : the type of the received event. The ignore_ssl_errors key is optional and defaults to false . If set to true , any SSL error encountered while doing the HTTP request will be ignored. This can be useful if the trigger must ignore self-signed or expired certificates. Moreover, depending on the event type, all keys that are contained in the events described in the previous section are available, always by wrapping them in {{ }} . The realm is also sent in the Astarte-Realm header. Example This is an example of a trigger that uses Mustache action. { &quot;name&quot;: &quot;example_mustache_trigger&quot;, &quot;action&quot;: { &quot;template_type&quot;: &quot;mustache&quot;, &quot;template&quot;: &quot;Device {{ device_id }} just connected from IP {{ device_ip_address }}&quot;, &quot;http_post_url&quot;: &quot;https://example.com/my_mustache_hook&quot; }, &quot;simple_triggers&quot;: [ { &quot;type&quot;: &quot;device_trigger&quot;, &quot;on&quot;: &quot;device_connected&quot;, &quot;device_id&quot;: &quot;*&quot; } ] } When a device is connected, the following request will be received by https://example.com/my_mustache_hook : POST /my_mustache_hook HTTP/1.1 Astarte-Realm: test Content-Length: 63 Content-Type: text/plain Host: example.com User-Agent: hackney/1.13.0 Device ydqBlFsGQ--xZ-_efQxuLw just connected from IP 172.18.0.1","ref":"060-triggers.html#actions","title":"Triggers - Actions","type":"extras"},{"doc":"Channels are part of AppEngine, and allow users to monitor device events through WebSockets, on top of Phoenix Channels . Under the hood, Channels use transient triggers to define which kind of events will flow through a specific room.","ref":"060-triggers.html#relationship-with-channels","title":"Triggers - Relationship with Channels","type":"extras"},{"doc":"Groups Astarte supports creating groups of devices in a realm. Groups are currently useful mainly to provide access control, combining Astarte's path based authorization with the fact that devices can be queried with a group URL. This makes it possible to emit tokens allowing a user to operate only on devices that belong to a specific group. Groups can be managed using astartectl or using AppEngine API . See the Managing Groups page in the User Guide for some usage examples. Keep in mind a group is existing as long as there's at least one device in it. Once the last device is removed from the group, the group does not exist anymore, since groups are a tag (or label) of devices.","ref":"065-groups.html","title":"Groups","type":"extras"},{"doc":"Authentication and Authorization Authentication and authorization are crucial, as Astarte likely holds sensitive resources and is capable to send mass commands to a device fleet. First of all: when talking about auth in Astarte, we are talking about anything which isn't a Device - those are Authenticated through Pairing and Authorized by their Transport (which uses Pairing for the Authentication policies). Astarte's authentication/authorization stage identifies the principal through a token (with JWT as the first class citizen), which is the only currency the platform supports.","ref":"070-auth.html","title":"Authentication and Authorization","type":"extras"},{"doc":"In Astarte, realms are logically separated and have completely different data partitions. This is also true in terms of authentication, as caller is always authenticated on a per-realm basis. As such, an authentication realm matches 1:1 an Astarte realm. Superadmin APIs, such as housekeeping, are part of a different authentication realm which is defined upon cluster setup.","ref":"070-auth.html#authentication-realms","title":"Authentication and Authorization - Authentication Realms","type":"extras"},{"doc":"Astarte, by design, does not have a concept of per-user authentication built in. The definition of an authentication realm is a mean to verify a token's validity, that is most likely a public key. This makes integrating Astarte with 3rd party authentication/authorization frameworks and SSOs extremely easy, as the whole logic for addressing user management is managed out of the cluster by a dedicated party. Depending on one's use case, it is possible to use either a very simple, dedicated OAuth server for each realm, or a full fledged SSO such as Keycloak which matches its authentication realms to Astarte's realms. Especially if you are aiming at the latter, make sure to read the advised best practices for authentication afterwards.","ref":"070-auth.html#authentication-in-astarte","title":"Authentication and Authorization - Authentication in Astarte","type":"extras"},{"doc":"Currently, Astarte supports a URL-based authorization for the API. Given that Astarte's data access APIs match the devices' topology like a tree, declaring the authorization in terms of path whitelisting gives enough flexibility to give each user the correct permissions without limitations. As said, Astarte does not have the concept of user, and neither has a durable storage which tracks permissions. As such, it expects the authorization information to be inside the token, which is the only entity Astarte can trust - given it has been verified and authenticated through its signature. Paths are given in form of a set of Perl-like Regular Expressions , and on a per-API basis. This means that each API endpoint (app, realm, etc...) has its own regular expression which defines what the user can do. Moreover, each HTTP verb in an API endpoint (e.g.: GET, POST, PUT, DELETE) can have its own regular expression, to fine-grain permissions on each path. Note: given Astarte's interface are either read only or write only, HTTP verb fine-graining in AppEngine API is mostly useful for preventing a user from deleting a consumer Datastream even though it has write access to it. Most of the time, using only a single regular expression with no verb fine-graining works. Examples of valid regular expressions on AppEngine API are: POST::devices/.*/interfaces/com\\\\.my\\\\.interface/.* : Allows to set individual values on the com.my.interface interface on any individual device in the realm. .*::.*/interfaces/com\\\\.my\\\\.monitoring\\\\.interface.* : Allows to get/set/delete either the aggregate or the individual values of the com.my.monitoring.interface interface on any device or device aggregation in the realm. .*::devices/j0zbvbQp9ZNnanwvh4uOCw.* : Allows every operation on device j0zbvbQp9ZNnanwvh4uOCw GET::devices/[a-zA-Z0-9-_]* : Allows to get every individual device's status, but denies access to any additional information/operation on them. Examples of valid regular expressions on Realm Management API are: POST::interfaces\\/.* : Allows installing new interfaces in the realm. GET::interfaces\\/.* : Allows inspecting every interface in the realm. PUT::interfaces\\/.*\\/0 : Allows updating all draft interfaces in the realm. Other valid examples are: .*::.* : Allows any operation on the given API. Both verb and path regular expressions are implicitly delimited by adding ^ before and $ after the regular expression string. For example, if you use GET::interfaces as regular expression in Realm Management API, the path will be matched against ^GET$ and the path will be matched against ^interfaces$ . This way the only operation allowed will be listing all the interfaces, while all operation on interfaces/ subpaths will be denied. Token claims and formats Authorization regular expressions have to be contained in the token's claims. Only the JWT case will be considered given it is the primary currency Astarte supports. Every claim is an array of regular expressions, which act as a logical OR. A similar behavior could be of course achieved (and might be more efficient) with a singular regular expression, but for the sake of readability and simplicity it is allowed nonetheless. Of course, keeping the authorization claims simple and pragmatic helps in terms of performance. Supported token claims are: a_aea : Defines the regular expressions for AppEngine API a_rma : Defines the regular expressions for Realm Management API a_ha : Defines the regular expressions for Housekeeping API a_pa : Defines the regular expressions for Pairing API a_ch : Defines the regular expressions for Channels Of course, claims are considered only after a successful token verification. This means that the claim will be processed only if the caller is authenticated against the correct authentication realm - this is especially the case for what concerns Housekeeping, which has a dedicated Authentication realm not tied to any Astarte realms. An example of a valid token claim is: { &quot;a_aea&quot;: [&quot;GET::devices/[a-zA-Z0-9-_]*&quot;, &quot;.*::.*/interfaces/com\\\\.my\\\\.monitoring\\\\.interface.*&quot;, &quot;.*::devices/j0zbvbQp9ZNnanwvh4uOCw.*&quot;], &quot;a_rma&quot;: [&quot;GET::.*&quot;] } Which allows very specific permissions on AppEngine API, and a &quot;read all&quot; on Realm Management API. The client by default has no permission to do anything: as such, if a token is missing a claim it is simply assumed that the client isn't authorized to access that specific API. However, keeping in mind that Astarte has no concept of User, it is also true that your authentication backend might choose to emit a different token with only a subset of its real permissions to keep claims and regular expressions as pragmatic as possible. See Granular Claims in Best Practices for more details on this. Natively supported tokens Astarte supports only JWT natively, which has to be signed using one of the following algorithms: ES256 ES384 ES512 PS256 PS384 PS512 RS256 RS384 RS512","ref":"070-auth.html#authorization","title":"Authentication and Authorization - Authorization","type":"extras"},{"doc":"Valid tokens can be used for calling into Astarte's public APIs. Depending on which token mechanism is used, the HTTP call must adhere to some requirements. JWT Every API call must have an Authorization: Bearer &lt;token&gt; header. Not providing the token or providing a token which can't be validated for the authentication realm of the context results in a 401 reply.","ref":"070-auth.html#authorization-for-rest-apis","title":"Authentication and Authorization - Authorization for REST APIs","type":"extras"},{"doc":"A valid token should be supplied when opening the WebSocket, in the very same fashion to what happens with REST APIs. However, the claims in this token will support different verbs compared to the REST APIs, namely JOIN and WATCH . These have very specific meanings and are well explained in Channels' User Guide . The behavior and supported tokens are equivalent to REST APIs.","ref":"070-auth.html#authorization-for-channels","title":"Authentication and Authorization - Authorization for Channels","type":"extras"},{"doc":"Astarte, by default, is extremely easy to configure assuming your chosen SSO is capable of issuing JWT, as it is currently the only natively supported authentication currency. However, virtually any token-based system can be used as an auth framework for Astarte. The main purpose of Astarte's design, however, is to keep things simple for everyone. Putting up a full-fledged SSO dedicated to Astarte is beyond the scope of this documentation, and we favor the use case where an existing SSO infrastructure is integrated with Astarte, rather than built ad-hoc. For simple use cases and instant satisfaction, it is strongly advised to use a simpler solution, such as a dedicated OAuth server. Almost all popular languages and frameworks provide great projects which can spin up an OAuth2 server + user management in a matter of hours, from Elixir/Phoenix to Java/Spring to Go . Astarte's Enterprise Distribution includes other add-ons, such as automation and configuration for popular SSOs.","ref":"070-auth.html#supported-integrations","title":"Authentication and Authorization - Supported integrations","type":"extras"},{"doc":"Due to the nature of tokens, applications and SSOs must take care of emission and storage of the token themselves. In most production cases, Astarte will be part of a larger SSO infrastructure being one of the clients (this is especially true for OAuth). Among best practices, emitting short-lived tokens should always be considered, but depending on the use case, the authentication pipeline can be further tuned to address a number of potential issues. Token exchange OAuth, like other protocols supports the concept of a Token Exchange . Consider a web dashboard with a logged in user. The user will, most likely, have a token which is used by its frontend to call upon the backend/APIs of the web dashboard. For the sake of simplicity, one might include in this token the adequate claims to give the user access to Astarte, but this might not be desirable for a number of reasons outlined above. Token exchange, if supported by your SSO, provides a great way to work around this: whenever the backend or the frontend requires access to Astarte, it can invoke the token exchange mechanism of the SSO to generate a short lived token for the API call from the original authentication, which can then be used even as a single shot access mechanism. Granular claims The token exchange approach can be efficiently paired with a mechanism of granular claims. Consider the use case above, and let's assume the frontend needs direct, frequent access to Astarte's APIs. Exchanging tokens too many times might put a burden on the SSO and might become impractical. However, Astarte decouples entirely authentication and authorization - that means, if two subsequent (valid) tokens which represent the same identity have substantially different claims, it doesn't care. This is intentional, as it allows for a much more efficient pattern: the token used by an hypotetical frontend can have a subset of the user's claims - for example, allowing him to read data from its devices, whereas token exchange can be used whenever more specific operations should be performed - for example, sending some commands or data to devices. This also addresses the objection that regular expressions can grow big or quite complicated in case users need a large number of very granular permissions. In such complex cases, the SSO can be tuned to give out only a subset of claims depending on the user's operation. Token revocation Token revocation isn't natively supported in Astarte for two reason: the first one is performance, as keeping a revocation list is expensive in many regards. The second is the fact that the revocation list is, most of the time, SSO specific, and a dedicated SSO integration would be required. Rather than token revocation, a better practice is to make sure every emitted token has a short enough lifetime. However, it is possible to extend Astarte's authorization stage to support revocation, even though there are no plans to provide upstream support for that. Changing a Realm's validation mean Over the lifetime of a cluster, it might be necessary to change a realm's validation mean for the most diverse reasons. By design, validation means are meant to be long lived, and changing them is supposed to be an extraordinary operation. Astarte supports only one validation mean at a time. When the validation mean is changed, all tokens emitted which could be validated with the previous mean become invalid. It is also possible that there might be a delay between the request of a validation mean change and its actuation. This means during this grace period tokens will be validated against the previously configured mean. As such, it is advised to treat a validation mean change as a maintenance operation for the realm. More details can be found in the Administrator Guide.","ref":"070-auth.html#best-practices","title":"Authentication and Authorization - Best practices","type":"extras"},{"doc":"Astarte MQTT v1 Protocol Astarte MQTT v1 Protocol allows communication between Astarte and devices. It is the first protocol that has been implemented in Astarte, and it exploits every feature provided by Astarte itself. Astarte MQTT v1 doesn't mandate a specific Transport Credentials format: the broker must handle Authentication, Authorization and Pairing integration the way it sees fit. Astarte MQTT v1 is implemented by Astarte's Reference Transport, Astarte/VerneMQ - a client wishing to interact with it must implement MQTT v3.1.1 and all needed features for Pairing to work. MQTT doesn't mandate the data serialization format, so any application might implement its own format. Data serialization might be a tricky task and protocols might be hard to design, Astarte MQTT takes care of this and provides a higher level protocol which abstracts this detail from the end user. Astarte MQTT v1 Protocol builds upon MQTT v3.1.1 itself, BSON (Binary JSON, version 1.1) serialized payloads and on optional zlib deflate. All communications are ordered and asynchronous. A protocol reference implementation is provided with an Astarte SDK, however developers might implement it from scratch using 3rd party libraries with their favourite languages: all formats and protocols described here are open and well documented. Last but not least Astarte doesn't mandate this protocol, and a different one can be used with a different transport.","ref":"080-mqtt-v1-protocol.html","title":"Astarte MQTT v1 Protocol","type":"extras"},{"doc":"Astarte MQTT v1 Protocol relies on few well known reserved topics. Topic Purpose Published By QoS Payload Format &lt;realm name&gt;/&lt;device id&gt; Introspection Device 2 ASCII plain text, ':' and ';' delimited &lt;realm name&gt;/&lt;device id&gt;/control/emptyCache Empty Cache Device 2 ASCII plain text (always &quot;1&quot;) &lt;realm name&gt;/&lt;device id&gt;/control/consumer/properties Purge Properties Astarte 2 deflated plain text &lt;realm name&gt;/&lt;device id&gt;/control/producer/properties Purge Properties Device 2 deflated plain text &lt;realm name&gt;/&lt;device id&gt;/&lt;interface name&gt;/&lt;path&gt; Publish Data Both 0, 1, 2 BSON (or empty) For clarity reasons all &lt;realm name&gt;/&lt;device id&gt; prefixes will be omitted on the following paragraphs, those topics will be called device topics. Topics are not bidirectional, devices must not publish data for server owned topics and viceversa, onwership is explicitly stated in interfaces files.","ref":"080-mqtt-v1-protocol.html#mqtt-topics-overview","title":"Astarte MQTT v1 Protocol - MQTT Topics Overview","type":"extras"},{"doc":"BSON allows saving precious bytes compared to JSON, while offering the advantages of a schema-less protocol. Consider, for example, a simple value and timestamp payload. The encoded JSON version, {&quot;v&quot;:25.367812,&quot;t&quot;:1537346756844} counts 33 bytes. The hexdump of the same message encoded with BSON is: 0000000 1 b 00 00 00 09 74 00 ec e0 01 f1 65 01 00 00 01 0000020 76 00 8 c 13 5 f ed 28 5 e 39 40 00 that fits just in 27 bytes. BSON format BSON is a really simple binary format, breaking down the previous example is very easy thanks to BSON simplicity: the first 4 bytes ( 1b 00 00 00 ) are the document size header, follows the timestamp marker ( 09 ), the timestamp key name ( 74 00 , that is &quot;t&quot;), the timestamp value ( 5f 48 06 f1 65 01 00 00 as int64), the double value marker ( 01 ), the value key name ( 76 00 , that is &quot;v&quot;), the actual value ( cd cc cc cc cc 4c 39 40 as 64-bit IEEE 754-2008 floating point) and the end of document marker ( 00 ). Astarte payload standard fields Key Type Mandatory Description v Any Astarte type Yes The value being sent (both properties and datastream) t UTC datetime No Explicit timestamp, if present (optional, datastream only) Astarte data types to BSON types Astarte Data Type BSON Type Size in Bytes double double (0x01) 8 integer int32 (0x10) 4 boolean boolean (0x08) 1 longinteger int64 (0x12) 8 string UTF-8 string (0x02) &gt;= length (encoding dependent) binaryblob binary (0x05) length datetime UTC datetime (0x09) 8 doublearray Array (0x04) (8 + keysize) * count integerarray Array (0x04) (4 + keysize) * count booleanarray Array (0x04) (1 + keysize) * count longintegerarray Array (0x04) (1 + keysize) * count stringarray Array (0x04) depends on count, length, keys length and encoding binaryblobarray Array (0x4) depends on count, keys length and length integer and long integer are signed integer values, double must be a valid number ( +inf , NaN , etc... are not supported), variable data types might be subject to size limitations and object aggregations are encoded as embedded documents.","ref":"080-mqtt-v1-protocol.html#bson","title":"Astarte MQTT v1 Protocol - BSON","type":"extras"},{"doc":"A device is not required to publish any additional connection or disconnection messages, the MQTT broker will automatically keep track of these events and relay them to Astarte. When connecting, before publishing any data message, a device should check MQTT session present flag. When the MQTT session present flag is true no further actions are required, when false the device should take following actions: Publish its introspection Publish an empty cache message Publish all of its existing and set properties on all its property interfaces If a device is unable to inspect session present all previous actions must be taken at every reconnection.","ref":"080-mqtt-v1-protocol.html#connection-and-disconnection","title":"Astarte MQTT v1 Protocol - Connection and Disconnection","type":"extras"},{"doc":"Each device must declare the set of supported interfaces and their version. Astarte needs to know which interfaces the device advertises before processing any further data publish. This message in Astarte jargon is called introspection and it's performed by publishing on the device root topic the list of interfaces that are installed on the device. Introspection payload is a simple plain text string, and it has the following format (in BNF like syntax): introspection :: = introspection_list introspection_list :: = introspection_entry &quot;;&quot; introspection_list | introspection_entry introspection_entry :: = interface_name &quot;:&quot; interface_major_version &quot;:&quot; interface_minor_version The following example is a valid introspection payload: com . example . MyInterface : 1 : 0 ; org . example . DraftInterface : 0 : 3","ref":"080-mqtt-v1-protocol.html#introspection","title":"Astarte MQTT v1 Protocol - Introspection","type":"extras"},{"doc":"Astarte MQTT v1 strives to save bandwidth upon reconnections, to make sure even frequent reconnections don't affect bandwidth consumption. As such, upon connecting and if MQTT advertises a session present, both sides assume that data flow is ordered and consistent. However, there might be cases where this guarantee isn't respected by the device for a number of reasons (e.g.: new device, factory reset, cache lost...). In this case, a device might declare that it has no confidence about its status and its known properties, and can request to resynchronise entirely with Astarte. In Astarte jargon this message is called empty cache and it is performed by publising &quot;1&quot; on the device /control/emptyCache topic. After an empty cache message properties might be purged and Astarte might publish all the server owned properties again.","ref":"080-mqtt-v1-protocol.html#empty-cache","title":"Astarte MQTT v1 Protocol - Empty Cache","type":"extras"},{"doc":"In the very same fashion as the device, Astarte (or the broker) might be inconsistent with a Device's known status and its known properties. Although unlikely, as Astarte should always keep knowledge about remote device status, this might happen, for example, after an internal error. Astarte performs this task by telling the broker to disconnect the device and clear its session. After this, when the device will attempt reconnection, session present will be false. After a clean session properties might be purged.","ref":"080-mqtt-v1-protocol.html#session-present","title":"Astarte MQTT v1 Protocol - Session Present","type":"extras"},{"doc":"Either a Device or Astarte may tell the remote host the set properties list. Any property that is not part of the list will be deleted from any cache or database. This task is called purge properties in Astarte jargon, and it is performed by publishing a the list of known set properties to /control/consumer/properties or /control/producer/properties . Purge Properties payload is a zlib deflated plain text, with an additional 4 bytes header. The additional 4 bytes header is the size of the uncompressed payload, encoded as big endian uint32. The following example is a payload compressed using zlib default compression, with the additional 4 bytes header: 0000000 00 00 00 46 78 9 c 4 b ce cf d5 4 b ad 48 cc 2 d c8 0000020 49 d5 f3 ad f4 cc 2 b 49 2 d 4 a 4 b 4 c 4 e d5 2 f ce 0000040 cf 4 d d5 2 f 48 2 c c9 b0 ce 2 f 4 a 87 ab 70 29 4 a 0000060 4 c 2 b 41 28 ca 2 f c9 48 2 d 0 a 00 2 a 02 00 b2 0 c 0000100 1 a c9 The uncompressed plain text payload has the following format (in BNF like syntax): properties :: = properties_list properties_list :: = properties_entry &quot;;&quot; properties_list | properties_entry properties_entry :: = interface_name path The following example is the inflated previous payload: com . example . MyInterface / some / path ; org . example . DraftInterface / otherPath This protocol feature is fundamental when a device has any interface with an allow_unset mapping, purge properties allows to correct any error due to unhandled unset messages.","ref":"080-mqtt-v1-protocol.html#purge-properties","title":"Astarte MQTT v1 Protocol - Purge Properties","type":"extras"},{"doc":"Either Astarte or a device might publish new data on a interface/endpoint specific topic. The topic is built using /&lt;interface name&gt;/&lt;path&gt; schema, and it is used regardless of the type of interface or mapping being used. Also / path is a valid path for object aggregated interfaces. The following device topics are valid: /com.example.MyInterface/some/path /org.example.DraftInterface/otherPath /com.example.astarte.ObjectAggregatedInterface/ Data messages QoS is chosen according to mapping settings, such as reliability. Properties are always published using QoS 2. Interface Type Reliability QoS properties always unique 2 datastream unreliable 0 datastream guaranteed 1 datastream unique 2 Payload Format Payload format might change according to the message type. Payloads are always BSON encoded, except for unset messages that are empty. Property Message Property messages have a &quot;v&quot; key (which means value). Valid examples are: {&quot;v&quot;: &quot;string property value&quot;} {&quot;v&quot;: 10} {&quot;v&quot;: true} Previous payloads are BSON encoded as the following hex dumps: 0000000 22 00 00 00 02 76 00 16 00 00 00 73 74 72 69 6 e 0000020 67 20 70 72 6 f 70 65 72 74 79 20 76 61 6 c 75 65 0000040 00 00 0000000 0 c 00 00 00 10 76 00 0 a 00 00 00 00 0000000 09 00 00 00 08 76 00 01 00 Property messages order must be preserved and they must be consumed in order. The same property with the same value can be sent several times, this behavior is allowed but discouraged: it's up to the device to avoid useless messages. A device must also make sure to publish all the properties that have been changed while the device was offline. Unset Property Message Properties can be unset with an unset message. An unset message is just an empty 0 bytes payload. Datastream Message (individual aggregation) Datastream messages for interfaces with individual aggregation have a &quot;v&quot; key and an optional &quot;t&quot; key (which means timestamp). Valid examples are: {&quot;v&quot;: false} {&quot;v&quot;: 16.73} {&quot;v&quot;: 16.73, &quot;t&quot;: 1537449422890} Timestamps are UTC timestamps (BSON 0x09 type), when not provided reception timestamp is used. Previous payloads are BSON encoded as the following hex dumps: 0000000 09 00 00 00 08 76 00 00 00 0000000 10 00 00 00 01 76 00 7 b 14 ae 47 e1 ba 30 40 00 0000000 1 b 00 00 00 09 74 00 2 a 70 20 f7 65 01 00 00 01 0000020 76 00 7 b 14 ae 47 e1 ba 30 40 00 Datastream Message (object aggregation) Datastream messages for interfaces with object aggregation support every Astarte payload standard field (such as &quot;t&quot;), but in this case value is a BSON subdocument, in which each key represent a mapping of the aggregation. Valid examples are: {&quot;v&quot;: {&quot;temp&quot;: 25.3123, &quot;hum&quot;: 67.112}} {&quot;v&quot;: {&quot;temp&quot;: 25.3123, &quot;hum&quot;: 67.112}, &quot;t&quot;: 1537452514811} Timestamps are UTC timestamps (BSON 0x09 type), when not provided reception timestamp is used. Previous payloads are BSON encoded as following hex dumps: 0000000 28 00 00 00 03 76 00 20 00 00 00 01 68 75 6 d 00 0000020 ba 49 0 c 02 2 b c7 50 40 01 74 65 6 d 70 00 72 8 a 0000040 8 e e4 f2 4 f 39 40 00 00 0000000 33 00 00 00 09 74 00 fb 9 d 4 f f7 65 01 00 00 03 0000020 76 00 20 00 00 00 01 68 75 6 d 00 ba 49 0 c 02 2 b 0000040 c7 50 40 01 74 65 6 d 70 00 72 8 a 8 e e4 f2 4 f 39 0000060 40 00 00","ref":"080-mqtt-v1-protocol.html#publishing-data","title":"Astarte MQTT v1 Protocol - Publishing Data","type":"extras"},{"doc":"A device might implement a subset of this protocol if needed. /control/consumer/properties , /control/producer/properties and /emptyCache might be ignored or not implemented if a device has no property interfaces. A further simplification might remove any requirement for any introspection message when previously provisioned, but this feature is not supported out of the box.","ref":"080-mqtt-v1-protocol.html#minimal-protocol","title":"Astarte MQTT v1 Protocol - Minimal Protocol","type":"extras"},{"doc":"A device might be forcefully disconnected due to any kind of error. Devices should wait a random amount of time before trying to connect again to the broker. session present might be also set to false to ensure a clean and consistent state (in that case messages such as introspection and empty cache should published as previously described). Malformed or unexpected messages are discarded and further actions might be taken.","ref":"080-mqtt-v1-protocol.html#error-handling","title":"Astarte MQTT v1 Protocol - Error Handling","type":"extras"},{"doc":"In Astarte, every Transport orchestrates its credentials through Pairing. Astarte/VerneMQ authenticates devices using Mutual SSL Autentication - as such, devices use SSL certificates emitted through Pairing API to authenticate against the broker. To achieve this, the device must ensure it is capable of performing http(s) calls to Pairing API to obtain its certificates, performing SSL/X509 operations and connecting to the MQTT Broker through the use of SSL certificates.","ref":"080-mqtt-v1-protocol.html#authentication","title":"Astarte MQTT v1 Protocol - Authentication","type":"extras"},{"doc":"Device can only publish and subscribe to its device topic ( &lt;realm name&gt;/&lt;device id&gt; ) and its subtopics. The broker will deny any publish or subscribe outside that hierarchy.","ref":"080-mqtt-v1-protocol.html#authorization","title":"Astarte MQTT v1 Protocol - Authorization","type":"extras"},{"doc":"In the same fashion as Authentication, Pairing provides the client with information about how to connect to the MQTT broker. When invoking relevant Pairing API's method to gather information about available transports for a device, if Astarte advertises Astarte MQTT v1, a similar reply will be returned: { &quot;data&quot;: { &quot;version&quot;: &quot;&lt;version string&gt;&quot;, &quot;status&quot;: &quot;&lt;status string&gt;&quot;, &quot;protocols&quot;: { &quot;astarte_mqtt_v1&quot;: { &quot;broker_url&quot;: &quot;mqtts://broker.astarte.example.com:8883&quot; } } } }","ref":"080-mqtt-v1-protocol.html#connecting-to-the-broker","title":"Astarte MQTT v1 Protocol - Connecting to the Broker","type":"extras"},{"doc":"Astarte Database Astarte leverages Cassandra to store all of its data, including data ingested from devices (which might scale to insane amounts). Cassandra offers scalability and high availability with good performances . Cassandra offers linear scalability and can span from really small clusters to hundreds of nodes, without compromising on reliability. ScyllaDB &gt;= 3.3 is also supported as a drop-in replacement when a performance boost is needed. Cassandra is also the ideal storage for large-scale data processing with Apache Spark . Astarte is multi-tenant by design, with each tenant mapping to an Astarte Realm. Each Realm has its own Cassandra keyspace, which can be tuned according to Realm-specific needs (e.g.: Realms might have different replication levels). For this reason, in the scope of this section, realm and keyspace can be used as synonyms, except for the astarte keyspace.","ref":"090-database.html","title":"Astarte Database","type":"extras"},{"doc":"Astarte automatically takes care of keyspaces, tables creation and intra-version migrations (those tasks are performed by astarte_housekeeping or astarte_realm_management , depending on the context). The following documentation is just a reference about Astarte's internal statements, and is related to the release series referenced by the documentation. Astarte Keyspace Astarte needs an astarte keyspace to store its own data. astarte keyspace and tables are created with following CQL statements: CREATE KEYSPACE astarte WITH replication = {'class': 'SimpleStrategy', 'replication_factor': &lt;replication factor&gt;} AND durable_writes = true; CREATE TABLE astarte.realms ( realm_name varchar, PRIMARY KEY (realm_name) ); Realm Creation Each realm needs several tables to store data for all the functionalities. Realm tables can be grouped in the following functionalities: Configuration &amp; key-value store Interfaces schema Device management Groups management Triggers storage Data storage Some data storage tables might be created when required, whereas all other tables are created when a keyspace is created, using the following statements: CREATE KEYSPACE &lt;realm name&gt; WITH replication = {'class': 'SimpleStrategy', 'replication_factor': :replication_factor} AND durable_writes = true; CREATE TABLE &lt;realm name&gt;.kv_store ( group varchar, key varchar, value blob, PRIMARY KEY ((group), key) ); CREATE TABLE &lt;realm name&gt;.names ( object_name varchar, object_type int, object_uuid uuid, PRIMARY KEY ((object_name), object_type) ); CREATE TABLE &lt;realm_name&gt;.devices ( device_id uuid, aliases map&lt;ascii, varchar&gt;, introspection map&lt;ascii, int&gt;, introspection_minor map&lt;ascii, int&gt;, old_introspection map&lt;frozen&lt;tuple&lt;ascii, int&gt;&gt;, int&gt;, protocol_revision int, first_registration timestamp, credentials_secret ascii, inhibit_credentials_request boolean, cert_serial ascii, cert_aki ascii, first_credentials_request timestamp, last_connection timestamp, last_disconnection timestamp, connected boolean, pending_empty_cache boolean, total_received_msgs bigint, total_received_bytes bigint, exchanged_bytes_by_interface map&lt;frozen&lt;tuple&lt;ascii, int&gt;&gt;, bigint&gt;, exchanged_msgs_by_interface map&lt;frozen&lt;tuple&lt;ascii, int&gt;&gt;, bigint&gt;, last_credentials_request_ip inet, last_seen_ip inet, groups map&lt;text, timeuuid&gt;, PRIMARY KEY (device_id) ); CREATE TABLE &lt;realm name&gt;.grouped_devices ( group_name varchar, insertion_uuid timeuuid, device_id uuid, PRIMARY KEY ((group_name), insertion_uuid, device_id) ); CREATE TABLE &lt;realm name&gt;.endpoints ( interface_id uuid, endpoint_id uuid, interface_name ascii, interface_major_version int, interface_minor_version int, interface_type int, endpoint ascii, value_type int, reliability int, retention int, expiry int, database_retention_ttl int, database_retention_policy int, allow_unset boolean, explicit_timestamp boolean, description varchar, doc varchar, PRIMARY KEY ((interface_id), endpoint_id) ); CREATE TABLE &lt;realm name&gt;.interfaces ( name ascii, major_version int, minor_version int, interface_id uuid, storage_type int, storage ascii, type int, ownership int, aggregation int, automaton_transitions blob, automaton_accepting_states blob, description varchar, doc varchar, PRIMARY KEY (name, major_version) ); CREATE TABLE &lt;realm name&gt;.individual_properties ( device_id uuid, interface_id uuid, endpoint_id uuid, path varchar, reception_timestamp timestamp, reception_timestamp_submillis smallint, double_value double, integer_value int, boolean_value boolean, longinteger_value bigint, string_value varchar, binaryblob_value blob, datetime_value timestamp, doublearray_value list&lt;double&gt;, integerarray_value list&lt;int&gt;, booleanarray_value list&lt;boolean&gt;, longintegerarray_value list&lt;bigint&gt;, stringarray_value list&lt;varchar&gt;, binaryblobarray_value list&lt;blob&gt;, datetimearray_value list&lt;timestamp&gt;, PRIMARY KEY((device_id, interface_id), endpoint_id, path) ); CREATE TABLE &lt;realm name&gt;.simple_triggers ( object_id uuid, object_type int, parent_trigger_id uuid, simple_trigger_id uuid, trigger_data blob, trigger_target blob, PRIMARY KEY ((object_id, object_type), parent_trigger_id, simple_trigger_id) );","ref":"090-database.html#schema-and-keyspace-creation","title":"Astarte Database - Schema and Keyspace Creation","type":"extras"},{"doc":"Devices Devices table stores the list of all the devices for a certain realm and all their metadata, including the introspection, the device status and credentials information. Column Name Column Type Description device_id uuid Device unique 128 bits ID. aliases map&lt;ascii, varchar&gt; Alias purpose and alias map. introspection map&lt;ascii, int&gt; Device interface name to interface major version map based on most recent device introspection. introspection_minor map&lt;ascii, int&gt; Device interface name to interface minor version map based on most recent device introspection. old_introspection map&lt;frozen&lt;tuple&lt;ascii, int&gt;&gt;, int&gt; All previous device interfaces. This column is used to keep track of all interfaces that have been used and might still have some recorded data. The column maps interface (name, major) to minor. protocol_revision int Spoken Astarte MQTT v1 protocol revision. first_registration timestamp First registration attempt timestamp. credentials_secret ascii The bcrypt hash of the credential secret, that the device uses to obtain new credentials. inhibit_credentials_request boolean Ban device credentials renewal, device will be able to connect to the transport up to the credential expiry. cert_serial ascii Device certificate serial used by the CA. cert_aki ascii Device certificate Authority Key Identifier. first_credentials_request timestamp First credentials request timestamp. last_connection timestamp Most recent device connection event timestamp. last_disconnection timestamp Most recent device disconnection event timestamp. connected boolean True if the device is connected, otherwise is false. pending_empty_cache boolean Device is in an unclean state and an empty cache message is being waited. total_received_msgs bigint Count of received messages since the device registration. total_received_bytes bigint Amount of received messages bytes since the device registration. exchanged_msgs_by_interface bigint Count of exchanged messages since the device registration. exchanged_bytes_by_interface bigint Amount of exchanged messages bytes since the device registration. last_credentials_request_ip inet Device IP address used during the last credential request. last_seen_ip inet Most recent device IP address. groups map&lt;text, timeuuid&gt; Groups which the device belongs to, the key is the group name, and the value is its insertion timeuuid, which is used as part of the key on grouped_devices table.","ref":"090-database.html#tables","title":"Astarte Database - Tables","type":"extras"},{"doc":"This section describes the schema changes happening between different Astarte Versions. They are divided between Astarte Keyspace (changes that affect the Astarte Keyspace), and Realm Keyspaces (changes that affect all realm keyspaces). Every change is followed by the CQL statement that produces the change. From v0.10 to v0.11 Astarte Keyspace v0.11 Changes Remove astarte_schema table DROP TABLE astarte_schema; Remove replication_factor column from the realms table ALTER TABLE realms DROP replication_factor; Realm Keyspaces v0.11 Changes Add grouped_devices table CREATE TABLE &lt;realm_name&gt;.grouped_devices ( group_name varchar, insertion_uuid timeuuid, device_id uuid, PRIMARY KEY ((group_name), insertion_uuid, device_id) ); Add groups , exchanged_bytes_by_interface and exchanged_msgs_by_interface columns to the devices table ALTER TABLE &lt;realm_name&gt;.devices ADD (groups map&lt;text, timeuuid&gt;, exchanged_bytes_by_interface map&lt;frozen&lt;tuple&lt;ascii, int&gt;&gt;, bigint&gt;, exchanged_msgs_by_interface map&lt;frozen&lt;tuple&lt;ascii, int&gt;&gt;, bigint&gt;); Add database_retention_ttl and database_retention_policy columns to the endpoints table ALTER TABLE &lt;realm_name&gt;.endpoints ADD ( database_retention_ttl int, database_retention_policy int );","ref":"090-database.html#schema-changes","title":"Astarte Database - Schema changes","type":"extras"},{"doc":"Introduction This documentation page describes a discontinued version, for production systems use a newer version instead. Astarte is an Open Source IoT platform focused on Data management. It takes care of everything from collecting data from devices to delivering data to end-user applications. To achieve such a thing, it uses a mixture of mechanisms and paradigm to store organized data, perform live queries. This guide focuses on daily operations for Astarte users and integrators. It goes through fundamental operations such as setting up triggers, querying APIs, integrating 3rd party applications and more. The user guide starts from the assumption that the reader is interacting with one or more well-known realms , and throughout the manual the assumption is that we're always operating inside a test realm, unless otherwise specified. Setting up realms is out of the scope of this guide, also because it's not a task the average user has to deal with. Please refer to the dedicated chapter of the Administrator manual to learn more about this specific topic. Before you begin, make sure you are familiar with Astarte's architecture, design and concepts .","ref":"001-intro_user.html","title":"Introduction","type":"extras"},{"doc":"Interacting with Astarte Astarte's interaction is logically divided amongst two main entities. Devices are the bottom end, and represent your IoT fleet. They can access Astarte only through a Transport, they are defined by a set of Interfaces which, in turn, also define on a very granular level which kind of data they can exchange. By design, they can't access any resource which isn't their own: such a behavior can be configured using Astarte as a middleman to act as a secure Gateway. Users are actual users, applications or anything else which needs to interact directly with Astarte. They are bound to a realm, and can virtually access any resource in that realm given they're authorized to do so. Users can also manage triggers and perform maintenance activity on the Realm.","ref":"010-interacting_with_astarte.html","title":"Interacting with Astarte","type":"extras"},{"doc":"When interacting with Astarte as a User, you have several options to choose from: astartectl : astartectl is the main command-line tool to interact with Astarte clusters, which packs in a number of subcommands to interact with Astarte API sets. It is a swiss army knife to perform daily operations on Astarte Clusters, and it abstracts most Astarte API interactions in a user-friendly way. Astarte Dashboard: Astarte provides a built-in UI that can be used for managing Interfaces, Devices and Triggers. If your cluster has the dashboard enabled, it can be usually found at dashboard.&lt;base Astarte URL&gt; . It is meant to be a graphical, user-friendly tool to perform daily operations in the Cluster. Astarte API Clients: API Clients are provided for a variety of languages. These clients abstract API interaction with language-friendly paradigms, and provide API automations for several operations. Currently, the main API client available is astarte-go . Astarte APIs: The base APIs are the lower level interaction layer. They are accessible, in standard installations, at api.&lt;base Astarte URL&gt;/&lt;apiset&gt; , and are the main mean of interaction upon which all other clients are based upon. Depending on the context, you might want to choose what suits you best. Over the course of the documentation, several examples will be provided with interaction means. Setting up astartectl In the documentation, it is assumed that astartectl is properly configured to interact with your Realm or your Cluster. Please refer to its documentation to make sure all needed configurations are in place.","ref":"010-interacting_with_astarte.html#user-side-tools","title":"Interacting with Astarte - User-side Tools","type":"extras"},{"doc":"Devices interact with Astarte through their associated Transport. In this guide, we'll assume the Transport is MQTT/VerneMQ as per Astarte's defaults. However, rather than implementing the whole Astarte protocol over MQTT, it is usually a better idea to rely on one of Astarte's SDKs . Authentication/Pairing Depending on how you plan on implementing Astarte's pairing mechanism , your devices might need an Agent for their first authentication or not. However, once they retrieve their Credentials Secret, they can implement Astarte's standard pairing routine to rotate their SSL certificate for accessing the transport. In the most likely scenario in which you are using one of Astarte's SDKs, the SDK takes care of the whole pairing routine under the hood and, depending on your agent implementation, you just need to feed the SDK with either the Credentials Secret or the Agent Key. Exchanging data As per Astarte's protocol specification, data is exchanged based on the device's introspection. The device will be able to publish data on the transport on device interfaces, and receive data on server interfaces. In the MQTT case, the device will subscribe to its server interfaces' topics, and publish on its device interfaces topics. Isolation and RBAC are guaranteed by the transport's ACL, which are usually orchestrated though a dedicated Astarte extension (as in the VerneMQ/MQTT case). Again, Astarte's SDK allows you to interact with your device interfaces directly without caring about the underlying protocol and exchange details.","ref":"010-interacting_with_astarte.html#interacting-with-a-device","title":"Interacting with Astarte - Interacting with a Device","type":"extras"},{"doc":"Astarte is mainly accessed through its APIs. Astarte's APIs are exposed through dedicated microservices (see Components ) and are meant both for configuration and for accessing data. There are two main sets of APIs we'll be using frequently: AppEngine API : This API is meant for querying/pushing data from/to devices. This maps to astartectl 's astartectl appengine subcommand. Realm Management API : This API is meant for configuring a target realm, and most notably for managing triggers. This maps to astartectl 's astartectl realm-management subcommand. Authentication Authenticating against Astarte is out of the scope of this guide, especially due to the fact that Astarte does not manage authentication directly . We'll assume either the authentication isn't enabled, or that the user is always interacting with the APIs with a token with the following claims { &quot;a_aea&quot;: &quot;.*:.*&quot;, &quot;a_rma&quot;: &quot;.*:.*&quot; } Which represents a realm administrator. In real life use cases, you should always make sure to give out more granular permissions and to obtain the token in the right way from your authentication server. When using astartectl or any other client, you can also pass a Realm Private Key as an authentication mean, and have the token be automatically generated for you. Accessing the APIs In a standard Astarte installation, AppEngine API and Realm Management API are usually accessible at api.&lt;your astarte domain&gt;/appengine and api.&lt;your astarte domain&gt;/realmmanagement . If your Astarte installation has Swagger UI enabled, you can use the /swagger endpoint to access it, and to issue API calls straight from your browser to follow this guide.","ref":"010-interacting_with_astarte.html#interacting-as-a-user","title":"Interacting with Astarte - Interacting as a User","type":"extras"},{"doc":"Accessing and Exploring a Realm In Astarte, a Realm is a logical partition which holds a number of devices and an Authentication Realm","ref":"020-accessing_and_exploring_a_realm.html","title":"Accessing and Exploring a Realm","type":"extras"},{"doc":"Interface Design Guide Before we begin, let's get this straight: The way you design your interfaces will determine the overall performance and efficiency of your cluster This is because interfaces define not only the way data is exchanged between Astarte and Devices/Applications, but also how it will be stored, managed and queried . As such, it is fundamental to spend enough time on finding the most correct Interface design for your use case, keeping in mind how your users will consume your data, what might change in the future, what is fundamental and what is optional, and more.","ref":"029-interface_design_guide.html","title":"Interface Design Guide","type":"extras"},{"doc":"Before you begin, you might want to take a look at Astarte Interfaces Editor , which is also available in any Astarte Dashboard installation. Astarte Interfaces Editor gives you automated validation and linting for Astarte Interfaces, and also gives you a declarative editor with automatic JSON generation. It is well maintained and used as a reference for Interface design. Consider using it for building your interfaces.","ref":"029-interface_design_guide.html#use-the-right-tools","title":"Interface Design Guide - Use the right tools","type":"extras"},{"doc":"Without going into deeper details on what concerns Astarte's DB internals, there are some considerations one should always keep in mind when designing interfaces. Querying an Interface is fast, querying across Interfaces is painful Astarte's data modeling is designed to optimize queries within a single interface. Querying across interfaces is supported, but might affect performances significantly, especially if done frequently and with complex queries. This is especially true for triggers, as they could be evaluated very frequently. In general, if you plan on having different mappings which are frequently queried altogether, or dependent on each other for several triggers, you might be better off in having them all in the same Interface. Aggregation makes a difference Aggregation is a powerful feature, which comes with price and benefits. Even though each series has only one timestamp for all values, it is also true that losing granularity for endpoints might cause storage of redundant data if only one of the aggregated mappings change value. Moreover, in terms of data modeling, Aggregated interfaces imply the creation of a dedicated Cassandra table. Having a lot of aggregated interfaces might end up putting additional pressure on the Cassandra Cluster in terms of memory and overall performance. Your Cluster administrator might (rightfully) choose to limit the amount of installed aggregate interfaces in a Realm, or in the overall Cluster.","ref":"029-interface_design_guide.html#rationale","title":"Interface Design Guide - Rationale","type":"extras"},{"doc":"Rule of thumb: Favor extreme atomicity in case you expect your interfaces to change often, be as atomic as reasonably possible in case you want to favor performance and flexibility in querying data.","ref":"029-interface_design_guide.html#interface-atomicity","title":"Interface Design Guide - Interface Atomicity","type":"extras"},{"doc":"Managing Interfaces Interfaces define how data is exchanged over Astarte. For a Device to be capable of exchanging data into its Realm, its interfaces have to be registered into the Realm first. Let's walk over the whole process. It is assumed that you have read the Interface design guide before, to avoid bad surprises once your fleet starts rolling.","ref":"030-manage_interfaces.html","title":"Managing Interfaces","type":"extras"},{"doc":"Listing Interfaces You can list all installed interfaces in a given Realm. This will return all the valid installed Interface names, without any versioning. List Interfaces using astartectl $ astartectl realm-management interfaces list [com.my.Interface1 com.my.Interface2 com.my.Interface3] List Interfaces using Astarte Dashboard From your Dashboard, after logging in, click on &quot;Interfaces&quot; in the left menu. List Interfaces using Realm Management API GET &lt;astarte base API URL&gt;/realmmanagement/v1/test/interfaces {&quot;data&quot;: [&quot;com.my.Interface1&quot;,&quot;com.my.Interface2&quot;,&quot;com.my.Interface3&quot;]} Listing Major Versions for an Interface For each installed Interface, there can be any number of Major versions installed. This information can be retrieved by listing the available Major versions for a specific interface. In a realm, only the latest minor version of each major version of an Interface is kept. This can be done due to the fact that Semantic Versioning implies a new minor version doesn't introduce any breaking change (e.g.: deleting or renaming a mapping), and as such querying an older version of an interface using a newer one as a model is always compatible - some mappings might be empty, as expected, and will be disregarded. Astarte ensures upon Interface installation for this constraint, and as such you can always query the latest minor version of an Interface safely. List Versions using astartectl $ astartectl realm-management interfaces versions com.my.Interface1 [0 1 2] List Versions using Astarte Dashboard In the Dashboard's Interface page, click on any Interface name. A drop-down will appear, showing installed major versions for that Interface name. List Versions using Realm Management API GET &lt;astarte base API URL&gt;/realmmanagement/v1/test/interfaces/com.my.Interface1 {&quot;data&quot;: [0,1,2]} Getting an Interface Definition Astarte allows you to retrieve the Interface Definition for a given Name and Major Version pair. The definition is in the standard Interface JSON format. Get Interface Definition using astartectl $ astartectl realm-management interfaces show com.my.Interface1 0 { &quot;data&quot;: { &quot;version_minor&quot;: 2, &quot;version_major&quot;: 0, &quot;type&quot;: &quot;properties&quot;, &quot;ownership&quot;: &quot;device&quot;, &quot;mappings&quot;: [ { &quot;type&quot;: &quot;integer&quot;, &quot;path&quot;: &quot;/myValue&quot;, &quot;description&quot;: &quot;This is quite an important value.&quot; }, { &quot;type&quot;: &quot;integer&quot;, &quot;path&quot;: &quot;/myBetterValue&quot;, &quot;description&quot;: &quot;A better revision, introduced in minor 2, supported only by some devices&quot; }, { &quot;type&quot;: &quot;boolean&quot;, &quot;path&quot;: &quot;/awesome&quot;, &quot;allow_unset&quot;: true, &quot;description&quot;: &quot;Introduced in minor 1, tells you if the device is awesome. Optional.&quot; } ], &quot;interface_name&quot;: &quot;com.my.Interface1&quot; } } Get Interface Definition using Astarte Dashboard From the Interfaces page, click on an Interface name, and click on the Major version for which you'd like to see the definition. The Interfaces Editor window will open, with the Interface definition in the text box on the right. From the Editor page, it is also possible to add new mappings to the Interface and bump it to a new Minor. Get Interface Definition using Realm Management API GET &lt;astarte base API URL&gt;/realmmanagement/v1/test/interfaces/com.my.Interface1/0 { &quot;data&quot;: { &quot;version_minor&quot;: 2, &quot;version_major&quot;: 0, &quot;type&quot;: &quot;properties&quot;, &quot;ownership&quot;: &quot;device&quot;, &quot;mappings&quot;: [ { &quot;type&quot;: &quot;integer&quot;, &quot;path&quot;: &quot;/myValue&quot;, &quot;description&quot;: &quot;This is quite an important value.&quot; }, { &quot;type&quot;: &quot;integer&quot;, &quot;path&quot;: &quot;/myBetterValue&quot;, &quot;description&quot;: &quot;A better revision, introduced in minor 2, supported only by some devices&quot; }, { &quot;type&quot;: &quot;boolean&quot;, &quot;path&quot;: &quot;/awesome&quot;, &quot;allow_unset&quot;: true, &quot;description&quot;: &quot;Introduced in minor 1, tells you if the device is awesome. Optional.&quot; } ], &quot;interface_name&quot;: &quot;com.my.Interface1&quot; } }","ref":"030-manage_interfaces.html#querying-interfaces","title":"Managing Interfaces - Querying Interfaces","type":"extras"},{"doc":"Interfaces are supposed to change over time, and are dynamic. As such, they can be installed and updated. Interface installation means adding either a whole new Interface (as in: an Interface with a new name), or a new major version of an already known Interface. Interface update means updating a specific, existing interface name/major version with a new minor version. When designing interfaces, it is strongly advised to use Astarte Interface Editor. The Editor is embedded into any Astarte Dashboard installation but, in case your Astarte installation does not provide you with a Dashboard, you can use Astarte Interface Editor public online instance . Use it to write and validate your definitions, and install the resulting JSON file through either astartectl or Realm Management APIs. Synchronizing interfaces using astartectl astartectl provides a handy sync command that, given a list of Interface files, will synchronize the state of the Astarte Realm with your local interfaces. It is handy in those cases where your Realm has several interfaces, and you're storing Interfaces in a common place, such as a Git Repository - this is the average case for Astarte-based applications/clouds. Assuming you have a set of Interface files in your folder all with the .json extension, invoking astartectl realm-management interfaces sync will result in something like this: $ astartectl realm-management interfaces sync *.json Will install interface com.my.Interface1 version 0.2 Will install interface com.my.Interface2 version 1.1 Will update interface com.my.Interface3 to version 1.4 Do you want to continue? [y/n] y Interface com.my.Interface1 installed successfully Interface com.my.Interface2 installed successfully Interface com.my.Interface3 updated successfully to version 1.4 After invocation, your Astarte Realm will be up to date with all Interfaces in your local directory. Note: astartectl realm-management interfaces sync currently synchronizes Interfaces only from your local machine to the Realm, and not the other way round. In case the Realm has a more recent version of an interface compared to your local files, or it has some interfaces which are not referenced by your local files, no action will be taken. Install an Interface using Astarte Dashboard Access the Editor by going to the Interfaces page, and clicking on &quot;Install a New Interface...&quot; in the top-right corner. The Editor will open. From there, you can either paste in an existing JSON definition, which will be validated and will update the left-screen declarative Editor, or you can build a whole new Interface from scratch. Once you're done, hit the &quot;Install Interface&quot; button at the bottom of the declarative Editor (left side) to install the Interface in the Realm. Install an Interface using astartectl First of all, ensure that you have the Interface you'd like to install saved in a file on your local machine. We will assume the interface is available as interface1.json . $ astartectl realm-management interfaces install interface1.json ok Install an Interface using Realm Management API Realm Management currently implements a completely asynchronous API for Interface installation - as such, the only feedback received by the API is that the Interface is valid and the request was accepted by the backend. However, this is no guarantee that the Interface will be installed successfully. As a best practice, it is advised to either wait a few seconds in between Realm Management API invocations, or verify through a GET operation whether the Interface has been installed or not. POST &lt;astarte base API URL&gt;/realmmanagement/v1/test/interfaces The POST request must have the following request body, with content type application/json { &quot;data&quot;: { &quot;version_minor&quot;: 2, &quot;version_major&quot;: 0, &quot;type&quot;: &quot;properties&quot;, &quot;ownership&quot;: &quot;device&quot;, &quot;mappings&quot;: [ { &quot;type&quot;: &quot;integer&quot;, &quot;path&quot;: &quot;/myValue&quot;, &quot;description&quot;: &quot;This is quite an important value.&quot; }, { &quot;type&quot;: &quot;integer&quot;, &quot;path&quot;: &quot;/myBetterValue&quot;, &quot;description&quot;: &quot;A better revision, introduced in minor 2, supported only by some devices&quot; }, { &quot;type&quot;: &quot;boolean&quot;, &quot;path&quot;: &quot;/awesome&quot;, &quot;allow_unset&quot;: true, &quot;description&quot;: &quot;Introduced in minor 1, tells you if the device is awesome. Optional.&quot; } ], &quot;interface_name&quot;: &quot;com.my.Interface1&quot; } } The call will return either 201 Created or an error. Most common failure cases are: The interface/major combination already exists in the Realm The interface schema fails validation In any case, the API returns details on what caused the error and how to solve it through Astarte's standard error reply schema. Update an Interface using astartectl First of all, ensure that you have the Interface you'd like to update saved in a file on your local machine. We will assume the interface is available as interface1_3.json . $ astartectl realm-management interfaces update interface1_3.json ok Update an Interface using Astarte Dashboard Go to the Interfaces page, click on the Interface Name you'd like to update, and click on the Major version which is referred by your upgrade (e.g.: if you're updating from 1.2 to 1.3, you want to click on Major Version 1). The Editor will appear, populated with the currently installed Interface definition. Paste in your updated JSON file, or use the declarative editor to make your changes. The editor will be limited to Semantic Version-compatible operations (as in - adding new mappings). Once you're done, hit the &quot;Apply Changes&quot; button at the bottom of the declarative Editor (left side) to update the Interface in the Realm. Update an Interface using Realm Management API To update an existing interface, issue a PUT /interfaces/&lt;name&gt;/&lt;major&gt; endpoint of the realm with the very same semantics as the Installation procedure. The call will return either 201 Created or an error. Apart from the very same errors that could be triggered upon installation, Update will also fail if the interface doesn't provide a compatible upgrade path from the previously installed minor.","ref":"030-manage_interfaces.html#installing-updating-an-interface","title":"Managing Interfaces - Installing/Updating an interface","type":"extras"},{"doc":"Interfaces are versioned through a semantic versioning-like mechanism. A Realm can hold any number of interfaces and any number of major versions of a single interface. It holds, however, only the latest installed minor version of each major version, due to the inherent compatibility of Semantic Versioning. There is no significant cost in adding a non-aggregated interface to a Realm or updating a non-aggregated interface frequently - keep in mind, however, that you might incur in dangling data in your devices if you don't plan your interface update strategy accurately. For what concerns Aggregated interfaces, instead, there is an inherent cost which might end up in putting pressure on your Cluster . Once an interface has been installed in a Realm, it can't be uninstalled without performing manual operations on Astarte's DB, unless its major version number is 0 . This is a safety measure to prevent dangling data from appearing in the cluster. For this reason, when developing an Astarte-based interface, it is strongly advised to keep its major number to 0 to allow quick changes at the expense of data loss. Please note, however, that deleting a major 0 interface is possible if the Realm has no devices left declaring that specific interface in their introspection. This is done to avoid forever dangling data and potential consistency errors. This limitation might be lifted in the future through a mass-deletion mechanism, but there is no guarantee this will ever be done. It is advised to test new interfaces on a limited number of devices to ease operations.","ref":"030-manage_interfaces.html#interfaces-lifecycle","title":"Managing Interfaces - Interfaces lifecycle","type":"extras"},{"doc":"There is a clear difference between how Interfaces are managed in a Realm and its Devices (e.g.: the device Introspection). Whereas a Realm can have any number of versions of a single interface, a Device is allowed to expose in its introspection only a single, specific version of an Interface. In general, Realm interfaces are kept as a shared agreement between its entities, but when it comes to interacting with a Device, the Realm honors its introspection (as long as the Device declares interfaces the Realm is knowledgeable about). As such, installing an interface in a Realm is a completely safe and non-disruptive operation: by design, Devices aren't aware of which interfaces a Realm supports, and Realms don't impose any interface versioning on a Device.","ref":"030-manage_interfaces.html#realm-vs-device-interface-relationship","title":"Managing Interfaces - Realm vs. Device Interface relationship","type":"extras"},{"doc":"Due to how minor versions work, it is responsibility of the end user to prevent accidental data loss due to missing data. Every mapping declared in a new minor release must be assumed as optional, as there is no guarantee that a Device will be able to publish (or receive) data on that specific mapping. Minor version bumps work great in case they represents additional, optional features which might be available on an arbitrarly large subset of Devices implementing that interface's major version, and are not necessary or fundamental for normal operations. If that is not the case, consider a major version update or a whole new interface instead. Also, please keep in mind that designing interfaces in the right way, especially being as atomic as reasonably possible, helps a lot in preventing situations where a minor interface update can't be done without disrupting operations. Again, the Interface design guide covers this topic extensively.","ref":"030-manage_interfaces.html#caveats","title":"Managing Interfaces - Caveats","type":"extras"},{"doc":"In several situations, it is possible to have dangling data inside Astarte. This happens by design, as the liquid nature of a Device makes it possible for data to be stored in interfaces no longer present in its introspection. Astarte does not delete data unless requested explicitly: as such, data remains available inside its database, but potentially inaccessible through the cluster's APIs and standard mechanism. As of the current version, Astarte has no mechanism for retrieving and acting upon a device's dangling data - this is a limitation that will be lifted in future releases with additions to the current API. Interface major version change If a device upgrades one of its interfaces to a new major version, the previous interface is parked and its data remains dangling. Every API call, trigger, or reference to the interface will always target the major version declared in the introspection, regardless of the fact that a more recent version might have been installed in the realm. Interface deletion from device A device might arbitrarly decide to remove an interface from its introspection. In such a case, Astarte won't return any data and will consider all data previously pushed to said interface inaccessible. In case the interface comes back again in the introspection, previously pushed data will be available as if nothing happened.","ref":"030-manage_interfaces.html#dangling-data","title":"Managing Interfaces - Dangling data","type":"extras"},{"doc":"Registering a Device Devices are Astarte's main entities for exchanging data. Even though a Device usually represents the physical Device communicating with Astarte, they might as well be mapped to other entities, such as individual sensors or aggregated gateways. A Device always belongs to a Realm and is identified by a Device ID , which has to be unique at least within its Realm. Devices communicate with Astarte through Transports - in most installations, this means through an MQTT Broker (VerneMQ with Astarte's plugin). Before this happens, though, Devices must obtain credentials for accessing their Transport and, most of all, make themselves known to Astarte. This happens through the Registration process. In Astarte, Registering a device means obtaining an unique Credentials Secret (Registration Credentials), univocally associated to a Device ID, through a well-known workflow and pipeline. If you are not familiar with these concepts, please refer to Pairing Architecture to learn more about Pairing's workflow basics. The Credentials Secret can then be used by the Device for accessing Pairing API and getting information and Credentials for its Transport. As such, registration happens only once during a Device's lifecycle, and is a security-sensitive process. As such, this process is usually carried over (in production scenarios) through an Agent .","ref":"035-register_device.html","title":"Registering a Device","type":"extras"},{"doc":"An Agent 's purpose is to perform Registration on behalf of a Device. Agents should be the only components in your infrastructure with enough credentials to access Pairing's Agent APIs (as a rule of thumb, it is a bad idea to give access to Pairing API to anything which isn't an Agent). When setting up an Astarte project, it is fundamental to define beforehand how your Devices will be registered and hence where your Agent(s) will belong. There's two main ways for implementing an Agent, even though in production scenarios On Board Agents are strongly discouraged as they expose a single point of failure in terms of a Realm's whole fleet security. On Board Agent Please keep in mind that On Board Agents are not advised in production, as a single compromised device/token might compromise the Registration routine for your entire fleet. They should be used only in non-critical use cases or during testing and development. On Board Agents are provided as a feature by Astarte's SDK, and hide the detail of Device registration by integrating an Agent into the SDK itself. This allows to deliver the same credentials to each device belonging to a Realm. Of course, this also opens up a single point of failure in the whole fleet's security, as Credentials aren't tied to a specific device - as such, if compromised, they might allow an attacker to register an arbitrary device into a Realm, unless other policies prevent him from doing so. To create a On Board Agent, you simply need to emit a long-enough lived token from your Realm's private key with access to Pairing's Agent APIs . This token should then be delivered to your devices and provided to the SDK in order to carry over the Registration. The SDK will do this automatically and without any need for additional code, as long as you set the agentKey configuration key to a meaningful value, and no Credentials Secret has been set. 3rd Party Agent A more secure approach to the Registration process is having a 3rd Party agent. In such a case, an external component is in charge of requesting a Credentials Secret to Pairing and delivering it to the target Device. This approach has a number of benefits: in terms of Security, the Agent uses a short-lived token and can follow the Realm's authentication workflow just like any other application. For what concerns daily operations, the Agent can implement any arbitrary logic to make a decision on whether a Device should be registered or not. In such cases, Devices have an out-of-band communication mechanism with the Agent in which the Credentials are exchanged. Usually, these cases fall under two main categories: &quot;Local&quot; or &quot;Plant&quot; Agents In this scenario, devices are imprinted with their Credentials Secret in the production plant. The Device might not even be connected to the Internet, whereas the machine running the Agent has access to the target Astarte Cluster and adequate Credentials for Registration. Once the Agent acquires the Device ID of the Device which should be registered, it issues the request to Astarte's Pairing API and obtains the Device's Credentials Secret . At this stage, the Agent is in charge of delivering the Credentials Secret to the Device the way it sees fit. As a best practice, the Credentials Secret should then be saved to an OTP area or a dedicated secure storage in the device to prevent tampering or accidental loss. Even though this is arguably the most secure mechanism available for Registering a Device, it might not fit every use case as the Device will be irrevocabily assigned to a specific Astarte Cluster and a specific Realm in that Cluster before it even connects. &quot;Remote&quot; Agents If your use case demands more flexibility, Registering a Device in a plant might not fit your Device's lifecycle. This could be likely if, for example, Realm or Cluster assignment should be done dynamically once the Device reaches its final user. In this case, this role is usually delegated to an external web application acting as an Agent. In this case, it's up to the user setting up all mechanisms for delivering the Credentials Secret to the Device, which includes securing the communication channel. On the other hand, this allows an extremely flexible approach to Registration, which can be implemented through an entirely custom logic.","ref":"035-register_device.html#registration-agent","title":"Registering a Device - Registration Agent","type":"extras"},{"doc":"Credentials Secrets are meant to be immutable - as such, they should be handled with extreme care. Credentials Secrets are used only for interacting with Pairing, hence to obtain Credentials for a Transport which, on the other hand, are meant to be volatile. A Device can be Registered an arbitrary number of times before its Credentials Secret is used for the first time for interacting with Pairing. This is done to ensure the entire Registration process, including any kind of external custom logic of the Agents, has been carried over successfully, allowing a de-facto &quot;retry&quot; until there's certainty the Device has access to its Credentials Secret . Please note that when Registering a Device, a new Credentials Secret is generated every time.","ref":"035-register_device.html#credentials-secret-lifecycle","title":"Registering a Device - Credentials Secret Lifecycle","type":"extras"},{"doc":"Once the Credentials Secret is used for retrieving Credentials for a Transport for the first time, Astarte prevents further registration of the same Device again. If there's the need of registering the device again (e.g.: a Device has been tampered and got back to its plant with its previous Credentials Secret compromised), it is possible to explicitly unregister the device to obtain a new Credentials Secret using Pairing's Agent APIs or with astartectl (see the output of astartectl pairing agent unregister -h for more documentation).","ref":"035-register_device.html#unregistering-a-device","title":"Registering a Device - Unregistering a device","type":"extras"},{"doc":"Connecting a Device Once a Device has been Registered in Astarte, it is capable of connecting to it. Devices connect to Astarte through the use of Transports . A Transport is an arbitrary protocol implementation which maps Astarte's concepts (mainly Interfaces) to a communication channel. Astarte's main supported Transport is Astarte/MQTT, implemented on top of VerneMQ through an additional plugin , and it is used by Astarte's SDKs for communication. However, virtually any protocol can be integrated in Astarte by creating a corresponding Transport. Transports also define the authentication/authorization mechanism of their Devices. For instance, Astarte/MQTT uses mutual SSL Authentication with Certificate Rotation for securing its Ingress and identifying its clients. To manage their Transport(s) and Credentials, Devices have to interact with Pairing.","ref":"040-connect_device.html","title":"Connecting a Device","type":"extras"},{"doc":"Once a Device has performed its first registration through an Agent, it holds its Credentials Secret . This Credentials Secret is the token the device uses for performing the actual Pairing routine, which results in the device obtaining its Credentials for accessing its designated Transport. A Device's Credentials Secret allows access to Pairing API's Device REST API , which is then used for obtaining information about which Transports the Device can use for communicating, and for obtaining Credentials for its assigned Transports. The ability to request Credentials of a Device can be inhibited with AppEngine API or using astartectl with this command: astartectl appengine devices credentials inhibit &lt;device_id_or_alias&gt; true \\ -k &lt;appengine-key&gt; -r &lt;realm-name&gt; -u &lt;astarte-api-url&gt; Once its credentials_inhibited field is set to true , a Device is not able to request new Credentials. Note that Credentials that were already emitted will still be valid until their expiration. As, from a user's standpoint, the way a Device communicates with Astarte is entirely Transport-specific, this guide will cover using Astarte/MQTT through one of Astarte's SDKs. If you are using a different Transport, please refer to its User Guide, or if you wish to implement your own, head over to Transport Developer Documentation .","ref":"040-connect_device.html#credentials-secret-pairing-and-transports","title":"Connecting a Device - Credentials Secret, Pairing and Transports","type":"extras"},{"doc":"If you are using one of Astarte's SDK, the Pairing routine is entirely managed, and you won't need to do any of the aforementioned steps. Just make sure your Credentials Secret is passed as the apiKey configuration key, to allow the SDK to perform automatically the Pairing routine when needed. The SDK does a number of automated things under the hood. Its flow is: The SDK verifies if a SSL certificate for connecting to the broker is present. If it is, it attempts connecting to the Transport. If the Transport doesn't accept the connection due to an SSL error, it queries Pairing API about its certificate status. If Pairing API returns a problem with the certificate or, in general, the certificate isn't valid, the certificate is erased and the Pairing procedure begins. The SDK invokes Pairing API until it manages to obtain a valid Certificate for the Transport. The SDK considers a Device successfully paired when it has a valid certificate and manages to connect to the Transport. Once in this state, the Device can start exchanging data. Note: the Pairing procedure is secure as long as Pairing API is queried using HTTPS. Plain HTTP installations are vulnerable to a number of different attacks and should NEVER be used in production. Interfaces and Introspection A Device must have some installed interfaces to be capable of exchanging data. These interfaces must be made known to the SDK and installed in the Device's Realm, as previously explained . The SDK expects the user to provide a directory containing a set of valid interfaces. It then takes care of making Astarte aware of its registered interfaces through a process called Introspection. Introspection is a special control message in Astarte's protocol which makes Astarte aware of a list of Interfaces and relative versions which are installed on the Device. Again, Astarte's SDK, given a directory, is capable of performing the correct procedures for keeping Introspecting in sync correctly without any kind of user intervention. Astarte's SDK also takes care of updating a Device's Introspection if its interfaces change. Exchanging data When a Device connects successfully, it must then subscribe to its server Interfaces. The SDK takes care of this detail and exposes a higher level interface. For example, using the Qt5 SDK: { m_sdk = new AstarteDeviceSDK(QStringLiteral(&quot;/path/to/transport-astarte.conf&quot;), QStringLiteral(&quot;/path/to/interfaces&quot;), deviceId); connect(m_sdk-&gt;init(), &amp;Hemera::Operation::finished, this, &amp;AstarteStreamQt5Test::checkInitResult); connect(m_sdk, &amp;AstarteDeviceSDK::dataReceived, this, &amp;AstarteStreamQt5Test::handleIncomingData); } void AstarteStreamQt5Test::handleIncomingData(const QByteArray &amp;interface, const QByteArray &amp;path, const QVariant &amp;value) { qDebug() &lt;&lt; &quot;Received data, interface: &quot; &lt;&lt; interface &lt;&lt; &quot;path: &quot; &lt;&lt; path &lt;&lt; &quot;, value: &quot; &lt;&lt; value &lt;&lt; &quot;, Qt type name: &quot; &lt;&lt; value.typeName(); } Applications can simply connect to the handleIncomingData signal and have data correctly formatted and delivered as it runs through the transport. On the other hand, for sending data: m_sdk-&gt;sendData(interface, path, value); The SDK will check if data is coherent with its introspection, and send data onto the transport in the correct way. Reliability, retention and persistency in the SDK Astarte's SDK has an internal concept of persistency, depending on the behaviour defined in its installed Interfaces. The retention parameter, specifically, tells Astarte's SDK how hard it should try to send a specific message. In case the Transport is unreachable, the SDK might try to persist, either in memory or on disk, and send the message when the connection is available again. Please note that these parameters declared in Interfaces are to be considered on a best effort basis. In case your SDK does not support persistency or has persistency disabled, a number of warranties requested by an Interface might not be satisfied. Make sure your SDK is configured correctly before moving to production.","ref":"040-connect_device.html#using-astarte-mqtt-through-astarte-sdk","title":"Connecting a Device - Using Astarte/MQTT through Astarte SDK","type":"extras"},{"doc":"Querying a Device Once you have your devices connected, up and running in Astarte, you can start interacting with them.","ref":"050-query_device.html","title":"Querying a Device","type":"extras"},{"doc":"First things first, you can check if your device is correctly registered in Astarte, and its current status. Let's assume our Device has f0VMRgIBAQAAAAAAAAAAAA as its id. A Device's status includes a number of useful information, among which whether it is connected or not to its Transport, its introspection, the amount of exchanged data and more. Query Device status using astartectl $ astartectl appengine devices show f0VMRgIBAQAAAAAAAAAAAA Device ID: f0VMRgIBAQAAAAAAAAAAAA Connected: false Last Connection: 2018-02-07 18:38:57.266 +0000 UTC Last Disconnection: 2018-02-08 09:49:26.566 +0000 UTC Introspection: com.example.ExampleInterface v1.0 exchanged messages: 20 exchanged bytes: 200B org.example.TestInterface v0.2 exchanged messages: 8 exchanged bytes: 147B Received Messages: 221 Data Received: 11.7K Last Seen IP: 203.0.113.89 Last Credentials Request IP: 203.0.113.201 First Registration: 2018-01-31 17:10:59.270 +0000 UTC First Credentials Request: 2018-01-31 17:10:59.270 +0000 UTC Query Device status using Astarte Dashboard After logging in to Astarte dashboard, go to the &quot;Devices&quot; page clicking on the menu on your left. A list of available Device IDs will appear. If you do not see your device at a glance, use the search bar on the top right to find it. Clicking on the Device ID will take you to its details page. Query Device status using AppEngine API GET api.&lt;your astarte domain&gt;/appengine/v1/test/devices/f0VMRgIBAQAAAAAAAAAAAA { &quot;data&quot;: { &quot;total_received_msgs&quot;: 221, &quot;total_received_bytes&quot;: 11660, &quot;last_seen_ip&quot;: &quot;203.0.113.89&quot;, &quot;last_credentials_request_ip&quot;: &quot;203.0.113.201&quot;, &quot;last_disconnection&quot;: &quot;2018-02-07T18:38:57.266Z&quot;, &quot;last_connection&quot;: &quot;2018-02-08T09:49:26.556Z&quot;, &quot;id&quot;: &quot;f0VMRgIBAQAAAAAAAAAAAA&quot;, &quot;first_registration&quot;: &quot;2018-01-31T17:10:59.270Z&quot;, &quot;connected&quot;: true, &quot;introspection&quot;: { &quot;com.example.ExampleInterface&quot; : { &quot;major&quot; : 1, &quot;minor&quot; : 0, &quot;exchanged_msgs&quot;: 20, &quot;exchanged_bytes&quot;: 200 }, &quot;org.example.TestInterface&quot; : { &quot;major&quot; : 0, &quot;minor&quot; : 2, &quot;exchanged_msgs&quot;: 8, &quot;exchanged_bytes&quot;: 147 } }, &quot;aliases&quot;: { &quot;name&quot;: &quot;device_a&quot; }, &quot;groups&quot;: [ &quot;my_group&quot;, ], &quot;previous_interfaces&quot;: [ { &quot;name&quot;: &quot;com.example.ExampleInterface&quot;, &quot;major&quot; : 0, &quot;minor&quot; : 2, &quot;exchanged_msgs&quot;: 3, &quot;exchanged_bytes&quot;: 120 } ] } } Through the API, it is also possible to get the Introspection of the device only: GET api.&lt;your astarte domain&gt;/appengine/v1/test/devices/f0VMRgIBAQAAAAAAAAAAAA/interfaces { &quot;data&quot;: [ &quot;com.example.ExampleInterface&quot;, &quot;com.example.TestInterface&quot; ] } This returns the Interfaces which the device reported in its Introspection and which are known to the Realm.","ref":"050-query_device.html#device-status","title":"Querying a Device - Device status","type":"extras"},{"doc":"Depending on the aggregation and ownership of the Interface, you can GET / PUT / POST on the interface itself or one of its mappings, or use astartectl to perform the same operation on the command line. Some examples are: Get data from an aggregate device properties interface astartectl invocation: astartectl appengine devices data-snapshot f0VMRgIBAQAAAAAAAAAAAA com.example.ExampleInterface AppEngine API invocation: GET api.&lt;your astarte domain&gt;/appengine/v1/test/devices/f0VMRgIBAQAAAAAAAAAAAA/interfaces/com.example.ExampleInterface Get last sent value from an individual device datastream interface astartectl invocation: astartectl appengine devices data-snapshot f0VMRgIBAQAAAAAAAAAAAA com.example.TestInterface AppEngine API invocation: GET api.&lt;your astarte domain&gt;/appengine/v1/test/devices/f0VMRgIBAQAAAAAAAAAAAA/interfaces/com.example.TestInterface/myValue?limit=1 Set values in an individual server datastream interface astartectl invocation: astartectl appengine devices send-data f0VMRgIBAQAAAAAAAAAAAA com.example.OtherTestInterface /myOtherValue &lt;value&gt; AppEngine API invocation: POST api.&lt;your astarte domain&gt;/appengine/v1/test/devices/f0VMRgIBAQAAAAAAAAAAAA/interfaces/com.example.OtherTestInterface/myOtherValue Request body: {&quot;data&quot;: &lt;value&gt;} API Query semantics In general, to query AppEngine, the following things must be kept in mind When sending data, use PUT if dealing with properties , POST if dealing with datastream . When GET ting, if you are querying an aggregate interface, make sure to query the interface itself rather than its mappings. When GET ting datastream , keep in mind that AppEngine's default behavior is to return a large as possible timeseries.","ref":"050-query_device.html#interacting-with-device-data","title":"Querying a Device - Interacting with Device Data","type":"extras"},{"doc":"The Datastream case is significant, as it might be common to have a lot of values for each endpoint/interface. As such, returning all of them in a single API call is most of the times not desirable nor recommended. To avoid putting the cluster under excessive pressure, AppEngine API is configured with a hard cap on the maximum number of returned results for each single call, with a sane default of 10000 . Although this hard cap is entirely configurable, please be aware that AppEngine API is designed to process a lot of reasonably small requests in the shortest possible time, and hence is not optimised nor strongly tested against big requests . Make sure that AppEngine API has enough resources available to cope with the maximum dataset size. AppEngine API provides you with a variety of mechanisms to make retrieval and navigation of large data sets as smooth and efficient as possible. Limit Adding a limit=n to the URL query tells AppEngine to return no more than n results. This acts similarly to a LIMIT SQL statement, but, as it stands, it does not impose a hard limit on the whole retrieved dataset but on the amount of the results displayed by the API call - see Pagination and Time Windows for more details on this topic and the performance implications of different limits in queries. If the specified limit is beyond the hard cap, the query won't fail, but will return at most the amount set by the hard cap, without further warnings. Since/To/Since After Results can be limited to a specific time window. since and to can be set to a ISO 8601 valid timestamp to limit on an upper and lower bound the result set. This can also be combined with limit to make sure that no more than n results are returned. Also, since and to can as well be set independently to provide only an upper or lower bound. In case you're dealing with a very large dataset and you want to dump it, it is likely that you need to go beyond what a reasonable default limit looks like. In those cases, you can use the since_after query parameter to retrieve parameters within a time window. since_after slices the time window just like since does, but it does not include values matching the specified timestamp, if any. This is especially useful when paginating, to start right after a returned result. Pagination and time windows AppEngine API provides you automatically with a time window-based pagination. When GET ting a datastream , if more results are available beyond the chosen time window/limit, a links map will be provided, in JSON-API style, to allow the user to paginate the results accordingly using since_after . You can use limit to determine each page's size. When specifying a valid limit , the links will keep the page size consistent over the next calls. However, limit should be used wisely to lower the pressure on the cluster. Each API call maps to a query that, no matter how efficient, has a computational cost. A few mid-sized queries should always be preferred over a large amount of smaller queries. Given your cluster is configured correctly, limit should be omitted in most cases when paginating, and you should rather trust your cluster's hard cap to be the sweet spot in efficiency and cluster pressure. Downsampling Especially when plotting graphs, retrieving all points in a time series isn't desirable. Astarte provides you with an implementation of the LTTB Downsampling Algorithm , which is used to return only a fixed number of samples from a time series. When setting downsample_to=n , AppEngine will return a maximum of n results, which are the most significant over the considered time series according to the algorithm. Due to how LTTB works, downsample_to must be &gt;2 , as the algorithm will return the two ends of the considered value bucket, and n-2 values which are the picked samples. Please refer to the LTTB implementation used by Astarte to learn more about how this algorithm affects samples and its limitations. downsample_to=x can be used in conjunction with other query parameters, including limit=y . When doing so, Astarte will downsample to x samples the dataset composed of the last y values. Every feature previously outlined is in fact available with downsampling, including pagination - bear in mind, though, that for how the algorithm works, some options have drastically different semantic effects. Also, the hard cap has a very different meaning in downsampling. In this case, the hard cap applies to downsample_to instead of limit . limit can be an arbitrarly large amount of samples taken out of the DB, and can be used mainly to alleviate pressure in case of extremely large datasets which would require a lot of time for being processed by LTTB - even though, most of the time, you might want to define a time window to downsample instead. Astarte is also capable of downsampling aggregated interfaces, as long as a downsample_key is specified, which has to match the last token of an endpoint of the queried interface (i.e. in case the interface has a /%{id}/myValue mapping which should be used as the downsample_key , you should specify downsample_key=myValue in the query). When doing so, the aggregate will be downsampled using the chosen endpoint value as the y axis value, whereas its other endpoints will be disregarded when applying the algorithm. Please note that, no matter what downsample_key is used, a sample will be composed by the whole aggregation. If there is no way an interface can be downsampled (this is true, for example, if no downsample_key has been specified for aggregations , or for types such as strings ), AppEngine API will return a 4xx error. In general, downsampling is a powerful mechanism with a lot of limitations which really shines when plotting. Once again, this is a fundamental factor to consider when designing your interfaces .","ref":"050-query_device.html#navigating-and-retrieving-datastream-results-through-apis","title":"Querying a Device - Navigating and retrieving Datastream results through APIs","type":"extras"},{"doc":"astartectl implements some convenience methods that make navigation easier. In particular, astartectl allows for any of the AppEngine API query parameters/mechanisms, but also implements automated pagination, snapshots and more. Data Snapshot astartectl has a unique feature that allows to retrieve a &quot;Data Snapshot&quot; of a device, namely the last known value for every interface available in the Device's introspection. This is extremely useful to have an at-a-glance view of the Device status with regards to data. Simply invoke astartectl appengine devices data-snapshot &lt;device ID&gt; , or astartectl appengine devices data-snapshot &lt;device ID&gt; &lt;interface name&gt; to get a snapshot for a single interface. Advanced querying astartectl appengine devices get-samples is astartectl 's frontend to advanced query. Refer to the command line documentation to learn about all available parameters, which match all of the parameters found in AppEngine API. The main difference is that, in case a query would break the boundaries of the page limit, astartectl will automatically paginate the request, and return all of the samples. Exporting Devices Data with astartectl The previous feature makes astartectl extremely useful when it comes to export or dump data. Moreover, get-samples features a --output option, which allows to print the results in different formats, such as json or CSV . This way, exporting values becomes extremely easy, as get-samples can easily tap into an Interface's entire data set and print it into a CSV file.","ref":"050-query_device.html#astartectl-specific-features","title":"Querying a Device - astartectl-specific features","type":"extras"},{"doc":"Using Astarte Channels Especially when building Frontend applications, it is useful to receive real-time updates about data sent from Devices. Astarte leverages Phoenix Channels to provide such a thing over WebSockets in AppEngine API. WebSockets can be used natively from a Web Browser and follow the same authentication pattern as a standard HTTP call. Astarte Channels define a semantic on top of Phoenix Channels which allows read-only monitoring of device Interfaces. Authentication and Authorization over Channels happens in the very same way as AppEngine , and the a_ch claim in the token is respected when joining rooms and installing triggers. See Authentication and Authorization for more details on Auth semantics in Astarte.","ref":"052-using_channels.html","title":"Using Astarte Channels","type":"extras"},{"doc":"Rooms in Astarte Channels map 1:1 to Topics in Phoenix Channels, and can be joined in the very same way. Once a connection is established, the user can join any number of rooms, given he is authorized to do so . A Room is identified by a topic with the following semantics: rooms:&lt;realm&gt;:&lt;name&gt; . For example, rooms:test:myroom will join the Room myroom in the Realm test . A room can be joined by any number of concurrent users. Rooms serve as containers for Transient Triggers, which can be installed by any authorized user. Transient Triggers are actual Triggers , with the difference that they exist within a Channels Room rather than within a Realm - this mostly affects their timespan - and that the action can't be configured - every time a Condition is triggered a message is delivered to users in the Room, in a well-known format . Events Everytime a Condition of an installed Trigger is triggered, an event is sent to the Phoenix Channel, with a similar payload: { &quot;device_id&quot;: &quot;f0VMRgIBAQAAAAAAAAAAAA&quot;, &quot;event&quot;: { &quot;type&quot;: &quot;device_connected&quot;, &quot;device_ip_address&quot;: &quot;1.2.3.4&quot; } } device_id is always present (as long as the trigger matches a device) and identifies the device emitting the event. event , instead, depends on the kind of installed trigger. It always carries a type string, which identifies the content of the object. Currently, the documentation of every event's payload can be found in Astarte's protobuf files . However, there are some discrepancies in mapping (e.g.). It is advised also to have a look at the encoder . In the foreseeable future, more user friendly documentation will be provided. Lifecycle Once a room is created, it remains valid and active with all of its subscriptions. There's little overhead in having a large number of rooms, as the only components leeching resources are Transient Triggers. As of today, Transient Triggers never expire - it is responsibility of the user to clean them up once the room becomes empty, if needed. In future versions, Transient Triggers will likely expire after some time, if left in an empty room.","ref":"052-using_channels.html#rooms","title":"Using Astarte Channels - Rooms","type":"extras"},{"doc":"To install a Transient Trigger, one should issue a watch event in the Channel, given he is authorized to do so. The payload of such an event is identical to a Trigger definition, hence it looks like this: { &quot;name&quot;: &quot;datatrigger&quot;, &quot;device_id&quot;: &quot;f0VMRgIBAQAAAAAAAAAAAA&quot;, &quot;simple_trigger&quot;: { &quot;type&quot;: &quot;data_trigger&quot;, &quot;on&quot;: &quot;incoming_data&quot;, &quot;interface_name&quot;: &quot;org.astarte-platform.genericsensors.Values&quot;, &quot;interface_major&quot;: 0, &quot;match_path&quot;: &quot;/streamTest/value&quot;, &quot;value_match_operator&quot;: &quot;&gt;&quot;, &quot;known_value&quot;: 0.6 } } This installs in the Room a Transient Trigger which will trigger an event everytime a value higher than 0.6 is sent on the path /streamTest/value of the datastream interface org.astarte-platform.genericsensors.Values by the device f0VMRgIBAQAAAAAAAAAAAA , and will be received by every user currently in the room. If a user isn't in the room at the time of the event, he will not get it, and there's no way he can retrieve it if he joined at a later time. Triggers can be uninstalled by issuing an unwatch event in the Channel. The payload of the event should be the name of the trigger which should be uninstalled. Group Triggers Transient triggers can also target an Astarte group instead of a single device. To install a group volatile trigger, pass the group_name key in the JSON payload instead of the device_id key. For example, the trigger below is equivalent to the one in the previous section, but it targets all devices that are in the group mygroup . { &quot;name&quot;: &quot;groupdevicetrigger&quot;, &quot;group_name&quot;: &quot;mygroup&quot;, &quot;simple_trigger&quot;: { &quot;type&quot;: &quot;data_trigger&quot;, &quot;on&quot;: &quot;incoming_data&quot;, &quot;interface_name&quot;: &quot;org.astarte-platform.genericsensors.Values&quot;, &quot;interface_major&quot;: 0, &quot;match_path&quot;: &quot;/streamTest/value&quot;, &quot;value_match_operator&quot;: &quot;&gt;&quot;, &quot;known_value&quot;: 0.6 } } Note that the devices belonging to the group are evaluated when the trigger is installed, i.e. if a device is added to the group when the trigger is already installed, the trigger will not target the newly added device. The same goes for devices removed from the group, that will still be targeted by the trigger until it is removed.","ref":"052-using_channels.html#managing-transient-triggers","title":"Using Astarte Channels - Managing Transient Triggers","type":"extras"},{"doc":"Just like any other Astarte component, Authorization is encapsulated in a token claim, in particular the a_ch claim. However, the mechanism is rather different compared to a REST API, and uses different verbs. JOIN The JOIN verb implies that a user can join a room. This only allows him to receive events and to interact in a read-only fashion with the room itself. There is no restriction to which events a user sees - if he is authorized to enter in a room, he will be capable of seeing all events flowing in. More granular permissions can be done simply by creating more rooms in which different triggers will be installed. The JOIN verb has the following semantic: JOIN::&lt;regex&gt; , where regex matches a room name (the room name is what follows rooms:&lt;realm&gt;: - the realm is implicit in the context of the authorization token). For example, a user authorized with the JOIN::test.* claim in the test realm will be able to join, for example, rooms:test:testthis , rooms:test:testme , rooms:test:test . The realm is always implicit in the regex, as the token is authenticated in the context of a Realm. WATCH The WATCH verb allows a user to install a Trigger within a room. Its semantics define which kind of trigger, and upon which entities the user is allowed to act. Watch semantics are WATCH::&lt;regex&gt; , where regex is a regular expression which matches a device, path or interface (or a mixture of them) in almost very same fashion as the a_aea claim (which is used in AppEngine). Given different kind of triggers impact different Astarte entities, the Authorization claim implicitly defines which kind of triggers a user will be able to install. For example, f0VMRgIBAQAAAAAAAAAAAA/org.astarte-platform.genericsensors.Values.* will allow installing data triggers such as the one shown in the previous example, but won't let the user install device-wide triggers (such as connect/disconnect events). A claim such as f0VMRgIBAQAAAAAAAAAAAA or f0VMRgIBAQAAAAAAAAAAAA.* , instead, will allow device-level triggers to be installed.","ref":"052-using_channels.html#authorization","title":"Using Astarte Channels - Authorization","type":"extras"},{"doc":"Using Triggers Triggers allow receiving notifications when a device connects, disconnects or publishes specific data. More details on Triggers can be found in the Architecture Documentation . Astarte allows you to install and delete Triggers dynamically through its clients. Upon installation or deletion, changes to the Trigger infrastructure might take some time to propagate, and some devices might pick up changes at a later time. If a Trigger shows as installed, it will eventually be loaded.","ref":"060-using_triggers.html","title":"Using Triggers","type":"extras"},{"doc":"At any time, you can list existing Triggers in a Realm and fetch their details and definitions. Listing and querying Triggers using Astarte Dashboard After logging in, navigate to the Triggers page using the menu on the left. The list of Triggers installed in the Realm will be shown in the page. Clicking on a Trigger will open the Trigger editor in view-only mode, showing its definition on the right panel. Listing and querying Triggers using astartectl To list all existing Triggers in a Realm: $ astartectl realm-management triggers list [my_trigger other_trigger my_connection_trigger my_data_trigger] To get a Trigger definition: $ astartectl realm-management triggers show my_connection_trigger { &quot;name&quot;: &quot;my_connection_trigger&quot;, &quot;action&quot;: { &quot;http_post_url&quot;: &quot;&lt;post-url&gt;&quot; }, &quot;simple_triggers&quot;: [ { &quot;type&quot;: &quot;device_trigger&quot;, &quot;device_id&quot;: &quot;*&quot;, &quot;on&quot;: &quot;device_connected&quot; } ] } Listing and querying Triggers using Realm Management API To list all existing Triggers in a Realm: GET api.&lt;astarte base URL&gt;/realmmanagement/v1/&lt;realm name&gt;/triggers { &quot;data&quot;: [ &quot;my_trigger&quot;, &quot;other_trigger&quot;, &quot;my_connection_trigger&quot;, &quot;my_data_trigger&quot; ] } To get a Trigger definition: GET api.&lt;astarte base URL&gt;/realmmanagement/v1/&lt;realm name&gt;/triggers/my_connection_trigger { &quot;data&quot;: { &quot;name&quot;: &quot;my_connection_trigger&quot;, &quot;action&quot;: { &quot;http_post_url&quot;: &quot;&lt;post-url&gt;&quot; }, &quot;simple_triggers&quot;: [ { &quot;type&quot;: &quot;device_trigger&quot;, &quot;device_id&quot;: &quot;*&quot;, &quot;on&quot;: &quot;device_connected&quot; } ] } }","ref":"060-using_triggers.html#listing-triggers","title":"Using Triggers - Listing Triggers","type":"extras"},{"doc":"To install a Trigger, you need its JSON definition. If you have access to the Astarte Dashboard, you can use its Trigger Editor to build your JSON definition and install the Trigger directly. If you already have a JSON definition instead, you can either use astartectl or Realm Management APIs. The name of the Trigger must be unique within the Realm, or an error will be returned. Installing a Trigger using Astarte Dashboard After logging in, navigate to the Triggers page using the menu on the left. Click on &quot;Install a new Trigger...&quot; in the top-right corner. The Trigger Editor will open, and you can either paste/write a JSON definition, or use the declarative editor. When you are done, click on the &quot;Install Trigger&quot; button at the bottom of the declarative editor to install the Trigger in the Realm. Installing a Trigger using astartectl Assuming the Trigger definition is contained in my_connection_trigger.json , $ astartectl realm-management triggers install my_connection_trigger.json ok Installing a Trigger using Realm Management APIs POST api.&lt;astarte base URL&gt;/realmmanagement/v1/&lt;realm name&gt;/triggers The POST request must have the following request body, with content type application/json { &quot;data&quot;: { &quot;name&quot;: &quot;my_connection_trigger&quot;, &quot;action&quot;: { &quot;http_post_url&quot;: &quot;&lt;post-url&gt;&quot; }, &quot;simple_triggers&quot;: [ { &quot;type&quot;: &quot;device_trigger&quot;, &quot;device_id&quot;: &quot;*&quot;, &quot;on&quot;: &quot;device_connected&quot; } ] } }","ref":"060-using_triggers.html#installing-a-trigger","title":"Using Triggers - Installing a Trigger","type":"extras"},{"doc":"To delete a Trigger, you need to know its name. Just like when installing a Trigger, deleting a Trigger might not stop the data flow out of the Trigger immediately, which will eventually terminate at some point. Deleting a Trigger using Astarte Dashboard After logging in, navigate to the Triggers page using the menu on the left. Click on &quot;Install a new Trigger...&quot; in the top-right corner. Click on the Trigger name you want to delete. The Trigger Editor will open, and a &quot;Delete&quot; button will become available next to the Trigger name. Click on it to delete the Trigger. Deleting a Trigger using astartectl $ astartectl realm-management triggers delete my_connection_trigger ok Deleting a Trigger using Realm Management APIs DELETE api.&lt;astarte base URL&gt;/realmmanagement/v1/&lt;realm name&gt;/triggers/my_connection_trigger","ref":"060-using_triggers.html#deleting-a-trigger","title":"Using Triggers - Deleting a Trigger","type":"extras"},{"doc":"This section outlines two examples for the two main Trigger types (connection and data), and a sample payload for its HTTP Post URL action. Connection Trigger This trigger will send a POST request to &lt;post-url&gt; every time any device connects to its transport. This is the JSON representation of the trigger: { &quot;name&quot;: &quot;my_connection_trigger&quot;, &quot;action&quot;: { &quot;http_post_url&quot;: &quot;&lt;post-url&gt;&quot; }, &quot;simple_triggers&quot;: [ { &quot;type&quot;: &quot;device_trigger&quot;, &quot;device_id&quot;: &quot;*&quot;, &quot;on&quot;: &quot;device_connected&quot; } ] } If the Trigger is installed, when a device connects, &lt;post-url&gt; will receive the following JSON payload: { &quot;timestamp&quot;: &quot;&lt;timestamp&gt;&quot;, &quot;device_id&quot;: &quot;&lt;device_id&gt;&quot;, &quot;event&quot;: { &quot;type&quot;: &quot;device_connected&quot;, &quot;device_ip_address&quot;: &quot;&lt;device_ip_address&gt;&quot; } } Data Trigger This trigger will send a POST request to &lt;post-url&gt; every time a device sends data to the org.astarte-platform.genericsensors.Values major version 0 interface on the /streamTest/value path. This is the JSON representation of the trigger { &quot;name&quot;: &quot;my_data_trigger&quot;, &quot;action&quot;: { &quot;http_post_url&quot;: &quot;&lt;post-url&gt;&quot; }, &quot;simple_triggers&quot;: [ { &quot;type&quot;: &quot;data_trigger&quot;, &quot;on&quot;: &quot;incoming_data&quot;, &quot;interface_name&quot;: &quot;org.astarte-platform.genericsensors.Values&quot;, &quot;interface_major&quot;: 0, &quot;match_path&quot;: &quot;/streamTest/value&quot;, &quot;value_match_operator&quot;: &quot;*&quot; } ] } If the Trigger is installed, when a device sends data to the interface/path defined above, &lt;post-url&gt; will receive the following JSON payload: { &quot;timestamp&quot;: &quot;&lt;timestamp&gt;&quot;, &quot;device_id&quot;: &quot;&lt;device_id&gt;&quot;, &quot;event&quot;: { &quot;type&quot;: &quot;incoming_data&quot;, &quot;interface&quot;: &quot;org.astarte-platform.genericsensors.Values&quot;, &quot;path&quot;: &quot;/streamTest/value&quot;, &quot;value&quot;: &lt;value&gt; } }","ref":"060-using_triggers.html#trigger-examples","title":"Using Triggers - Trigger examples","type":"extras"},{"doc":"Managing Groups Devices can be divided in groups to provide group-specific access to the APIs. The examples below will use astartectl but you can achieve the same results using AppEngine API.","ref":"065-managing-groups.html","title":"Managing Groups","type":"extras"},{"doc":"Some prefixes are reserved for internal use. It's not possible to create groups with a name starting with the ~ and @ characters.","ref":"065-managing-groups.html#reserved-group-prefixes","title":"Managing Groups - Reserved group prefixes","type":"extras"},{"doc":"You can create a group with astartectl with this command astartectl appengine groups create mygroup &lt;device_identifier&gt;,&lt;device_identifier&gt; device_identifier can be a Device ID or an Alias, and you can put multiple devices by separating them with a comma. You can check the group was created by listing groups in your realm astartectl appengine groups list","ref":"065-managing-groups.html#creating-a-group","title":"Managing Groups - Creating a group","type":"extras"},{"doc":"Once you created a group, you can add or remove devices from it. To add a device, use: astartectl appengine groups devices add &lt;device_identifier&gt; To remove a device, use: astartectl appengine groups devices remove &lt;device_identifier&gt; Keep in mind that a group exists as long as it has at least one device in it, so if you remove the last device from a group, the group will cease to exist. You can always check which devices are in a group with: astartectl appengine groups devices list","ref":"065-managing-groups.html#adding-or-removing-a-device-to-from-a-group","title":"Managing Groups - Adding or removing a device to/from a group","type":"extras"},{"doc":"Once a device is in a group, you can access to its data on this URL: https://&lt;astarte-api&gt;/appengine/v1/groups/&lt;group_name&gt;/devices/&lt;device_id&gt; The hierarchy is exactly the same that is found under https://&lt;astarte-api&gt;/appengine/v1/devices/&lt;device-id&gt; which is documented here , but this makes it possible to emit a JWT that only allows access to devices belonging to a specific group.","ref":"065-managing-groups.html#accessing-devices-in-a-group-with-astarte-appengine-api","title":"Managing Groups - Accessing Devices in a group with Astarte AppEngine API","type":"extras"},{"doc":"Connect 3rd party applications","ref":"070-connect_application.html","title":"Connect 3rd party applications","type":"extras"},{"doc":"Using Astarte's Grafana Datasource","ref":"080-grafana_datasource.html","title":"Using Astarte's Grafana Datasource","type":"extras"},{"doc":"Troubleshooting","ref":"090-troubleshooting.html","title":"Troubleshooting","type":"extras"},{"doc":"Devices cannot connect to Astarte There might be some network issues or network misconfiguration Devices need a working network connection in order to communicate with Astarte. There might be some temporary network issues, or any network setting or appliance might not be properly configured. Make sure that devices are allowed to make outbound connections on ports 443 (https) and any port the transport needs for accepting connections from devices. For Astarte/VerneMQ, this defaults to 8883 (MQTT over SSL), but might also be configured otherwise. SSL issues Devices need to be able to connect to Astarte using SSL. Make sure that the clock has been synched to avoid certificate issue/expiry date errors, make also sure to have all the root CAs up to date. Device gets disconnected from Astarte Some interfaces might be missing When a device reports an interface that Astarte doesn't have, it gets disconnected when the introspection is published. Make sure that all device interfaces have been previously installed on Astarte. Make also sure that interface name and major exactly matches installed version. Device is publishing unexpected or malformed data When a device sends invalid, malformed or unexpected data it gets disconnected, make sure that the device is sending valid data. An interface mismatch might be the most common reason for this kind of issues. e.g. the interface has been declared device owned on the device, and astarte owned on astarte. Make sure to use exactly the same JSON file on both ends.","ref":"090-troubleshooting.html#devices","title":"Troubleshooting - Devices","type":"extras"},{"doc":"Triggers are not executed Triggers have not been loaded yet Triggers might take some time before being loaded for devices that have been recently connected, make sure to wait some time before the triggers cache is populated again. If you are on a hurry make sure to test a trigger on a device that has not been recently connected yet.","ref":"090-troubleshooting.html#triggers","title":"Troubleshooting - Triggers","type":"extras"},{"doc":"Introduction This documentation page describes a discontinued version, for production systems use a newer version instead. This guide is meant for System Administrators who need to deal with Astarte clusters installation, maintenance and upgrade. The guide will cover prerequisites, installation in different supported environments, and common maintenance operations. Before you begin, it is fundamental you are familiar with Astarte's architecture, design and concepts , especially for what concerns its components and 3rd party services.","ref":"001-intro_administrator.html","title":"Introduction","type":"extras"},{"doc":"System Requirements Astarte is a Native Kubernetes application, and as such Kubernetes is a hard requirement. It is possible to run Astarte outside Kubernetes, although a number of features won't be available - these setups are outside the scope of this document.","ref":"010-system_requirements.html","title":"System Requirements","type":"extras"},{"doc":"Astarte requires at least Kubernetes 1.12 - however, it currently targets Kubernetes 1.16+. It is advised to consult Astarte Operator's compatibility matrix in the README to ensure a specific Kubernetes setup is supported. The Astarte Operator does not require any unstable feature gate in Kubernetes 1.16, and is actively tested against KinD and major Managed Kubernetes installations on various Cloud Providers.","ref":"010-system_requirements.html#kubernetes-requirements","title":"System Requirements - Kubernetes Requirements","type":"extras"},{"doc":"Depending on the kind of setup, Astarte might require different resource configurations when it comes to nodes. astartectl takes care of this with the profiles features, which inspects the Cluster and provides a set of ready made configurations for the Cluster. Besides this, Astarte requires a minimum of 3 physical nodes in case one is planning on a redundant setup.","ref":"010-system_requirements.html#resource-requirements","title":"System Requirements - Resource Requirements","type":"extras"},{"doc":"Prerequisites As much as Astarte's Operator is capable of creating a completely self-contained installation, there's a number of prerequisites to be fulfilled depending on the use case.","ref":"020-prerequisites.html","title":"Prerequisites","type":"extras"},{"doc":"In your local machine, you'll need two main tools: kubectl and astartectl . Ensure you have a kubectl version matching your target Kubernetes cluster version, and a recent astartectl version.","ref":"020-prerequisites.html#on-your-machine","title":"Prerequisites - On your machine","type":"extras"},{"doc":"Astarte currently features only one Managed Ingress, based on Voyager . Voyager provides routing, SSL termination and more, and as of today is the preferred/advised way to run Astarte in production. Astarte Operator is capable of interacting with Voyager through its dedicated AstarteVoyagerIngress resource, as long as the Voyager Operator is installed. Installing Voyager Operator is outside the scope of this guide, and you should refer to Voyager's documentation . You don't need to create Voyager ingresses yourself - just the Operator itself is enough.","ref":"020-prerequisites.html#voyager","title":"Prerequisites - Voyager","type":"extras"},{"doc":"In production deployments, it is strongly advised to have a separate Cassandra cluster interacting with the Kubernetes installation. This is due to the fact that Cassandra Administration is a critical topic, especially with mission critical workloads. Astarte Operator includes only basic management of Cassandra, and as such it should not be relied upon when dealing with production environments. In case an external Cassandra cluster is deployed, be aware that Astarte lives on the assumption it will be the only application managing the Cluster - as such, it is strongly advised to have a dedicated cluster for Astarte.","ref":"020-prerequisites.html#external-cassandra","title":"Prerequisites - External Cassandra","type":"extras"},{"doc":"When deploying external components, it is important to take in consideration how Kubernetes behaves with the underlying infrastructure. Most modern Cloud Providers have a concept of Virtual Private Cloud, by which the internal Kubernetes Network stack directly integrates with their Network stack. This, in short, enables deploying Pods in a shared private network, in which other components (such as Virtual Machines) can be deployed. This is the preferred, advised and supported configuration. In this scenario, there's literally no difference between interacting with a VM or a Pod, enabling a hybrid infrastructure without having to pay the performance cost.","ref":"020-prerequisites.html#kubernetes-and-external-components","title":"Prerequisites - Kubernetes and external components","type":"extras"},{"doc":"Installing Astarte Operator Operator installation is usually intermediated by astartectl , through the astartectl cluster subcommand. astartectl cluster manages the entire lifecycle of Astarte within a single Kubernetes Cluster, with regards of both the Operator and the Astarte instance(s) that will be deployed in the Cluster.","ref":"030-installation_kubernetes.html","title":"Installing Astarte Operator","type":"extras"},{"doc":"Installing the Operator is as simple as astartectl cluster install-operator This command will take care of installing all needed components for the Operator to run. This includes all the RBAC roles, Custom Resource Definitions, and the Operator itself. The --version switch allows to specify a version to install - when not specified, the latest version will be installed instead.","ref":"030-installation_kubernetes.html#installation","title":"Installing Astarte Operator - Installation","type":"extras"},{"doc":"To upgrade the Operator, use the dedicated upgrade-operator command. astartectl cluster upgrade-operator Just like the install-operator command, the --version switch allows to specify the version to upgrade to - when not specified, the latest version will be fetched and used.","ref":"030-installation_kubernetes.html#upgrading-the-operator","title":"Installing Astarte Operator - Upgrading the Operator","type":"extras"},{"doc":"To uninstall the Operator, use the dedicated uninstall-operator command. astartectl cluster uninstall-operator This command will refuse to execute if any Astarte instances are active in the Cluster. Uninstalling the Operator is possible only after all managed instances have been deleted too. When uninstalling the Operator, all resources installed with install-operator will be erased completely.","ref":"030-installation_kubernetes.html#uninstalling-the-operator","title":"Installing Astarte Operator - Uninstalling the Operator","type":"extras"},{"doc":"Manual Operator Installation In case you do not want to use astartectl to manage the Operator, this guide will run you through all the steps needed to set up Astarte Kubernetes without any external tool but kubectl . Note: Please be aware that this method is to be used only if you have very specific reasons why not to use astartectl , for example: you're running a fork of the Operator, you're running the Operator outside of the cluster, or you're on the very bleeding edge. astartectl automates internally all of this guide and should be your main choice in production.","ref":"040-manual_kubernetes.html","title":"Manual Operator Installation","type":"extras"},{"doc":"First of all, you will need to clone the Operator repository, as this is where some of the needed resources for the Operator are. Ensure you're cloning the right branch for the Operator Version you'd like to install. For example, if you want to Deploy an Operator in the 0.11 series, you would git clone -b v0.11.4 https://github.com/astarte-platform/astarte-kubernetes-operator.git","ref":"040-manual_kubernetes.html#clone-the-operator-repository","title":"Manual Operator Installation - Clone the Operator Repository","type":"extras"},{"doc":"The Operator requires a number of RBAC roles to run, and will also require Astarte CRDs to be installed. Navigate into the deploy directory of your local clone, and install the service account: kubectl apply -f service_account.yaml kubectl get ServiceAccount -n kube-system astarte-operator Then, install the Cluster Role kubectl apply -f role.yaml kubectl get ClusterRole astarte-operator Last but not least, install the Cluster Role Binding: kubectl apply -f role_binding.yaml kubectl get ClusterRoleBinding astarte-operator Once done, navigate into the deploy/crds directory of your local clone, and install all Astarte Custom Resource Definitions: kubectl create -f api.astarte-platform.org_astartes_crd.yaml kubectl create -f api.astarte-platform.org_astartevoyageringresses_crd.yaml kubectl get CustomResourceDefinition Caveats for Astarte CRDs Astarte CRDs are automatically generated and embed the OpenAPIv3 schema of the Custom Resource. For this reason, they're quite big in size. For this reason, using kubectl apply on these resources will always fail, as the annotations generated by kubectl would be beyond Kubernetes' character limit for annotations. To work around this, you should always install CRDs with kubectl create and update them with kubectl replace .","ref":"040-manual_kubernetes.html#install-rbacs-and-crds","title":"Manual Operator Installation - Install RBACs and CRDs","type":"extras"},{"doc":"Navigate into the deploy directory of your local clone. The Operator Deployment template can be found in operator.yaml . At this time, you might want to tweak the Deployment - especially for what concerns the image tag. Once you're ready to go, apply the Deployment to your Kubernetes cluster, and wait until it becomes ready. kubectl apply - f operator . yaml kubectl get deployment - n kube - system astarte - operator","ref":"040-manual_kubernetes.html#running-the-operator-inside-the-cluster","title":"Manual Operator Installation - Running the Operator inside the Cluster","type":"extras"},{"doc":"Note: Running the operator outside the cluster is not advised in production. Usually, you need such a deployment if you plan on developing the Operator itself. However, this scenario is tested in the e2e tests, and as such provides the very same features of the in-cluster Deployment, which remains the go-to scenario for production. To run the Operator outside the cluster, you will need the operator-sdk command line. Please refer to operator-sdk installation guide to install it. Also, please make sure that the version of operator-sdk matches or is compatible with the version of the operator-sdk module in the Operator's go.mod file. Navigate to the root directory of your clone, and run operator-sdk run --local This will bring up the Operator and connect it to your current Kubernetes context. Caveats When running the Operator locally, you're bound to a single namespace, and to all limitations of operator-sdk run . This is out of the scope of this guide, and you should be confident with operator-sdk 's User Guide if you plan on running the Operator outside the Cluster.","ref":"040-manual_kubernetes.html#running-the-operator-outside-the-cluster","title":"Manual Operator Installation - Running the Operator outside the Cluster","type":"extras"},{"doc":"Setting up the Cluster Once the Astarte Operator has been installed , and any prerequisite has been fulfilled , you can move forward and deploy an Astarte Cluster.","ref":"060-setup_cluster.html","title":"Setting up the Cluster","type":"extras"},{"doc":"You can use astartectl to deploy an instance through the astartectl cluster instances deploy command. This is an interactive command that will inspect your cluster and provide you with a set of profiles that can be deployed. When you choose a Profile, you will be prompted with a number of questions that will be needed to configure your instance correctly. Upon completion, astartectl will prepare and execute the deployment automatically.","ref":"060-setup_cluster.html#using-astartectl","title":"Setting up the Cluster - Using astartectl","type":"extras"},{"doc":"In astartectl , profiles allow for easy scaling, enhanced management, and automated upgrade upon release series without any action on behalf of the user. They're the way to go if you plan on having a standard, managed installation. astartectl comes packed with a set of default profiles, but you can write your own ones. Profiles can be either written as Go resources, or (in a much easier fashion) as yaml resources. You can have a look at the Profiles schema here . Writing your own profile This guide will be extended in the future, as more recent versions of astartectl will support loading yaml profiles.","ref":"060-setup_cluster.html#astartectl-profiles","title":"Setting up the Cluster - astartectl Profiles","type":"extras"},{"doc":"If you do not want to use astartectl or Profiles, you can create your own Astarte Custom Resource. This gives you a higher degree of customization, allowing you to tweak any single parameter in the Astarte setup. The main Astarte CRD contains extensive documentation on the available fields in OpenAPIv3 format. Just create your Astarte Custom Resource, which will look something like this: apiVersion: api.astarte-platform.org/v1alpha1 kind: Astarte metadata: name: example-minimal namespace: astarte spec: # This is the most minimal set of reasonable configuration to spin up an Astarte # instance with reasonable defaults and enough control over the deployment. version: 0.11.4 api: host: &quot;api.astarte.yourdomain.com&quot; # MANDATORY rabbitmq: resources: requests: cpu: 300m memory: 512M limits: cpu: 1 memory: 1000M cassandra: maxHeapSize: 1024M heapNewSize: 256M storage: size: 30Gi resources: requests: cpu: 1 memory: 1024M limits: cpu: 2 memory: 2048M vernemq: host: &quot;broker.astarte.yourdomain.com&quot; resources: requests: cpu: 200m memory: 1024M limits: cpu: 1000m memory: 2048M cfssl: resources: requests: cpu: 100m memory: 128M limits: cpu: 200m memory: 256M storage: size: 2Gi components: # Global resource allocation. Automatically allocates resources to components weighted in a # reasonable way. resources: requests: cpu: 1200m memory: 3072M limits: cpu: 3000m memory: 6144M You can simply apply this resource in your Kubernetes cluster with kubectl apply -f . The Operator will take over from there.","ref":"060-setup_cluster.html#using-a-standard-astarte-cr","title":"Setting up the Cluster - Using a standard Astarte CR","type":"extras"},{"doc":"Setting up the Ingress Once your Cluster is up and running , to expose it to the outer world you need to set up an Ingress. Currently, the only managed and supported Ingress is based upon Voyager , and this guide will cover only this specific case. Of course, ensure you have installed Voyager Operator before you begin.","ref":"065-setup_ingress.html","title":"Setting up the Ingress","type":"extras"},{"doc":"Most information needed for exposing your Ingress have already been given in your main Astarte resource. If your Kubernetes installation supports LoadBalancer ingresses (most managed ones do), you should be able to get away with the most standard CR: apiVersion: api.astarte-platform.org/v1alpha1 kind: AstarteVoyagerIngress metadata: name: example-minimal namespace: astarte spec: # The Astarte Instance the Ingress will be attached to astarte: example-minimal api: exposeHousekeeping: true dashboard: ssl: true host: &quot;dashboard.astarte.yourdomain.com&quot; # When not specified, dashboard will be deployed in /dashboard in the API host. letsencrypt: use: true acmeEmail: info@yourdomain.com challengeProvider: dns: provider: digitalocean credentialSecretName: voyager-digitalocean As you might see, there's only one very important thing to be noted: the astarte field must reference the name of an existing Astarte installation in the same namespace, and the Ingress will be configured and attached to that instance.","ref":"065-setup_ingress.html#creating-an-astartevoyageringress","title":"Setting up the Ingress - Creating an AstarteVoyagerIngress","type":"extras"},{"doc":"Astarte heavily requires SSL in a number of interactions, even though this can be bypassed with ssl: false . If you do not have any SSL Certificates for your domains, you can leverage Voyager's Let's Encrypt integration. AstarteVoyagerIngress integrates directly with Voyager's native types, and you can follow along Voyager's Let's Encrypt guide . Simply set letsencrypt.use to true , and fill the challengeProvider with the right parameters.","ref":"065-setup_ingress.html#ssl-and-certificates","title":"Setting up the Ingress - SSL and Certificates","type":"extras"},{"doc":"AstarteVoyagerIngress deploys a well-known tree of APIs to the host you specified in the main Astarte resource. In particular, assuming your API host was api.astarte.yourdomain.com : Housekeeping API base URL will be https://api.astarte.yourdomain.com/housekeeping/v1 Realm Management API base URL will be https://api.astarte.yourdomain.com/realmmanagement/v1 Pairing API base URL will be https://api.astarte.yourdomain.com/pairing/v1 AppEngine API base URL will be https://api.astarte.yourdomain.com/appengine/v1","ref":"065-setup_ingress.html#api-paths","title":"Setting up the Ingress - API Paths","type":"extras"},{"doc":"AstarteVoyagerIngress has a number of advanced options that can be used to accommodate needs of the most diverse deployments. Consult the CRD Documentation to learn more.","ref":"065-setup_ingress.html#further-customization","title":"Setting up the Ingress - Further customization","type":"extras"},{"doc":"Managing Realms Once the Cluster is set up, you can start managing it by creating Realms.","ref":"070-manage_realms.html","title":"Managing Realms","type":"extras"},{"doc":"When creating a new Cluster, Astarte Operator also creates a brand new keypair and stores it in the cluster. To retrieve it (assuming you deployed an instance named astarte in namespace astarte ): kubectl get secret -n astarte astarte-housekeeping-private-key -o=jsonpath={.data.private-key} | base64 -d &gt; housekeeping.key You can then use housekeeping.key to authenticate against Housekeeping API.","ref":"070-manage_realms.html#accessing-housekeeping-key","title":"Managing Realms - Accessing Housekeeping key","type":"extras"},{"doc":"This guide is not yet complete, as this part is a moving target within astartectl . Please refer to the API Documentation to manage Realms manually once here.","ref":"070-manage_realms.html#work-in-progress","title":"Managing Realms - Work in progress","type":"extras"},{"doc":"Upgrading the Cluster Upgrading an Astarte Cluster is meant to be a completely managed operation, as the Operator encapsulates all the needed logic for a clean Upgrade. Manual Upgrades are not supported and out of the scope of this guide - if you're maintaining a non-operator installation, you will need to understand all the manual steps for Upgrade for each Astarte component, which are explained in Release notes. However, the only supported mean of Upgrade remains the Operator.","ref":"080-upgrade_guide.html","title":"Upgrading the Cluster","type":"extras"},{"doc":"astartectl features an astartectl cluster instances upgrade command which can upgrade both astartectl and non- astartectl Managed Installations alike. When using a Profile, though, the upgrade procedure will also script any changes to the CR the profile carries over among versions (if needed), ensuring that the process is smooth enough. To upgrade, run astartectl cluster instances upgrade &lt;instance name&gt; You can optionally add an Astarte version as the second parameter - otherwise, astartectl will try to upgrade to the latest stable release. astartectl will interactively prompt you a number of questions depending on the operation, and will start the upgrade procedure. Please note that depending on the upgrade, the operation might require a downtime.","ref":"080-upgrade_guide.html#upgrading-through-astartectl","title":"Upgrading the Cluster - Upgrading through astartectl","type":"extras"},{"doc":"If you do not want to use astartectl , you will need to upgrade by modifying the CR manually. Usually, this boils down to bumping the version field in the spec - however, you should read all release notes carefully to know if any other changes to the CR are required. Once you apply the changes to the Resource, the Operator will take over and perform the Upgrade.","ref":"080-upgrade_guide.html#upgrading-by-modifying-the-cr","title":"Upgrading the Cluster - Upgrading by modifying the CR","type":"extras"},{"doc":"Monitoring Astarte is a complex, distributed system that may pose several challenges when deployed in production. Individual services report health and metrics to ensure production clusters can be properly monitored and proactive actions can be taken in case of faults or unexpected behavior.","ref":"090-monitoring.html","title":"Monitoring","type":"extras"},{"doc":"Every Astarte service, whether it's an API service or not, exposes an HTTP endpoint /health , without versioning, on its HTTP port. By default, services use port 4000 . /health is meant to be called frequently and reports the individual health state of a service. It will return 200 in case the service is healthy, or other errors in case the service is having issues. Among those issues, there might be failure in accessing RabbitMQ/RPC communications or failure in accessing the Database. Health checks and Kubernetes The aforementioned health checks are integrated in Kubernetes, when using Astarte Operator, as LivenessProbe and ReadinessProbe . As such, health monitoring and forced restarts are automatically handled without the need for the administrator to integrate any additional logic.","ref":"090-monitoring.html#health-checks","title":"Monitoring - Health checks","type":"extras"},{"doc":"Just like /health , every service exposes a /metrics endpoint. This endpoint exposes a series of metrics in Prometheus format, which can be easily integrated and queried from any Prometheus-compatible monitoring solution. Each service, besides exposing stats on its Erlang VM, resource consumption and HTTP stats (where applicable), also exposes a number of service-specific metric, which can be queried to obtain information about Astarte's usage and behavior. Authentication and access to metrics /metrics , being Prometheus-compatible, does not implement any kind of authentication or access control. Ideally, only your scraper should have access to /metrics , as it can leak sensitive information and should not be exposed to the outer world. Astarte Operator, by default, forbids access to /metrics through its ingress, as it assumes your scraper lives within the Kubernetes cluster or has means to access the cluster on its own. However, this behavior can be overridden through by setting serveMetrics: true in the api section. An additional parameter, serveMetricsToSubnet , can be specified to restrict access to /metrics only to source IPs in a specific subnet. It is strongly recommended to set this up in case an external scraper needs to have access to /metrics , to ensure access is restricted.","ref":"090-monitoring.html#service-metrics","title":"Monitoring - Service metrics","type":"extras"},{"doc":"Advanced operations This section provides guides to perform some operations that have to be perfomed manually since they could result in data loss or other type of irrecoverable damage. Always be careful while performing these operations","ref":"095-advanced-operations.html","title":"Advanced operations","type":"extras"},{"doc":"Right now, Astarte only allows deleting draft interfaces, i.e. interfaces with major version 0 and not used by any device. If you want to delete an interface that already has published data, you must proceed manually with the steps described below. In this guide we're going to assume that you're trying to delete the org.astarte-platform.genericsensors.Values interface in the test realm. The guide requires that you have cqlsh connected to the Cassandra/ScyllaDB instance that your Astarte instance is using. Switch to the target keyspace The keyspace has the same name of the realm, in our case it's test cqlsh &gt; use test ; Find out the interface id cqlsh :test &gt; SELECT interface_id FROM interfaces WHERE name = &#39;org.astarte-platform.genericsensors.Values&#39; AND major_version = 1 ; cqlsh will reply with the interface id interface_id -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- c238b244 - b90f - 4 c6d - f276 - 25768 bf6abac Delete the interface WARNING: This is a destructive step that will erase the correlation between the Interface name and internal ID. Before proceeding, ensure you saved the interface ID, or you will end up with dangling data. Further steps in this guide will require the interface ID. To delete the interface, cqlsh :test &gt; DELETE FROM interfaces WHERE name = &#39;org.astarte-platform.genericsensors.Values&#39; AND major_version = 1 ; Keep in mind that after this step, all existing devices that try to publish on this interface will be disconnected as soon as they try to do so. Delete interface data The interface data is stored in a different place depending on the interface type ( datastream or properties ) and aggregation. Individual datastream interfaces store their data in the individual_datastreams table. Individual properties interfaces store their data in the individual_properties table. Object datastream interfaces store their data in a dedicated table which is created starting from the interface (e.g. an interface called com.test.Sensors with major version 1 creates a com_test_sensors_v1 table in the realm keyspace). To delete data from object datastreams, you just need to DROP the table where the data is stored. Deleting data from individual interfaces requires more steps. In this example the interface is an individual datastream, but the procedure for individual properties is the same, but using the individual_properties table instead. To delete the interface data, first you have to find all the relevant primary keys cqlsh :test &gt; SELECT DISTINCT device_id , interface_id , endpoint_id , path FROM individual_datastreams WHERE interface_id = c238b244 - b90f - 4 c6d - f276 - 25768 bf6abac ALLOW FILTERING ; This will return a set of primary keys of data belonging to that interface device_id | interface_id | endpoint_id | path -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- | -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- | -- -- -- -- -- -- - 41 c1c072 - d416 - 4686 - ba23 - 673 fe4ad926f | c238b244 - b90f - 4 c6d - f276 - 25768 bf6abac | 33751412 - 3 e77 - ad1f - ad57 - 280 cc9fad581 | / test / value 81 c60277 - 4645 - 441 f - a49b - 66 a71ce54b83 | c238b244 - b90f - 4 c6d - f276 - 25768 bf6abac | 33751412 - 3 e77 - ad1f - ad57 - 280 cc9fad581 | / foo / value ... After that, you have to delete all the data belonging to those primary keys cqlsh :test &gt; DELETE FROM individual_datastreams WHERE device_id = 41 c1c072 - d416 - 4686 - ba23 - 673 fe4ad926f AND interface_id = c238b244 - b90f - 4 c6d - f276 - 25768 bf6abac AND endpoint_id = 33751412 - 3 e77 - ad1f - ad57 - 280 cc9fad581 AND path = &#39;/test/value&#39; ; cqlsh :test &gt; DELETE FROM individual_datastreams WHERE device_id = 81 c60277 - 4645 - 441 f - a49b - 66 a71ce54b83 AND interface_id = c238b244 - b90f - 4 c6d - f276 - 25768 bf6abac AND endpoint_id = 33751412 - 3 e77 - ad1f - ad57 - 280 cc9fad581 AND path = &#39;/foo/value&#39; ; ... devices-by-interface cleanup If you're using this guide to remove an draft interface (i.e. with major version 0 ) that can't be deleted since it has data on it, an additional step is required for a complete cleanup. The information about which devices are using draft interfaces is kept in the kv_store table. You can inspect the groups with cqlsh :test &gt; SELECT group FROM kv_store ; Inspecting the returned group s, you can easily identify which group has to be deleted, since it's the one with its name derived from the interface name. For example, if you're trying to remove all data from the org.astarte-platform.genericevents.DeviceEvents v0.1 interface, the corresponding group in kv_store will be devices-by-interface-org.astarte-platform.genericevents.DeviceEvents-v0 . After you identify the group, just remove all its entries with cqlsh :test &gt; DELETE FROM kv_store WHERE group = &#39;devices-by-interface-org.astarte-platform.genericevents.DeviceEvents-v0&#39; ; Conclusion After you end performing all the steps above, the interface will be completely removed from Astarte. You can then proceed to install a new interface with the same name and major version without any conflict. Remember to remove the interface also on the device side, otherwise devices will keep getting disconnected if they try to publish on the deleted interface.","ref":"095-advanced-operations.html#manual-deletion-of-interfaces","title":"Advanced operations - Manual deletion of interfaces","type":"extras"},{"doc":"Astarte in 5 minutes This documentation page describes a discontinued version, for production systems use a newer version instead. This tutorial will guide you through bringing up your Astarte instance, creating a realm and streaming your first data from a device simulator (or a real device) before your cup of tea is ready.","ref":"010-astarte_in_5_minutes.html","title":"Astarte in 5 minutes","type":"extras"},{"doc":"First of all, please keep in mind that this setup is not meant to be used in production : by default, no persistence is involved, the installation does not have any recovery mechanism, and you will have to restart services manually in case something goes awry. This guide is great if you want to take Astarte for a spin, or if you want to use an isolated instance for development. You will need a machine with at least 4GB of RAM, a recent 64-bit operating system with Docker , Docker Compose and astartectl installed. If you don't have astartectl installed on your machine yet, you should install it by following the instructions in astartectl's README Also, on the machine(s) or device(s) you will use as a client, you will need either Docker, or a Qt5 installation with development components if you wish to build and run components locally. Due to ScyllaDB requirements, if you're working on a Linux machine you should make sure that aio-max-nr is at least 1048576 : cat /proc/sys/fs/aio-max-nr 1048576 If it's less than that, you'll need to edit your /etc/sysctl.conf file fs . aio - max - nr = 1048576 and to persist this configuration sudo sysctl -p","ref":"010-astarte_in_5_minutes.html#before-you-begin","title":"Astarte in 5 minutes - Before you begin","type":"extras"},{"doc":"Docker version &gt;= 19 is recommended: $ docker -v Docker version 19.03.8 Docker compose version &gt;= 1.17 is recommended: $ docker-compose -v docker compose version 1.17.1, build unknown astartectl 0.11.x is recommended: $ astartectl version astartectl 0.11.0 This procedure has been tested on several systems, and is validated and maintained against Ubuntu 18.04 and macOS 10.15 Catalina, but any other modern operating system should work.","ref":"010-astarte_in_5_minutes.html#checking-prerequistes","title":"Astarte in 5 minutes - Checking prerequistes","type":"extras"},{"doc":"To get our Astarte instance running as fast as possible, we will install Astarte's standalone distribution. It includes a tunable Docker Compose which brings up Astarte and every companion service needed for it to work. To do so, simply clone Astarte's main repository and use its scripts to bring it up: $ git clone https://github.com/astarte-platform/astarte.git -b v0.11.4 &amp;&amp; cd astarte $ docker run -v $(pwd)/compose:/compose astarte/docker-compose-initializer:0.11.4 $ docker-compose up -d docker-compose-initializer will generate a root CA for devices, a key pair for Housekeeping, and a self-signed certificate for the broker (note: this is a really bad idea in production). You can tune the compose file further to use legitimate certificates and custom keys, but this is out of the scope of this tutorial. Compose might take some time to bring everything up, but usually within a minute from the containers creation Astarte will be ready. Compose will forward the following ports to your machine: 4000 : Realm Management API 4001 : Housekeeping API 4002 : AppEngine API 4003 : Pairing API 8883 : MQTTS 1885 : MQTT with Proxy Protocol for SSL termination (won't be used) 80 : Let's Encrypt verification (won't be used) This example won't use Let's Encrypt with VerneMQ - in case binding to port 80 is a problem to you, you can comment it out in docker-compose.yml without affecting any functionality. To check everything went fine, use docker ps to verify relevant containers are up: Astarte itself, VerneMQ, PostgreSQL (used by CFSSL), CFSSL, RabbitMQ and ScyllaDB should be now running on your system. If any of them isn't up and running, docker ps -a should show it stopped or failed. In those cases, it is advised to issue docker-compose up -d again to fix potential temporary failures.","ref":"010-astarte_in_5_minutes.html#install-astarte","title":"Astarte in 5 minutes - Install Astarte","type":"extras"},{"doc":"Now that we have our instance up and running, we can start setting up a Realm for our device. We'll call our Realm test . Given we have no SSO or Authentication mechanism set up, we're just going to generate a public key to sign our JWTs with. You can create one with astartectl : $ astartectl utils gen-keypair test Also, we will need a JWT token to authenticate against Housekeeping. generate-compose-files.sh created a keypair automatically, which is in compose/astarte-keys/housekeeping_{private,public}.pem . To perform all of our Astarte interactions, we will use astartectl . Use astartectl to create a new Realm: $ astartectl housekeeping realms create test --housekeeping-url http://localhost:4001/ -p test_public.pem -k compose/astarte-keys/housekeeping_private.pem This creates a test realm, which should be ready to be used almost immediately. To ensure your realm is available and ready, check if it exists in Astarte by issuing: $ astartectl housekeeping realms ls --housekeeping-url http://localhost:4001/ -k compose/astarte-keys/housekeeping_private.pem","ref":"010-astarte_in_5_minutes.html#create-a-realm","title":"Astarte in 5 minutes - Create a Realm","type":"extras"},{"doc":"We will use Astarte's Qt5 Stream Generator to feed data into Astarte. However before starting, we will have to install org.astarte-platform.genericsensors.Values interface into our new realm. To do that, we can use astartectl again: $ astartectl realm-management interfaces install standard-interfaces/org.astarte-platform.genericsensors.Values.json --realm-management-url http://localhost:4000/ -r test -k test_private.pem Now org.astarte-platform.genericsensors.Values should show up among our available interfaces: $ astartectl realm-management interfaces ls --realm-management-url http://localhost:4000/ -r test -k test_private.pem Our Astarte instance is now ready for our devices.","ref":"010-astarte_in_5_minutes.html#install-an-interface","title":"Astarte in 5 minutes - Install an interface","type":"extras"},{"doc":"We will also test Astarte's push capabilities with a trigger. This will send a POST to a URL of our choice every time the value generated by stream_test is above 0.6. Due to how triggers work, it is fundamental to install the trigger before a device connects. Doing otherwise will cause the trigger to kick in at a later time, and as such no events will be streamed for a while. Replace $TRIGGER_TARGET_URL with your target URL in the example below, you can use a Postbin service like Mailgun Postbin to generate a URL and see the POST requests. The resulting trigger would be: { &quot;name&quot;: &quot;my_trigger&quot;, &quot;action&quot;: { &quot;http_post_url&quot;: &quot;$TRIGGER_TARGET_URL&quot; }, &quot;simple_triggers&quot;: [ { &quot;type&quot;: &quot;data_trigger&quot;, &quot;on&quot;: &quot;incoming_data&quot;, &quot;interface_name&quot;: &quot;org.astarte-platform.genericsensors.Values&quot;, &quot;interface_major&quot;: 0, &quot;match_path&quot;: &quot;/streamTest/value&quot;, &quot;value_match_operator&quot;: &quot;&gt;&quot;, &quot;known_value&quot;: 0.6 } ] } Replace $TRIGGER_TARGET_URL with the URL your Trigger will target. Assuming you saved this as my_trigger.json , you can now install it through astartectl : $ astartectl realm-management triggers install my_trigger.json --realm-management-url http://localhost:4000/ -r test -k test_private.pem You can now check that your trigger is correctly installed: $ astartectl realm-management triggers ls --realm-management-url http://localhost:4000/ -r test -k test_private.pem","ref":"010-astarte_in_5_minutes.html#install-a-trigger","title":"Astarte in 5 minutes - Install a trigger","type":"extras"},{"doc":"If you already have an Astarte compliant device, you can configure it and connect it straight away, and it will just work with your new installation - provided you skip SSL checks on the broker's certificate. If you don't, you can use Astarte's stream-qt5-test to emulate an Astarte device and generate a datastream . You can do this either on the same machine where you are running Astarte, or from another machine or device on the same network. Depending on what your client supports, you can either compile stream-qt5-test (this will take some more time), or you can use a ready to use Docker container to launch it. Docker is the easiest and painless way, but this guide will cover both methods. Using a container for stream-qt5-test Astarte's stream-qt5-test can be pulled from Docker Hub with: $ docker pull astarte/astarte-stream-qt5-test:0.11.4 Its most basic invocation (from your astarte repository tree) is: $ docker run --net=&quot;host&quot; -e &quot;DEVICE_ID=$(astartectl utils device-id generate-random)&quot; -e &quot;PAIRING_HOST=http://localhost:4003&quot; -e &quot;REALM=test&quot; -e &quot;AGENT_KEY=$(astartectl utils gen-jwt pairing -k test_private.pem)&quot; -e &quot;IGNORE_SSL_ERRORS=true&quot; astarte/astarte-stream-qt5-test:0.11.4 This will generate a random datastream from a brand new, random Device ID. You can tweak those parameters to whatever suits you better by having a look at the Dockerfile. You can spawn any number of instances you like, or you can have the same Device ID send longer streams of data by saving the container's persistency through a Docker Volume. If you wish to do so, simply add -v /persistency:&lt;your persistency path&gt; to your docker run invocation. Refer to stream-qt5-test README for more details on which variables can be passed to the container. Also, please note that the --net=&quot;host&quot; parameter is required to make localhost work. If this is not desirable, you can change PAIRING_HOST to an host reachable from within the container network. Obviously, that parameter isn't required if you're running the container on a different machine and PAIRING_HOST is pointing to a different URL.","ref":"010-astarte_in_5_minutes.html#stream-data","title":"Astarte in 5 minutes - Stream data","type":"extras"},{"doc":"If your target platform does not support running containers, you can build stream-qt5-test from source. To do so, you will have to compile both Astarte Qt5 SDK and Astarte Qt5 Stream Test. Their main dependencies are cmake , qtbase , mosquitto and openssl . If you're on a Debian derivative, you can install them all with: # apt-get install qt5-default qtbase5-dev libqt5sql5-sqlite libssl-dev libmosquittopp-dev cmake git build-essential Once your dependencies are installed, compile your components: $ git clone https://github.com/astarte-platform/astarte-device-sdk-qt5.git -b v0.11.4 $ cd astarte-device-sdk-qt5 $ mkdir build $ cd build $ cmake -DCMAKE_INSTALL_PREFIX=/usr .. $ make $ make install $ cd - $ git clone https://github.com/astarte-platform/stream-qt5-test.git -b v0.11.4 $ cd stream-qt5-test $ qmake . $ make You can now run stream-qt5-test from your last build directory. Refer to its README (or to its sources) to learn about how to use it and which options are available.","ref":"010-astarte_in_5_minutes.html#building-stream-qt5-test-from-source","title":"Astarte in 5 minutes - Building stream-qt5-test from source","type":"extras"},{"doc":"Congratulations! Your devices or fake devices are now communicating with Astarte, and your tea should be ready by now. You can check if everything is working out by invoking AppEngine APIs to get some values. In case you are using stream-qt5-test , you can get the last sent value with astartectl : $ astartectl appengine devices get-samples &lt;your device id&gt; org.astarte-platform.genericsensors.Values /streamTest/value --count 1 --appengine-url http://localhost:4002 -r test -k test_private.pem If you get a meaningful value, congratulations - you have a working Astarte installation with your first datastream coming in! Moreover, Astarte's Docker Compose also installs Astarte Dashboard , from which you can manage your Realms and install Triggers, Interfaces and more from a Web UI. It is accessible by default at http://localhost:4040/ - remember that if you are not exposing Astarte from localhost , you have to change Realm Management API's URL in Dashboard's configuration file, to be found in compose/astarte-dashboard/config.json in Astarte's repository. You can generate a token for Astarte Dashboard, as usual, through astartectl utils gen-jwt all-realm-apis -k test_private.pem . By default, astartectl will generate a token valid for 8 hours, but you can set a specific expiration by using the -e &lt;seconds&gt; parameter. From here on, you can use all of Astarte's APIs and features from your own installation. You can add devices, experiment with interfaces, or develop your own applications on top of Astarte's triggers or AppEngine's APIs. And have a lot of fun!","ref":"010-astarte_in_5_minutes.html#grab-your-tea","title":"Astarte in 5 minutes - Grab your tea","type":"extras"},{"doc":"When you're done with your tests and developments, you can use docker-compose again to tear down your Astarte instance simply by issuing: $ docker-compose down Unless you add the -v option, persistencies will be kept and next time you will docker-compose up the cluster will come back in the very same state you left it last time. docker-compose down -v is extremely useful during development, especially if you want a clean slate for testing your applications or your routines every time.","ref":"010-astarte_in_5_minutes.html#cleaning-up","title":"Astarte in 5 minutes - Cleaning up","type":"extras"},{"doc":"Running Astarte through docker-compose is the fastest way for going from zero to hero. However, please keep in mind this setup is unlikely to hold for long in production, and is by design broken for large installations . We can't stop you from running such a thing in production, but do so as long as you know you voided your warranty by doing so. This method is great for development and for trying out the system. If you wish to deploy Astarte in a more robust environment, have a look at Astarte Enterprise or, if you want to go the DIY way, make sure that at least every service which requires persistency has reliable storage and adequate redundancy beneath it.","ref":"010-astarte_in_5_minutes.html#final-notes","title":"Astarte in 5 minutes - Final notes","type":"extras"},{"doc":"Introduction This documentation page describes a discontinued version, for production systems use a newer version instead. Astarte's APIs are documented through Swagger . Your Astarte installation probably already has Swagger UI support, which serves as the reference for your installed APIs. To browse API documentation online, follow this link .","ref":"001-intro_api.html","title":"Introduction","type":"extras"}]