<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="ExDoc v0.29.0">
    <meta name="project" content="Clea Astarte v1.2.0">

    <title>Interfaces — Clea Astarte v1.2.0</title>
    <link rel="stylesheet" href="dist/html-elixir-2YOS5DIE.css" />

    <script src="dist/handlebars.runtime-NWIB6V2M.js"></script>
    <script src="dist/handlebars.templates-X7YVL3G2.js"></script>
    <script src="dist/sidebar_items-C9FC9F15.js"></script>

      <script src="../common_vars.js"></script>

    <script async src="dist/html-XN2TSG4M.js"></script>


  </head>
  <body data-type="extras" class="page-extra">
    <script>

      try {
        var settings = JSON.parse(localStorage.getItem('ex_doc:settings') || '{}');

        if (settings.theme === 'dark' ||
           ((settings.theme === 'system' || settings.theme == null) &&
             window.matchMedia('(prefers-color-scheme: dark)').matches)
           ) {
          document.body.classList.add('dark')
        }
      } catch (error) { }
    </script>

<div class="main">

<button class="sidebar-button sidebar-toggle" aria-label="toggle sidebar">
  <i class="ri-menu-line ri-lg" title="Collapse/expand sidebar"></i>
</button>

<section class="sidebar">
  <form class="sidebar-search" action="search.html">
    <button type="submit" class="search-button" aria-label="Submit Search">
      <i class="ri-search-2-line" aria-hidden="true" title="Submit search"></i>
    </button>
    <button type="button" tabindex="-1" class="search-close-button" aria-label="Cancel Search">
      <i class="ri-close-line ri-lg" aria-hidden="true" title="Cancel search"></i>
    </button>
    <label class="search-label">
      <p class="sr-only">Search</p>
      <input name="q" type="text" class="search-input" placeholder="Search..." aria-label="Input your search terms" autocomplete="off" />
    </label>
  </form>

  <div class="autocomplete">
    <div class="autocomplete-results">
    </div>
  </div>

  <div class="sidebar-header">

      <a href="https://docs.astarte-platform.org/astarte/1.0/">
        <img src="assets/logo.png" alt="Clea Astarte" class="sidebar-projectImage">
      </a>

    <div class="sidebar-projectDetails">
      <a href="https://docs.astarte-platform.org/astarte/1.0/" class="sidebar-projectName" translate="no">
Clea Astarte
      </a>
      <strong class="sidebar-projectVersion" translate="no">
        v1.2.0
      </strong>
    </div>
    <ul class="sidebar-listNav">
      <li><a id="extras-list-link" href="#full-list">Pages</a></li>


    </ul>
  </div>

  <div class="gradient"></div>
  <ul id="full-list" class="sidebar-fullList"></ul>
</section>

<section class="content">
  <output role="status" id="toast"></output>
  <div class="content-outer">
    <div id="content" class="content-inner">

<h1>
<button class="settings display-settings">
  <i class="ri-settings-3-line"></i>
  <span class="sr-only">Settings</span>
</button>


    <a href="https://github.com/astarte-platform/astarte/blob/release-1.0/doc/pages/architecture/030-interface.md#L1" title="View Source" class="view-source" rel="help">
      <i class="ri-code-s-slash-line" aria-hidden="true"></i>
      <span class="sr-only">View Source</span>
    </a>

  <span>Interfaces</span>
</h1>

<p>Interfaces are a core concept of Astarte which defines how data is exchanged between Astarte and its
peers. They are not to be intended as OOP interfaces, but rather as the following definition:</p><blockquote><p>In computing, an interface is a shared boundary across which two or more separate components of a
computer system exchange information.</p></blockquote><p>In Astarte each interface has an owner, can represent either a continuous data stream or a snapshot
of a set of properties, and can be either aggregated into an object or be an independent set of
individual members.</p><p>If you are already familiar with interface's basic concepts, you might want to jump directly to the
<a href="040-interface_schema.html">Interface Schema</a>.</p><h2 id="versioning" class="section-heading">
  <a href="#versioning" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">versioning</p>
  </a>
  Versioning
</h2>
<p>Interfaces are versioned, each interface having both a major version and a minor
version number. The concept behind these two version numbers mimics <a href="http://semver.org/">Semantic
Versioning</a>: arbitrary changes can happen exclusively between different major
versions (e.g. removing members, changing types, etc...), whereas minor versions allow incremental
additive changes only (e.g. adding members).</p><p>Several different major versions of the same interface can coexist at the same time in Astarte,
although a Device can hold only a single version of an interface at a time (even though interfaces
can be updated over time). Interfaces, internally, are univocally identified by their name and their
major version.</p><h2 id="format" class="section-heading">
  <a href="#format" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">format</p>
  </a>
  Format
</h2>
<p>Interfaces are described using a JSON document. Each interface is identified by an unique
interface name of maximum 128 characters, which must be a <a href="https://en.wikipedia.org/wiki/Reverse_domain_name_notation">Reverse Domain
Name</a>. As a convention, the interface
name usually contains its author's URI Reverse Internet Domain Name.</p><p>An example skeleton looks like this:</p><pre><code class="makeup json" translate="no"><span class="p" data-group-id="2446332409-1">{</span><span class="w">
    </span><span class="nt">&quot;interface_name&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;com.test.MyInterfaceName&quot;</span><span class="p">,</span><span class="w">
    </span><span class="nt">&quot;version_major&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
    </span><span class="nt">&quot;version_minor&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="2446332409-2">[</span><span class="err">.</span><span class="err">.</span><span class="err">.</span><span class="p" data-group-id="2446332409-2">]</span><span class="w">
</span><span class="p" data-group-id="2446332409-1">}</span></code></pre><p>Valid values and variables are listed in the <a href="040-interface_schema.html">Interface Schema</a>.</p><h3 id="name-limitations" class="section-heading">
  <a href="#name-limitations" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">name-limitations</p>
  </a>
  Name limitations
</h3>
<p>A valid interface name consists of a Reverse Domain Name containing alphanumeric characters, hyphens
and dots. By design, both the top level domain and last domain component cannot contain hyphens,
although hypens are allowed in other parts of the interface name (e.g.: <code class="inline">org.astarte-platform.Values</code>
is a valid interface name).</p><p>Interface names have to be fully-defined Reverse Domain Names. <code class="inline">Values</code> will not be accepted as an
Astarte interface name, whereas <code class="inline">org.astarte-platform.Values</code> is a valid one.</p><p>Interface's uniqueness is also case insensitive. This means you cannot install two interfaces with the
same name and different casing (e.g.: <code class="inline">org.astarte-platform.MyValues</code> and <code class="inline">org.astarte-platform.Myvalues</code>).
This also applies to Major versioning: interfaces sharing the same name, even with a different major
version, cannot have different casing.</p><p>Although not enforced, naming conventions for Astarte Interfaces require lowercasing for anything but
the last part of the Interface name, which should be CamelCase.</p><p>Examples of names following conventions are:</p><ul><li><code class="inline">org.astarte-platform.ValidInterfaceName</code></li><li><code class="inline">org.astarte-platform.conventions.satisfied.ValidInterfaceName</code></li><li><code class="inline">org.astarte-platform.conventions-satisfied.ValidInterfaceName</code></li></ul><p>While examples of names not following conventions are:</p><ul><li><code class="inline">org.astarte-platform.validInterfaceName</code></li><li><code class="inline">org.astarte-platform.Conventions.NotSatisfied.ValidInterfaceName</code></li><li><code class="inline">org.astarte-platform.Conventions.not-satisfied.ValidInterfaceName</code></li></ul><h2 id="interface-type" class="section-heading">
  <a href="#interface-type" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">interface-type</p>
  </a>
  Interface Type
</h2>
<p>Interfaces have a well-known, predefined type, which can be either <code class="inline">property</code> or
<code class="inline">datastream</code>. Every Device in Astarte can have any number of interfaces of any different types.</p><h3 id="datastream" class="section-heading">
  <a href="#datastream" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">datastream</p>
  </a>
  Datastream
</h3>
<p><code class="inline">datastream</code> represents a mutable, ordered stream of data, with no concept of
persistent state or synchronization. As a rule of thumb, <code class="inline">datastream</code> interfaces should be used when
dealing with values such as sensor samples, commands and events. <code class="inline">datastream</code> are stored as time
series in the database, making them suitable for time span filtering and any other common time
series operation, but they are <em>not</em> idempotent in the REST API semantics.</p><p>Due to their nature, <code class="inline">datastream</code> interfaces have a number of <a href="#datastream-specific-features">additional
properties</a> which fine tune their behavior.</p><h3 id="properties" class="section-heading">
  <a href="#properties" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">properties</p>
  </a>
  Properties
</h3>
<p><code class="inline">properties</code> represent a persistent, stateful, synchronized state with no concept of
history or timestamping. <code class="inline">properties</code> are useful, for example, when dealing with settings, states or
policies/rules. <code class="inline">properties</code> are stored in a key-value fashion, and grouped according to their
interface, and they are idempotent in the REST API semantics. Rather than being able to act on a
stream like in the <code class="inline">datastream</code> case, <code class="inline">properties</code> can be retrieved, or can be used as a
<a href="060-triggers.html">trigger</a> whenever they change.</p><p>Values in a <code class="inline">properties</code> interface can be unset (or deleted according to the http jargon): to allow
such a thing, the interface must have its <code class="inline">allow_unset</code> property set to <code class="inline">true</code>. Please <a href="040-interface_schema.html">refer to the
JSON Schema</a> for further details.</p><h2 id="ownership" class="section-heading">
  <a href="#ownership" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">ownership</p>
  </a>
  Ownership
</h2>
<p>Astarte's design mandates that each interface has an owner. The owner of an interface
has a write-only access to it, whereas other actors have read-only access. Interface <strong>ownership</strong>
can be either <code class="inline">device</code> or <code class="inline">server</code>: the owner is the actor producing the data, whereas the other
actor consumes data.</p><h2 id="mappings" class="section-heading">
  <a href="#mappings" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">mappings</p>
  </a>
  Mappings
</h2>
<p>Every interface must have an array of mappings. Mappings are designed around REST
controller semantics: each mapping describes an endpoint which is resolved to a path, it is strongly
typed, and can have additional options. Just like in REST controllers, Endpoints can be parametrized
to build REST-like collection and trees. Parameters are identified by <code class="inline">%{parameterName}</code>, with each
endpoint supporting any number of parameters (see <a href="#limitations">Limitations</a>).</p><p>This is how a parametrized mapping looks like:</p><pre><code class="makeup json" translate="no"><span class="w">    </span><span class="p" data-group-id="2129475604-1">[</span><span class="err">.</span><span class="err">.</span><span class="err">.</span><span class="p" data-group-id="2129475604-1">]</span><span class="w">
    </span><span class="nt">&quot;mappings&quot;</span><span class="p">:</span><span class="w"> </span><span class="err">[</span><span class="w">
        </span><span class="p" data-group-id="2129475604-2">{</span><span class="w">
            </span><span class="nt">&quot;endpoint&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/%{itemIndex}/value&quot;</span><span class="p">,</span><span class="w">
            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;integer&quot;</span><span class="p">,</span><span class="w">
            </span><span class="nt">&quot;reliability&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;unique&quot;</span><span class="p">,</span><span class="w">
            </span><span class="nt">&quot;retention&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;discard&quot;</span><span class="w">
        </span><span class="p" data-group-id="2129475604-2">}</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="2129475604-3">[</span><span class="err">.</span><span class="err">.</span><span class="err">.</span><span class="p" data-group-id="2129475604-3">]</span></code></pre><p>In this example, <code class="inline">/0/value</code>, <code class="inline">/1/value</code> or <code class="inline">/test/value</code> all map to a valid endpoint, while
<code class="inline">/te/st/value</code> can't be resolved by any endpoint.</p><h3 id="supported-data-types" class="section-heading">
  <a href="#supported-data-types" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">supported-data-types</p>
  </a>
  Supported data types
</h3>
<p>The following types are supported:</p><ul><li><code class="inline">double</code>: A double-precision floating-point number as specified by binary64, by the IEEE 754
standard (NaNs and other non numerical values are not supported).</li><li><code class="inline">integer</code>: A signed 32 bit integer.</li><li><code class="inline">boolean</code>: Either <code class="inline">true</code> or <code class="inline">false</code>, adhering to JSON boolean type.</li><li><code class="inline">longinteger</code>: A signed 64 bit integer (please note that <code class="inline">longinteger</code> is represented as a string
by default in JSON-based APIs.).</li><li><code class="inline">string</code>: An UTF-8 string, at most 65536 bytes long.</li><li><code class="inline">binaryblob</code>: An arbitrary sequence of any byte that should be shorter than 64 KiB. (<code class="inline">binaryblob</code>
is represented as a base64 string by default in JSON-based APIs.).</li><li><code class="inline">datetime</code>: A UTC timestamp, internally represented as milliseconds since 1st Jan 1970 using a
signed 64 bits integer. (<code class="inline">datetime</code> is represented as an ISO 8601 string by default in JSON based
APIs.)</li><li><code class="inline">doublearray</code>, <code class="inline">integerarray</code>, <code class="inline">booleanarray</code>, <code class="inline">longintegerarray</code>, <code class="inline">stringarray</code>,
<code class="inline">binaryblobarray</code>, <code class="inline">datetimearray</code>: A list of values, represented as a JSON Array. Arrays can have
up to 1024 items and each item must respect the limits of its scalar type (<em>i.e.</em> each string in a
<code class="inline">stringarray</code> must be at most 65535 bytes long, each binary blob in a <code class="inline">binaryblobarray</code> must be
shorter than 64 KiB.</li></ul><p>Make sure that the differences between two distinct interface names are not limited to the casing or
the presence of hyphens. This situation leads to a collision in the interface names which brings to
an error in the interface installation process.</p><h3 id="limitations" class="section-heading">
  <a href="#limitations" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">limitations</p>
  </a>
  Limitations
</h3>
<p>A valid interface must resolve a path univocally to a single endpoint. Take the following example:</p><pre><code class="makeup json" translate="no"><span class="w">    </span><span class="p" data-group-id="1421413954-1">[</span><span class="err">.</span><span class="err">.</span><span class="err">.</span><span class="p" data-group-id="1421413954-1">]</span><span class="w">
    </span><span class="nt">&quot;mappings&quot;</span><span class="p">:</span><span class="w"> </span><span class="err">[</span><span class="w">
        </span><span class="p" data-group-id="1421413954-2">{</span><span class="w">
            </span><span class="nt">&quot;endpoint&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/%{itemIndex}/value&quot;</span><span class="p">,</span><span class="w">
            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;integer&quot;</span><span class="w">
        </span><span class="p" data-group-id="1421413954-2">}</span><span class="p">,</span><span class="w">
        </span><span class="p" data-group-id="1421413954-3">{</span><span class="w">
            </span><span class="nt">&quot;endpoint&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/myPath/value&quot;</span><span class="p">,</span><span class="w">
            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;integer&quot;</span><span class="w">
        </span><span class="p" data-group-id="1421413954-3">}</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="1421413954-4">[</span><span class="err">.</span><span class="err">.</span><span class="err">.</span><span class="p" data-group-id="1421413954-4">]</span></code></pre><p>In such a case, the interface isn't valid and is
rejected, due to the fact that path <code class="inline">/myPath/value</code> is ambiguous and could be resolved to two
different endpoints.</p><p>Any endpoint configuration must not generate paths that are prefix of other paths, for this reason
the following example is also invalid:</p><pre><code class="makeup json" translate="no"><span class="w">    </span><span class="p" data-group-id="2090531861-1">[</span><span class="err">.</span><span class="err">.</span><span class="err">.</span><span class="p" data-group-id="2090531861-1">]</span><span class="w">
    </span><span class="nt">&quot;mappings&quot;</span><span class="p">:</span><span class="w"> </span><span class="err">[</span><span class="w">
        </span><span class="p" data-group-id="2090531861-2">{</span><span class="w">
            </span><span class="nt">&quot;endpoint&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/some/thing&quot;</span><span class="p">,</span><span class="w">
            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="s2">&quot;integer&quot;</span><span class="w">
        </span><span class="p" data-group-id="2090531861-2">}</span><span class="p">,</span><span class="w">
        </span><span class="p" data-group-id="2090531861-3">{</span><span class="w">
            </span><span class="nt">&quot;endpoint&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/some/%{param}/value&quot;</span><span class="p">,</span><span class="w">
            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;integer&quot;</span><span class="w">
        </span><span class="p" data-group-id="2090531861-3">}</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="2090531861-4">[</span><span class="err">.</span><span class="err">.</span><span class="err">.</span><span class="p" data-group-id="2090531861-4">]</span><span class="w">
</span></code></pre><p>In case the interface's aggregation is <code class="inline">object</code>, additional restrictions apply. Endpoints in the
same interface must all have the same depth, and the same number of parameters. If the interface is
parametrized, every endpoint must have the same parameter name at the same level. This is an example
of a valid aggregated interface mapping:</p><pre><code class="makeup json" translate="no"><span class="w">    </span><span class="p" data-group-id="8630987676-1">[</span><span class="err">.</span><span class="err">.</span><span class="err">.</span><span class="p" data-group-id="8630987676-1">]</span><span class="w">
    </span><span class="nt">&quot;mappings&quot;</span><span class="p">:</span><span class="w"> </span><span class="err">[</span><span class="w">
        </span><span class="p" data-group-id="8630987676-2">{</span><span class="w">
            </span><span class="nt">&quot;endpoint&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/%{itemIndex}/value&quot;</span><span class="p">,</span><span class="w">
            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;integer&quot;</span><span class="w">
        </span><span class="p" data-group-id="8630987676-2">}</span><span class="p">,</span><span class="w">
        </span><span class="p" data-group-id="8630987676-3">{</span><span class="w">
            </span><span class="nt">&quot;endpoint&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/%{itemIndex}/otherValue&quot;</span><span class="p">,</span><span class="w">
            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;string&quot;</span><span class="w">
        </span><span class="p" data-group-id="8630987676-3">}</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="8630987676-4">[</span><span class="err">.</span><span class="err">.</span><span class="err">.</span><span class="p" data-group-id="8630987676-4">]</span></code></pre><p>Additional limitations (which stem from the MQTT protocol specification) can be outlined. When using
parametric endpoints, the actual values used in place of parameter placeholders must fulfill the
following requirements:</p><ul><li>endpoint parameters must be non-empty UTF-8 encoded strings;</li><li>endpoint parameters must not contain the following characters: <code class="inline">+</code> and <code class="inline">#</code>. Those characters are
treated as wildcards for MQTT topics and therefore must be avoided;</li><li>endpoint parameters must not contain the <code class="inline">/</code> character.</li></ul><h2 id="aggregation" class="section-heading">
  <a href="#aggregation" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">aggregation</p>
  </a>
  Aggregation
</h2>
<p>In a real world scenario, such as an array of sensors, there are usually two main
cases. A sensor might have one or more independent values which are sampled individually and sent
whenever they become available independently. Or a sensor might sample at the same time a number of
values, which might as well have some form of correlation.</p><p>In Astarte, this concept is mapped to interface <code class="inline">aggregation</code>. In case aggregation is <code class="inline">individual</code>,
each mapping is treated as an independent value and is managed individually. In case aggregation is
<code class="inline">object</code>, Astarte expects the owner to send all of the interface's mappings at the same time, packed
in a single message. In this case, all of the mappings share some core properties such as the
timestamp.</p><p>Aggregation is a powerful mechanism that can be used to map interfaces to real world <em>&quot;objects&quot;</em>.
Moreover, aggregated interfaces can also be parametrized, although with <a href="#limitations">some
limitations</a>.</p><h3 id="endpoints-and-aggregation" class="section-heading">
  <a href="#endpoints-and-aggregation" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">endpoints-and-aggregation</p>
  </a>
  Endpoints and aggregation
</h3>
<p>Since Astarte 0.11, Aggregations cannot have endpoints with depth 1. This was an erroneously allowed
behavior in Astarte 0.10 which is kept for retrocompatibility - however, new interfaces should ensure
each endpoint in an aggreate has at least depth 2, as support for depth 1 will be removed in a future
release. This change has been done to be consistent with AppEngine API design, and to ensure that
path <code class="inline">/</code> is not ambiguous.</p><p>This is the correct way to set up a valid endpoint structure for an aggregate:</p><pre><code class="makeup json" translate="no"><span class="w">    </span><span class="p" data-group-id="6050422319-1">[</span><span class="err">.</span><span class="err">.</span><span class="err">.</span><span class="p" data-group-id="6050422319-1">]</span><span class="w">
    </span><span class="nt">&quot;mappings&quot;</span><span class="p">:</span><span class="w"> </span><span class="err">[</span><span class="w">
        </span><span class="p" data-group-id="6050422319-2">{</span><span class="w">
            </span><span class="nt">&quot;endpoint&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/objects/value&quot;</span><span class="p">,</span><span class="w">
            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;integer&quot;</span><span class="w">
        </span><span class="p" data-group-id="6050422319-2">}</span><span class="p">,</span><span class="w">
        </span><span class="p" data-group-id="6050422319-3">{</span><span class="w">
            </span><span class="nt">&quot;endpoint&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/objects/otherValue&quot;</span><span class="p">,</span><span class="w">
            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;string&quot;</span><span class="w">
        </span><span class="p" data-group-id="6050422319-3">}</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="6050422319-4">[</span><span class="err">.</span><span class="err">.</span><span class="err">.</span><span class="p" data-group-id="6050422319-4">]</span></code></pre><p>The following structure, instead, is deprecated:</p><pre><code class="makeup json" translate="no"><span class="w">    </span><span class="p" data-group-id="8321845380-1">[</span><span class="err">.</span><span class="err">.</span><span class="err">.</span><span class="p" data-group-id="8321845380-1">]</span><span class="w">
    </span><span class="nt">&quot;mappings&quot;</span><span class="p">:</span><span class="w"> </span><span class="err">[</span><span class="w">
        </span><span class="p" data-group-id="8321845380-2">{</span><span class="w">
            </span><span class="nt">&quot;endpoint&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/value&quot;</span><span class="p">,</span><span class="w">
            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;integer&quot;</span><span class="w">
        </span><span class="p" data-group-id="8321845380-2">}</span><span class="p">,</span><span class="w">
        </span><span class="p" data-group-id="8321845380-3">{</span><span class="w">
            </span><span class="nt">&quot;endpoint&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;/otherValue&quot;</span><span class="p">,</span><span class="w">
            </span><span class="nt">&quot;type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;string&quot;</span><span class="w">
        </span><span class="p" data-group-id="8321845380-3">}</span><span class="p">,</span><span class="w">
    </span><span class="p" data-group-id="8321845380-4">[</span><span class="err">.</span><span class="err">.</span><span class="err">.</span><span class="p" data-group-id="8321845380-4">]</span></code></pre><h2 id="datastream-specific-features" class="section-heading">
  <a href="#datastream-specific-features" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">datastream-specific-features</p>
  </a>
  Datastream-specific features
</h2>
<p><code class="inline">datastream</code> interfaces are highly tunable, depending on the kind of
data they are representing: it is possible to fine tune several aspects of how data is stored,
transferred and indexed. The following properties can be set at mapping level.</p><blockquote><p>NOTE: In case the interface is aggregated, additional properties must
be the same for each mapping.</p></blockquote><ul><li><code class="inline">explicit_timestamp</code>: By default, Astarte associates a timestamp to data whenever it is collected
(or - when the message hits the data collection stage). However, when setting this property to
<code class="inline">true</code>, Astarte expects the owner to attach a valid timestamp each time it produces data. In that
case, the provided timestamp is used for indexing.</li><li><code class="inline">reliability</code>: Each mapping can be <code class="inline">unreliable</code> (default), <code class="inline">guaranteed</code>, <code class="inline">unique</code>. This defines
whether data should be considered delivered when the transport successfully sends the data
regardless of the outcome (<code class="inline">unreliable</code>), when data has been received at least once by the
recipient (<code class="inline">guaranteed</code>) or when data has been received exactly once by the recipient (<code class="inline">unique</code>).
When using reliable data, consider you might incur in additional resource usage on both the
transport and the device's end.</li><li><code class="inline">retention</code>: Each mapping can have a <code class="inline">discard</code> (default), <code class="inline">volatile</code>, <code class="inline">stored</code> retention. This
defines whether data should be discarded if the transport is temporarily uncapable of delivering
it (<code class="inline">discard</code>), should be kept in a cache in memory (<code class="inline">volatile</code>) or on disk (<code class="inline">stored</code>), and
guaranteed to be delivered in the timeframe defined by the <code class="inline">expiry</code>.</li><li><code class="inline">expiry</code>: Meaningful only when <code class="inline">retention</code> is <code class="inline">stored</code>. Defines how many seconds a specific data
entry should be kept before giving up and erasing it from the persistent cache. A value &lt;= 0 means
the persistent cache never expires, and is the default.</li><li><code class="inline">database_retention_policy</code>: Useful only with datastream. Defines whether data should expire
 from the database after a given interval. Valid values are: no_ttl and use_ttl.</li><li><code class="inline">database_retention_ttl</code>: Useful when database_retention_policy is <code class="inline">&quot;use_ttl&quot;</code>. Defines how many
seconds a specific data entry should be kept before erasing it from the database.</li></ul><h2 id="best-practices" class="section-heading">
  <a href="#best-practices" class="hover-link"><i class="ri-link-m" aria-hidden="true"></i>
  <p class="sr-only">best-practices</p>
  </a>
  Best practices
</h2>
<ul><li>When creating interface drafts, or for testing purposes in general, it is recommended to use 0 as
the major version, to make maintenance and testing easier. Currently, Astarte allows only
interfaces with <code class="inline">major_version</code> == 0 to be deleted, and this limitation will probably be never
lifted to prevent data loss.</li><li>When sending real time commands in <code class="inline">datastream</code> interfaces, <code class="inline">discard</code> is usually the best option.
Even though it does not guarantee delivery, it prevents users from unwillingly sending the same
command over and over if the recipient isn't available, causing a queue of commands to be sent to
the recipient when it gets back online. In general, <a href="#datastream-specific-features"><code class="inline">retention</code></a>
should be used to keep track of low traffic/important events</li></ul>
<div class="bottom-actions">
  <div class="bottom-actions-item">

      <a href="020-components.html" class="bottom-actions-button" rel="prev">
        <span class="subheader">
          ← Previous Page
        </span>
        <span class="title">
Components
        </span>
      </a>

  </div>
  <div class="bottom-actions-item">

      <a href="040-interface_schema.html" class="bottom-actions-button" rel="next">
        <span class="subheader">
          Next Page →
        </span>
        <span class="title">
Interface Schema
        </span>
      </a>

  </div>
</div>
      <footer class="footer">

        <p>
          Built using
          <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.29.0) for the

            <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a>

        </p>
      </footer>
    </div>
  </div>
</section>
</div>


  </body>
</html>
